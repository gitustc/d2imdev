#include <string.h> 
#include "structs.h"
#include "dccinfo.h"
#include "misc.h"
#include "dc6info.h"
#include "animdata.h"
#include "anim.h"


// ==========================================================================
// palshift must point to an array of 256 bytes
int anim_load_dcc(
   char  * name,
   COF_S * cof,
   int   lay_idx,
   long  user_dir,
   UBYTE * palshift
)
{
   LAY_INF_S  * lay;
   DCC_S      * dcc;
   int        entry, i, size, w, h, x, y;
   char       * buff;
   long       dir = 0, len;


   if ((cof == NULL) || (lay_idx >= COMPOSIT_NB))
      return 1;
   lay = & cof->lay_inf[lay_idx];

   // load dcc file
   entry = misc_load_mpq_file(name, & buff, & len, FALSE);
   if (entry == -1)
      return 1;

//  PREPARE DCC
//   typedef struct DCC_S
//   {
//     UBYTE           * ptr; // copy of the dcc in mem
//     long            size;  // size of the dcc in mem (in bytes)
//     DCC_HEADER_S    header;
//     DCC_DIRECTION_S direction [DCC_MAX_DIR];
//     DCC_FRAME_S     frame     [DCC_MAX_DIR] [DCC_MAX_FRAME];
//     DCC_BOX_S       box;
//   } DCC_S;



//  ’‚∏ˆ∫Ø ˝æÕ◊ˆ¡À’‚√¥“ªº˛ ¬«È:
//      1.∑÷≈‰dccΩ·ππÃÂƒ⁄¥Ê
//      2.∞—buff÷–µƒlen≥§◊÷Ω⁄øΩ±¥µΩdcc->ptr : memcpy(dcc->ptr, mem_ptr, mem_size);
//      3.∑µªÿdcc÷∏œÚƒ⁄¥Ê, –Ë“™ ÷∂Ø Õ∑≈
   dcc = dcc_mem_load(buff, len);
   free(buff);
   if (dcc == NULL)
      return 1;

   // choose direction
   switch (cof->dir)
   {
       //≤È±Ì
      case  1 : dir = glb_ds1edit.new_dir1[user_dir];  break;
      case  4 : dir = glb_ds1edit.new_dir4[user_dir];  break;
      case  8 : dir = glb_ds1edit.new_dir8[user_dir];  break;
      case 16 : dir = glb_ds1edit.new_dir16[user_dir]; break;
      case 32 : dir = glb_ds1edit.new_dir32[user_dir]; break;
   }

   // decode dcc direction
   if (dcc_decode(dcc, 1 << dir))
   {
      dcc_destroy(dcc);
      return 1;
   }

   // allocate the bitmaps
   size = dcc->header.frames_per_dir * sizeof(BITMAP *);
   lay->bmp_num = dcc->header.frames_per_dir;
   lay->bmp = (BITMAP **) malloc(size);
   if (lay->bmp == NULL)
   {
      dcc_destroy(dcc);
      return 1;
   }
   memset(lay->bmp, 0, size);
   
   // copy the bitmaps
   w = dcc->frame[dir][0].bmp->w;
   h = dcc->frame[dir][0].bmp->h;
   lay->off_x = dcc->direction[dir].box.xmin;
   lay->off_y = dcc->direction[dir].box.ymin;
   for (i=0; i < dcc->header.frames_per_dir; i++)
   {

      lay->bmp[i] = create_bitmap(w, h);

      if (lay->bmp[i] == NULL){
         while (i)
         {
            i--;
            destroy_bitmap(lay->bmp[i]);
         }
         dcc_destroy(dcc);
         return 1;
      }

      if (palshift){
         for (y=0; y<h; y++)
            for (x=0; x<w; x++)
               putpixel(lay->bmp[i], x, y, palshift[getpixel(dcc->frame[dir][i].bmp, x, y)]);
      }else{
          //–¥»ÎµΩlay->bmp[i]
         blit(dcc->frame[dir][i].bmp, lay->bmp[i], 0, 0, 0, 0, w, h);
      }
   }

   // end
   dcc_destroy(dcc);
   return 0;
}


// ==========================================================================
COF_S * anim_load_cof(char * base, char * tok, char * mod, char * clas, long user_dir, int obj_line, int progress)
{
    TXT_S       * txt  = glb_ds1edit.obj_buff;
    TXT_S       * txt2 = glb_ds1edit.objects_buff;

    COF_S       * cof;
    char        * buff;
    char        * bptr;
    char        * sptr;
    char        * pal_name;
    char        * pal_buff;
    long        * lptr;

    char        animdata_name[80];
    char        name[256];
    long        pal_idx=0;
    long        pal_len;
    long        id;
    long        line;
    long        animdata_fpd;
    long        animdata_speed;
    long        len;

    int         i;
    int         size;
    int         entry;
    int         idx;
    int         done;
    int         mode;

    char  comp_str[COMPOSIT_NB][3] = {
        {"HD"}, {"TR"}, {"LG"}, {"RA"}, {"LA"}, {"RH"}, {"LH"}, {"SH"},
        {"S1"}, {"S2"}, {"S3"}, {"S4"}, {"S5"}, {"S6"}, {"S7"}, {"S8"} };


    if (progress) {
        printf("\n");
    }

    // load palshift
    pal_buff = NULL;
    if (txt->col[misc_get_txt_column_num(RQ_OBJ, "Colormap")].size && txt->col[misc_get_txt_column_num(RQ_OBJ, "Index")].size) {
        pal_name = txt->data + (obj_line * txt->line_size) + txt->col[misc_get_txt_column_num(RQ_OBJ, "Colormap")].offset;
        sptr     = txt->data + (obj_line * txt->line_size) + txt->col[misc_get_txt_column_num(RQ_OBJ, "Index")].offset;
        pal_idx  = * ((long *) sptr);
        if (pal_name[0] && pal_idx) {
            if (progress) {
                printf("load colormap <%s>, will use index %li\n", pal_name, pal_idx);
                fflush(stdout);
            }
            entry = misc_load_mpq_file(pal_name, & pal_buff, & pal_len, progress);
            if (entry != -1) {
                // ’‚ «‘⁄∏„…Ò¬Ì???
                pal_idx = (pal_idx - 1) * 256;
                if ((pal_idx + 255) >= pal_len) {
                    free(pal_buff);
                    pal_buff = NULL;
                }
            } else if (progress) {
                printf("   (couldn't load the colormap)\n");
                fflush(stdout);
            }
        }
    }

    // load cof
    //‘≠¿¥√˚◊÷ «’‚√¥ππ≥…µƒ~
    sprintf( name, "%s\\%s\\Cof\\%s%s%s.cof", base, tok, tok, mod, clas );
    // µ˜ ‘µƒ ±∫Ú:
    // base: Data\Global\Monsters
    // tok : JA
    // mod : NU
    // clas: HTH
    if (progress) {
        printf("\nload COF <%s>\n", name);
        fflush(stdout);
    }
    //’‚∏ˆ∫Ø ˝ª·œ»‘⁄demo_data÷– ‘ ‘,≤ª––‘Ÿ‘⁄mpq÷–’“
    entry = misc_load_mpq_file(name, & buff, & len, progress);
    if (entry == -1) {
        return NULL;
    }

    // allocate COF_S structure
    size = sizeof(COF_S);
    cof  = (COF_S *) malloc(size);
    if (cof == NULL) {
        free(buff);
        return NULL;
    }
    memset(cof, 0, size);

    // fill it

    cof->cur_dir = user_dir;

    bptr = buff;

    // layers
    cof->lay = * bptr;
    bptr++;

    // printf( "lay = %3d\n", cof->lay );

        // lay =   3
        // lay =   1
        // lay =   1
        // lay =   1
        // lay =   1
        // lay =   1
        // lay =   1
        // lay =   2
        // lay =   2
        // lay =   2

    // frames per direction
    //‹≥..’‚√¥∆Ê›‚µƒÀı–¥
    //√ø∏ˆ≥ØœÚµƒframe ˝¡ø
    //Œ“¿’∏ˆ≤¡≤¡..Œ“æ”»ªø¥µΩ¡À“ª∏ˆcof->fpd == 60 µƒ....
    cof->fpd = * bptr;
    //¥”’‚¿Ôø¥µƒª∞...√≤À∆ «“ª∏ˆ∂Ø◊˜æÕ”–60...
    //≤ª»ª≤ªƒ‹’‚—˘rand()“ªœ¬µƒ...≥˝∑« «“ª¿‡∂Ø◊˜..±»»Á’æ◊≈∫Õ’æ◊≈“°Õ∑÷Æ¿‡
    cof->cur_frame = rand() % cof->fpd;
    bptr++;

    // directions
    //ø¥µΩµƒ’‚∏ˆŒ™1...Œ“≤¡
    cof->dir = * bptr;
    bptr++;

    // skip 25 unknown bytes
    bptr += 25;

    // layers infos
    // Œ“ø¥µΩµƒ’‚∏ˆ¿˝◊”÷–lay «3
	// µ´ «lay≤ª“ª∂®◊‹ «3
    for (i=0; i < cof->lay; i++) {
        // composit index
        // ∫‹∆Êπ÷, ’‚∏ˆlay «…Ò¬Ì
        // …œ√Ê“≤ø¥µΩ¡À, lay’‚∏ˆ±‰¡ø1,2,3≤ªµ»
        // √ø∏ˆ∑÷¡ø∂º”–shadow, transparency, ªπ”–weapon’‚»˝∏ˆ∑÷¡ø
        //
        // size = cof->dir * cof->fpd * cof->lay;
        // cof->priority = (UBYTE *) malloc(size);
        //
        // ‘Ÿ¥”’‚¿Ô¿¥ø¥..√ø“ªframe∂º”–lay∏ˆpriority
        // Œ“œ÷‘⁄ªπ «≤ªÃ´√˜¡À√ø“ª∏ˆlayµΩµ◊ «…Ò¬Ì
        // ”¶∏√ «Õ¨“ª÷÷∂´Œ˜µƒ≤ªÕ¨–ŒÃ¨???
        idx = * bptr;
        bptr++;

        // shadows
        cof->lay_inf[idx].shad_a = * bptr;
        bptr++;
        cof->lay_inf[idx].shad_b = * bptr;
        bptr++;

        // transparency
        cof->lay_inf[idx].trans_a = * bptr;
        bptr++;
        cof->lay_inf[idx].trans_b = * bptr;
        bptr++;

        // weapon class (used to know a part of the dcc name)
        // Œ“µ˜ ‘µƒ ±∫Ú’‚¿Ô «"HTH", ”–4∏ˆ◊÷Ω⁄, µ´ «√ª”√ÕÍπ˛
        memcpy(cof->lay_inf[idx].wclass, bptr, 4);
        bptr += 4;

        // dcc / dc6
        //HD±Ì æ…∂?
        sptr = txt->data + (obj_line * txt->line_size) + txt->col[misc_get_txt_column_num(RQ_OBJ, "HD") + idx].offset;
        sprintf(name, "%s\\%s\\%s\\%s%s%s%s%s.dcc", base, tok, comp_str[idx], tok, comp_str[idx], sptr, mod, cof->lay_inf[idx].wclass);

        if (progress) {
            printf("\nload DCC <%s>\n", name);
            fflush(stdout);
        }

        if (strlen(name)) {
            if ((pal_buff != NULL) && (cof->lay_inf[idx].trans_a == 0)) {
                // a colormap, and not on 1 alpha-blended layer
                // try to load a dcc
                if (anim_load_dcc(name, cof, idx, user_dir, (UBYTE *) (pal_buff + pal_idx))) {
                    // try with a .dc6 instead of a .dcc
                    printf("DEBUG: +++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
                    printf("DEBUG: LOADING FAIL....\n");
                    name[strlen(name) - 1] = '6';
                    printf("DEBUG: TRY LOADING <%s>\n",name);
                    printf("DEBUG: +++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
                    anim_load_dc6(name, cof, idx, user_dir, (UBYTE *) (pal_buff + pal_idx));
                }
            } else {
                // don't use a colormap
                // try to load a dcc
                //º”‘ÿdcc √ª”–ø¥∂Æ..Ã´¬È∑≥¡À
                if (anim_load_dcc(name, cof, idx, user_dir, NULL)) {
                    // try with a .dc6 instead of a .dcc
                    // .dcc => .dc6
                    // Œ“ ‘π˝, ’‚∏ˆµÿ∑Ωdcc∫Õdc6∂º «”–µƒ

                    printf("DEBUG: +++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
                    printf("DEBUG: LOADING FAIL....\n");
                    name[strlen(name) - 1] = '6';
                    printf("DEBUG: TRY LOADING <%s>\n",name);
                    printf("DEBUG: +++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
                    //∂Øª≠ «“‘.dc6µƒ∑Ω Ω¥Ê¥¢µƒ
                    //≤ªπ˝Œ“√ªø¥µΩœ‡¡⁄frameµƒ ±º‰≤Ó
                    //frameµƒms_deltaøÿ÷∆‘⁄Õ‚±ﬂ..”–“ª∏ˆƒ¨»œ÷µ...
                    anim_load_dc6(name, cof, idx, user_dir, NULL);
                }
            }
        }
    }

    // skip flags of each frames
    //√ø∏ˆframeµƒflag «“ª∏ˆchar
    //÷±Ω”Ã¯π˝¡ÀÀ˘”–µƒchars
    bptr += cof->fpd;

    // priority layer

    // allocate
    //dir «∏ˆ∑ΩœÚ◊‹ ˝..≤ªÕ¨µƒ∑ΩœÚ◊‹ ˝”–≤ªÕ¨µƒ∑ΩœÚ±Ì
    //»ª∫Û ˝æ›∞¥’’±Ì÷–µƒÀ≥–Ú¥Ê¥¢

    size = cof->dir * cof->fpd * cof->lay;
    cof->priority = (UBYTE *) malloc(size);
    if (cof->priority == NULL) {
        free(cof);
        free(buff);
        return NULL;
    }

    // fill
    memcpy(cof->priority, bptr, size);

    // default animation speed
    //ƒ¨»œµƒ..ƒ—π÷‘⁄dc6÷–√ª”–’“µΩ
    cof->spd_mul = 1;
    cof->spd_div = 256;

    // default x and y offsets
    cof->xoffset = cof->yoffset = 0;

    // speed info : try in animdata.d2
    sprintf(animdata_name, "%s%s%s", tok, mod, clas);
    if (animdata_get_cof_info(animdata_name, & animdata_fpd, & animdata_speed) == 0) {
        // found
        //      cof->fpd     = animdata_fpd;
        cof->spd_mul = animdata_speed; // can be override by objects.txt values
        cof->spd_div = 256;
    }

    // objects.txt ID of that obj
    sptr = txt->data + (obj_line * txt->line_size) + txt->col[glb_ds1edit.col_obj_id].offset;
    lptr = (long *) sptr;
    id   = * lptr;
    printf("object %s ID = %li\n", name, id);


    // which mode is this obj ?
    if (stricmp(mod, "NU") == 0) {
        mode = 0;
    } else if (stricmp(mod, "OP") == 0) {
        mode = 1;
    } else if (stricmp(mod, "ON") == 0) {
        mode = 2;
    } else if (stricmp(mod, "S1") == 0) {
        mode = 3;
    } else if (stricmp(mod, "S2") == 0) {
        mode = 4;
    } else if (stricmp(mod, "S3") == 0) {
        mode = 5;
    } else if (stricmp(mod, "S4") == 0) {
        mode = 6;
    } else if (stricmp(mod, "S5") == 0) {
        mode = 7;
    } else {
        // invalid object's mode, or simply not an object COF (like a monster COF)
        // end
        free(buff);
        if (pal_buff) {
            free(pal_buff);
        }
        return cof;
    }

    // search line in objects.txt for this ID
    if (id) {
        done                                        = FALSE;
        i                                           = 0;
        line                                        = 0;
        glb_ds1edit.obj_desc[obj_line].objects_line = -1;
        while ( ! done) {
            sptr = txt2->data + (i * txt2->line_size) + txt2->col[glb_ds1edit.col_objects_id].offset;
            lptr = (long *) sptr;
            if ( (* lptr) == id) {
                done = TRUE;
                line = i;
            } else {
                i++;
                if (i >= txt2->line_num) {
                    // end
                    free(buff);
                    if (pal_buff) {
                        free(pal_buff);
                    }
                    return cof;
                }
            }
        }
        glb_ds1edit.obj_desc[obj_line].objects_line = line;

        // speed multiplicator
        sptr = txt2->data + (line * txt2->line_size) + txt2->col[glb_ds1edit.col_frame_delta[mode]].offset;
        lptr = (long *) sptr;
        cof->spd_mul = (* lptr) == 0 ? 256 : (* lptr);

        // speed divisor
        cof->spd_div = 256;

        // xoffset & yoffset
        if (txt2->col[misc_get_txt_column_num(RQ_OBJECTS, "Xoffset")].size) {
            sptr         = txt2->data + (line * txt2->line_size) + txt2->col[misc_get_txt_column_num(RQ_OBJECTS, "Xoffset")].offset;
            lptr         = (long *) sptr;
            cof->xoffset = * lptr;
        }
        if (txt2->col[misc_get_txt_column_num(RQ_OBJECTS, "Yoffset")].size) {
            sptr         = txt2->data + (line * txt2->line_size) + txt2->col[misc_get_txt_column_num(RQ_OBJECTS, "Yoffset")].offset;
            lptr         = (long *) sptr;
            cof->yoffset = * lptr;
        }

        // orderflag
        if (txt2->col[glb_ds1edit.col_orderflag[mode]].size) {
            sptr           = txt2->data + (line * txt2->line_size) + txt2->col[glb_ds1edit.col_orderflag[mode]].offset;
            lptr           = (long *) sptr;
            cof->orderflag = * lptr;

            // if 0, check NU
            // because Mephisto bridge only have a 1 in the NU mode
            if ( * lptr == 0) {
                if (txt2->col[glb_ds1edit.col_orderflag[0]].size) {
                    sptr           = txt2->data + (line * txt2->line_size) + txt2->col[glb_ds1edit.col_orderflag[0]].offset;
                    lptr           = (long *) sptr;
                    cof->orderflag = * lptr;
                }
            }

            printf("object %s orderflag = %li\n", name, cof->orderflag);
        }
    }

    // end
    free(buff);
    if (pal_buff) {
        free(pal_buff);
    }
    return cof;
}


// ==========================================================================
COF_S * anim_load_desc_gfx(int i, int progress)
{
    TXT_S        * txt = glb_ds1edit.obj_buff;
    COF_S        * cof = NULL;
    char         * base;
    char         * tok;
    char         * mod;
    char         * clas;
    char         *sptr;
    long         * dirptr;

    long         dir;


    if (txt == NULL) {
        return NULL;
    }

    base   = txt->data + (i * txt->line_size) + txt->col[misc_get_txt_column_num(RQ_OBJ, "Base")].offset;
    tok    = txt->data + (i * txt->line_size) + txt->col[misc_get_txt_column_num(RQ_OBJ, "Token")].offset;
    mod    = txt->data + (i * txt->line_size) + txt->col[misc_get_txt_column_num(RQ_OBJ, "Mode")].offset;
    clas   = txt->data + (i * txt->line_size) + txt->col[misc_get_txt_column_num(RQ_OBJ, "Class")].offset;
    sptr   = txt->data + (i * txt->line_size) + txt->col[misc_get_txt_column_num(RQ_OBJ, "Direction")].offset;

    dirptr = (long *) sptr;

    dir = 0;
    if (txt->col[misc_get_txt_column_num(RQ_OBJ, "Direction")].size) {
        dir = * dirptr;
    }
    // ø¥, √ø∏ˆcofæÕ «’‚—˘À˜“˝µƒ
    // »ª∫ÛÕ®π˝hashµΩƒ⁄≤ø—∞’“

    if (base[0] && tok[0] && mod[0] && clas[0]) {
        printf("base=%10s tok=%4s mod=%4s clas=%4s\n", base,tok,mod,clas);
        cof = anim_load_cof(base, tok, mod, clas, dir, i, progress);
    }

    return cof;
}


// ==========================================================================
int anim_destroy_cof(COF_S * cof)
{
    BITMAP      ** bmp;

    int         b, max_b, c;
    int         size = 0;

    if (cof == NULL) {
        return 0;
    }

    // free bitmaps
    for (c=0; c < COMPOSIT_NB; c++) {
        // πÿ”⁄’‚∏ˆbmp ”–∏ˆ◊¢ Õ «only for editor!?
        bmp = cof->lay_inf[c].bmp;
        if (bmp != NULL) {
            max_b = cof->lay_inf[c].bmp_num;
            for (b=0; b < max_b; b++) {
                if (bmp[b] != NULL) {
                    size += sizeof(BITMAP);
                    size += bmp[b]->w * bmp[b]->h;
                    destroy_bitmap(bmp[b]);
                }
            }
            size += max_b * sizeof (BITMAP *);
            free(bmp);
        }
    }

    // free priority
    if (cof->priority != NULL) {
        size += cof->dir * cof->fpd * cof->lay;
        free(cof->priority);
    }

    // free cof
    size += sizeof(COF_S);
    free(cof);

    // end
    return size;
}


// ==========================================================================
void anim_update_gfx(int progress)
{
    COF_S       * cof;
    TXT_S       * txt = glb_ds1edit.obj_buff;

    int         d, od, o, idx;
    int         ds1_anim_used;

    if (txt == NULL) {
        return;
    }

    // counters to zero
    for (od=0; od < txt->line_num; od++) {
        // Œ“µ˜ ‘µƒ ±∫Úline_num «1050
        // ƒ—µ¿obj «∂‡µƒ, objects «…Ÿµƒ
        // “ÚŒ™µ˜ ‘objectsµƒ ±∫ÚæÕ48∏ˆ◊Û”“
        glb_ds1edit.obj_desc[od].usage_count = 0;
    }

    // update the counters


    //glb_dt1
    //dlb_ds1
    //glb_ds1edit
    for (d=0; d < DS1_MAX; d++) {
        if (glb_ds1[d].name[0] == 0) {
            continue;
        }
        for (o=0; o < glb_ds1[d].obj_num; o++) {
            idx = glb_ds1[d].obj[o].desc_idx;
            if (idx != -1) {
                // Õ≥º∆ π”√¥Œ ˝
                glb_ds1edit.obj_desc[idx].usage_count++;
            }
        }
    }

    // update cof datas
    for (od=0; od < txt->line_num; od++) {
        cof = glb_ds1edit.obj_desc[od].cof;
        if (glb_ds1edit.obj_desc[od].usage_count == 0) {
            // don't have to be used
            if (cof != NULL) {
                // cof exists so delete it
                anim_destroy_cof(cof);
                glb_ds1edit.obj_desc[od].cof = NULL;
            }
        } else {
            // have to be used
            if (cof == NULL) {
                //√ø∏ˆ π”√÷–µƒobj∂º–Ë“™”–“ª∏ˆcof
                //√ª”–µƒª∞æÕ»•load“ª∏ˆ
                // no cof, so load it
                glb_ds1edit.obj_desc[od].cof = anim_load_desc_gfx(od, progress);
                if (progress) {
                    fprintf(stderr, ".");
                    fflush(stderr);
                }
            }
        }
    }

    // if no animations at all for a ds1, disable the animation layer mask
    for (d=0; d < DS1_MAX; d++)
    {
        if (glb_ds1[d].name[0] == 0)
            continue;
        ds1_anim_used = FALSE;
        for (o=0; o < glb_ds1[d].obj_num; o++)
        {
            idx = glb_ds1[d].obj[o].desc_idx;
            if (idx != -1)
            {
                if (glb_ds1edit.obj_desc[idx].cof != NULL)
                {
                    ds1_anim_used = TRUE;
                    o = glb_ds1[d].obj_num; // stop the check of all objects
                }
            }
        }
        if (ds1_anim_used == FALSE)
            glb_ds1[d].animations_layer_mask = 0;
    }
}


// ==========================================================================
int anim_exit(void)
{
   TXT_S  * txt = glb_ds1edit.obj_buff;
   COF_S  * cof;
   int    i, size = 0;


   if (txt == NULL)
      return 0;
   if (glb_ds1edit.obj_desc == NULL)
      return 0;
      
   for (i=0; i < txt->line_num; i++)
   {
      cof = glb_ds1edit.obj_desc[i].cof;
      if (cof != NULL)
      {
         size += anim_destroy_cof(cof);
         glb_ds1edit.obj_desc[i].cof = NULL;
      }
   }
   return size;
}
#include <string.h>
#include <ctype.h>
#include "structs.h"
#include "misc.h"
#include "animdata.h"
 

// ==========================================================================
UBYTE animdata_hash_value(char * name)
{

    // Ëøô‰∏™ÂáΩÊï∞ËæìÂÖ•ÁöÑnameÂíåËæìÂá∫ÁöÑhashÂÄºÂ∞±ÊòØËøô‰∏™..


    //   block   0:    animdata_name = L1OPHTH,          hash =   0,    nb_records =    54
    //   block   1:    animdata_name = L2OPHTH,          hash =   1,    nb_records =    57
    //   block   2:    animdata_name = F9OPHTH,          hash =   2,    nb_records =    53
    //   block   3:    animdata_name = Q1ONHTH,          hash =   3,    nb_records =    42
    //   block   4:    animdata_name = S0ONHTH,          hash =   4,    nb_records =    41
    //   block   5:    animdata_name = S1ONHTH,          hash =   5,    nb_records =    51
    //   block   6:    animdata_name = S2ONHTH,          hash =   6,    nb_records =    54
    //   block   7:    animdata_name = U1ONHTH,          hash =   7,    nb_records =    40
    //   block   8:    animdata_name = U2ONHTH,          hash =   8,    nb_records =    47
    //   block   9:    animdata_name = W1ONHTH,          hash =   9,    nb_records =    62
    //   block  10:    animdata_name = W2ONHTH,          hash =  10,    nb_records =    67
    //   block  11:    animdata_name = Y1ONHTH,          hash =  11,    nb_records =    63
    //   block  12:    animdata_name = Z1ONHTH,          hash =  12,    nb_records =    60
    //   block  13:    animdata_name = Z2ONHTH,          hash =  13,    nb_records =    64
    //   block  14:    animdata_name = Z3ONHTH,          hash =  14,    nb_records =    60
    //   block  15:    animdata_name = Z4ONHTH,          hash =  15,    nb_records =    60
    //   block  16:    animdata_name = Z5ONHTH,          hash =  16,    nb_records =    59
    //   block  17:    animdata_name = Z4OPHTH,          hash =  17,    nb_records =    62
    //   block  18:    animdata_name = Z5OPHTH,          hash =  18,    nb_records =    58
    //   block  19:    animdata_name = Z2NUHTH,          hash =  19,    nb_records =    57
    //   block  20:    animdata_name = Z3NUHTH,          hash =  20,    nb_records =    48
    //   block  21:    animdata_name = Z4NUHTH,          hash =  21,    nb_records =    51
    //   block  22:    animdata_name = Z5NUHTH,          hash =  22,    nb_records =    45
    //   block  23:    animdata_name = Y7NUHTH,          hash =  23,    nb_records =    38
    //   block  24:    animdata_name = Y8NUHTH,          hash =  24,    nb_records =    34
    //   block  25:    animdata_name = Y9NUHTH,          hash =  25,    nb_records =    40
    //   block  26:    animdata_name = UBOPHTH,          hash =  26,    nb_records =    45
    //   block  27:    animdata_name = YAONHTH,          hash =  27,    nb_records =    35
    //   block  28:    animdata_name = ZAONHTH,          hash =  28,    nb_records =    37
    //   block  29:    animdata_name = YCONHTH,          hash =  29,    nb_records =    54
    //   block  30:    animdata_name = ZCONHTH,          hash =  30,    nb_records =    53
    //   block  31:    animdata_name = ZDONHTH,          hash =  31,    nb_records =    41
    //   block  32:    animdata_name = ZEONHTH,          hash =  32,    nb_records =    50
    //   block  33:    animdata_name = ZDOPHTH,          hash =  33,    nb_records =    43
    //   block  34:    animdata_name = ZEOPHTH,          hash =  34,    nb_records =    47
    //   block  35:    animdata_name = ZHONHTH,          hash =  35,    nb_records =    45
    //   block  36:    animdata_name = ZCNUHTH,          hash =  36,    nb_records =    41
    //   block  37:    animdata_name = ZHOPHTH,          hash =  37,    nb_records =    41
    //   block  38:    animdata_name = ZENUHTH,          hash =  38,    nb_records =    36
    //   block  39:    animdata_name = ZLONHTH,          hash =  39,    nb_records =    36
    //   block  40:    animdata_name = YNONHTH,          hash =  40,    nb_records =    31
    //   block  41:    animdata_name = ZLOPHTH,          hash =  41,    nb_records =    38
    //   block  42:    animdata_name = YPONHTH,          hash =  42,    nb_records =    29
    //   block  43:    animdata_name = YQONHTH,          hash =  43,    nb_records =    19
    //   block  44:    animdata_name = ZQONHTH,          hash =  44,    nb_records =    20
    //   block  45:    animdata_name = ZRONHTH,          hash =  45,    nb_records =    23
    //   block  46:    animdata_name = ZSONHTH,          hash =  46,    nb_records =    26
    //   block  47:    animdata_name = ZROPHTH,          hash =  47,    nb_records =    16
    //   block  48:    animdata_name = ZSOPHTH,          hash =  48,    nb_records =    17
    //   block  49:    animdata_name = ZVONHTH,          hash =  49,    nb_records =    18
    //   block  50:    animdata_name = ZWONHTH,          hash =  50,    nb_records =    17
    //   block  51:    animdata_name = ZVOPHTH,          hash =  51,    nb_records =    12
    //   block  52:    animdata_name = ZYONHTH,          hash =  52,    nb_records =    15
    //   block  53:    animdata_name = YYOPHTH,          hash =  53,    nb_records =    11
    //   block  54:    animdata_name = ZYOPHTH,          hash =  54,    nb_records =    10
    //   block  55:    animdata_name = ZVNUHTH,          hash =  55,    nb_records =     5
    //   block  56:    animdata_name = ZWNUHTH,          hash =  56,    nb_records =     6
    //   block  57:    animdata_name = YYNUHTH,          hash =  57,    nb_records =     3
    //   block  58:    animdata_name = ZYNUHTH,          hash =  58,    nb_records =     4
    //   block  59:    animdata_name = ZZWLHTH,          hash =  59,    nb_records =     2
    //   block  60:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  61:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  62:    animdata_name = SOTWXBW,          hash =  62,    nb_records =     1
    //   block  63:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  64:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  65:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  66:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  67:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  68:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  69:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  70:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  71:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  72:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  73:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  74:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  75:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  76:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  77:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  78:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  79:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  80:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  81:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  82:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  83:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  84:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  85:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  86:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  87:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  88:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  89:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  90:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  91:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  92:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  93:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  94:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  95:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  96:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  97:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  98:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block  99:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 100:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 101:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 102:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 103:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 104:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 105:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 106:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 107:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 108:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 109:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 110:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 111:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 112:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 113:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 114:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 115:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 116:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 117:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 118:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 119:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 120:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 121:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 122:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 123:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 124:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 125:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 126:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 127:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 128:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 129:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 130:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 131:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 132:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 133:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 134:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 135:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 136:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 137:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 138:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 139:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 140:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 141:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 142:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 143:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 144:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 145:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 146:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 147:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 148:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 149:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 150:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 151:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 152:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 153:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 154:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 155:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 156:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 157:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 158:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 159:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 160:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 161:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 162:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 163:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 164:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 165:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 166:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 167:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 168:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 169:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 170:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 171:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 172:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 173:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 174:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 175:    animdata_name = 0AA11HS,          hash = 175,    nb_records =     1
    //   block 176:    animdata_name = 0AA21HS,          hash = 176,    nb_records =     2
    //   block 177:    animdata_name = 0AA22HS,          hash = 177,    nb_records =     1
    //   block 178:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 179:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 180:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 181:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 182:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 183:    animdata_name = 10A1HTH,          hash = 183,    nb_records =     1
    //   block 184:    animdata_name = 10A2HTH,          hash = 184,    nb_records =     1
    //   block 185:    animdata_name = 21A1HTH,          hash = 185,    nb_records =     1
    //   block 186:    animdata_name = 40A1HTH,          hash = 186,    nb_records =     3
    //   block 187:    animdata_name = 40A2HTH,          hash = 187,    nb_records =     3
    //   block 188:    animdata_name = 15A1HTH,          hash = 188,    nb_records =     2
    //   block 189:    animdata_name = 43A1HTH,          hash = 189,    nb_records =     2
    //   block 190:    animdata_name = 44A1HTH,          hash = 190,    nb_records =     2
    //   block 191:    animdata_name = 45A1HTH,          hash = 191,    nb_records =     1
    //   block 192:    animdata_name = 64A1HTH,          hash = 192,    nb_records =     3
    //   block 193:    animdata_name = 65A1HTH,          hash = 193,    nb_records =     2
    //   block 194:    animdata_name = BAA21HS,          hash = 194,    nb_records =     3
    //   block 195:    animdata_name = BAA22HS,          hash = 195,    nb_records =     4
    //   block 196:    animdata_name = BAA22HT,          hash = 196,    nb_records =     3
    //   block 197:    animdata_name = 0ADD1HS,          hash = 197,    nb_records =     2
    //   block 198:    animdata_name = 0ADD2HS,          hash = 198,    nb_records =     1
    //   block 199:    animdata_name =        ,          hash =   0,    nb_records =     0
    //   block 200:    animdata_name = 0BA1HTH,          hash = 200,    nb_records =     2
    //   block 201:    animdata_name = FEA11HS,          hash = 201,    nb_records =     7
    //   block 202:    animdata_name = 20S1HTH,          hash = 202,    nb_records =     8
    //   block 203:    animdata_name = 10S3HTH,          hash = 203,    nb_records =     5
    //   block 204:    animdata_name = F0A1HTH,          hash = 204,    nb_records =     9
    //   block 205:    animdata_name = F0A2HTH,          hash = 205,    nb_records =    10
    //   block 206:    animdata_name = 60S1HTH,          hash = 206,    nb_records =    11
    //   block 207:    animdata_name = 61S1HTH,          hash = 207,    nb_records =    13
    //   block 208:    animdata_name = 62S1HTH,          hash = 208,    nb_records =    14
    //   block 209:    animdata_name = 62S2HTH,          hash = 209,    nb_records =    10
    //   block 210:    animdata_name = 15DDHTH,          hash = 210,    nb_records =     7
    //   block 211:    animdata_name = GMA12HS,          hash = 211,    nb_records =     7
    //   block 212:    animdata_name = GMA22HS,          hash = 212,    nb_records =     9
    //   block 213:    animdata_name = L3A1HTH,          hash = 213,    nb_records =     8
    //   block 214:    animdata_name = L3A2HTH,          hash = 214,    nb_records =     7
    //   block 215:    animdata_name = M4A1HTH,          hash = 215,    nb_records =     6
    //   block 216:    animdata_name = M5A1HTH,          hash = 216,    nb_records =     7
    //   block 217:    animdata_name = M6A1HTH,          hash = 217,    nb_records =     7
    //   block 218:    animdata_name = K9A1HTH,          hash = 218,    nb_records =     5
    //   block 219:    animdata_name = K9A2HTH,          hash = 219,    nb_records =    10
    //   block 220:    animdata_name = D0S1HTH,          hash = 220,    nb_records =    12
    //   block 221:    animdata_name = D1S1HTH,          hash = 221,    nb_records =    20
    //   block 222:    animdata_name = E1S1HTH,          hash = 222,    nb_records =    21
    //   block 223:    animdata_name = E2S1HTH,          hash = 223,    nb_records =    19
    //   block 224:    animdata_name = D4S1HTH,          hash = 224,    nb_records =    21
    //   block 225:    animdata_name = D5S1HTH,          hash = 225,    nb_records =    22
    //   block 226:    animdata_name = D6S1HTH,          hash = 226,    nb_records =    20
    //   block 227:    animdata_name = D7S1HTH,          hash = 227,    nb_records =    17
    //   block 228:    animdata_name = D8S1HTH,          hash = 228,    nb_records =    15
    //   block 229:    animdata_name = D9S1HTH,          hash = 229,    nb_records =    19
    //   block 230:    animdata_name = D9S2HTH,          hash = 230,    nb_records =    26
    //   block 231:    animdata_name = D9S3HTH,          hash = 231,    nb_records =    19
    //   block 232:    animdata_name = D9S4HTH,          hash = 232,    nb_records =    16
    //   block 233:    animdata_name = 62ONHTH,          hash = 233,    nb_records =    17
    //   block 234:    animdata_name = 70OPHTH,          hash = 234,    nb_records =    15
    //   block 235:    animdata_name = N5S1HTH,          hash = 235,    nb_records =    19
    //   block 236:    animdata_name = N6S1HTH,          hash = 236,    nb_records =    23
    //   block 237:    animdata_name = N7S1HTH,          hash = 237,    nb_records =    37
    //   block 238:    animdata_name = DBS1HTH,          hash = 238,    nb_records =    31
    //   block 239:    animdata_name = DBS2HTH,          hash = 239,    nb_records =    29
    //   block 240:    animdata_name = DDS1HTH,          hash = 240,    nb_records =    30
    //   block 241:    animdata_name = DDS2HTH,          hash = 241,    nb_records =    27
    //   block 242:    animdata_name = DDS3HTH,          hash = 242,    nb_records =    27
    //   block 243:    animdata_name = DDS4HTH,          hash = 243,    nb_records =    30
    //   block 244:    animdata_name = C0ONHTH,          hash = 244,    nb_records =    30
    //   block 245:    animdata_name = D0ONHTH,          hash = 245,    nb_records =    29
    //   block 246:    animdata_name = D1ONHTH,          hash = 246,    nb_records =    34
    //   block 247:    animdata_name = DKS1HTH,          hash = 247,    nb_records =    35
    //   block 248:    animdata_name = GIS1HTH,          hash = 248,    nb_records =    43
    //   block 249:    animdata_name = OBS1HTH,          hash = 249,    nb_records =    50
    //   block 250:    animdata_name = F3ONHTH,          hash = 250,    nb_records =    50
    //   block 251:    animdata_name = H2ONHTH,          hash = 251,    nb_records =    46
    //   block 252:    animdata_name = F5ONHTH,          hash = 252,    nb_records =    46
    //   block 253:    animdata_name = H2OPHTH,          hash = 253,    nb_records =    60
    //   block 254:    animdata_name = L1ONHTH,          hash = 254,    nb_records =    55
    //   block 255:    animdata_name = L2ONHTH,          hash = 255,    nb_records =    54

    unsigned int    i;
    unsigned int    nb   = strlen(name);
    UBYTE           hash = 0;

	// ÊâæÂà∞‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤‰∏≠ÁöÑÊúÄÂêé‰∏Ä‰∏™"."ÊâÄÂú®ÁöÑ‰ΩçÁΩÆ
    for (i=0; i < strlen(name); i++) {
        if (name[i] == '.') {
            nb = i;
        }
    }
	// ÂØπÊúÄÂêé‰∏Ä‰∏™"."‰πãÂâçÁöÑÂ≠óÁ¨¶Ê±ÇÂíå, ‰∏çÂåÖÊã¨"."
    // UBYTE           hash = 0;
    // ÊâÄ‰ª•Ê±ÇÂíå‰ºöÊúâÈ´ò‰ΩçÊ∫¢Âá∫ÁöÑ
    for (i=0; i < nb; i++) {
        hash += toupper(name[i]);
    }
    return hash;
}


// ==========================================================================
void animdata_load(void)
{

    // Êúâ‰∏ÄÁßçÊÑüËßâ: ÊàëËôΩÁÑ∂Áü•ÈÅì‰Ω†Âú®Âπ≤‰ªÄ‰πà, ÊàëÂç¥‰∏çÁü•ÈÅì‰Ω†‰∏∫‰ªÄ‰πàËøôÊ†∑Âπ≤
    char               * name = "Data\\Global\\AnimData.d2";
    char				animdata_name[10];
    ANIM_DATA_RECORD_S * rec_ptr = NULL;
    long               * lptr;

    long                 nb_rec;
    int                  entry, done = FALSE, curr_block = 0;
    UBYTE                hash;


    // free the file if already in mem
    if (glb_ds1edit.anim_data.buffer != NULL) {
        free(glb_ds1edit.anim_data.buffer);
    }

    // load it
    memset( & glb_ds1edit.anim_data, 0, sizeof(glb_ds1edit.anim_data) );
    entry = misc_load_mpq_file( name, (char **) & glb_ds1edit.anim_data.buffer, & glb_ds1edit.anim_data.buffer_size, FALSE );
    if ((entry == -1) || (glb_ds1edit.anim_data.buffer_size <= 4)) {
        printf("error : couldn't load <%s>\n", name);
        return;
    } else {
        printf("ok, <%s> found\n", name);
    }

    // read all blocks and update pointers
    lptr = ((long *) glb_ds1edit.anim_data.buffer);

    while ( !done) {

        nb_rec = * lptr;
        lptr++;
        // ‰∏∫‰∫ÜË∞ÉËØï, Ëøô‰∏ÄÂè•ÊòØÊó†ÊâÄË∞ìÁöÑ
        animdata_name[0] = '\0';

        if (nb_rec) {

            //   typedef struct ANIM_DATA_RECORD_S
            //   {
            //      char  cof_name[8];
            //      long  frames_per_dir;
            //      long  speed;
            //      UBYTE flags[144];
            //   } ANIM_DATA_RECORD_S;
            rec_ptr = (ANIM_DATA_RECORD_S *) lptr;
            memset(animdata_name, 0, sizeof(animdata_name));
            strncpy(animdata_name, rec_ptr->cof_name, 8);
            // ÈÄöËøáÈ´ò‰ΩçÊ∫¢Âá∫ÁöÑÊñπÂºèÂØπÂ≠óÁ¨¶‰∏≤Ê±ÇÂíå, ËøõËÄåÂæóÂà∞‰∏Ä‰∏™hashÂÄº
            hash = animdata_hash_value(animdata_name);
        } else {
            hash = 0;
        }

        // debug infos
        printf("   block %3i: animdata_name = %10s, hash = %5i, nb_records = %5li\n", curr_block, animdata_name, hash, nb_rec);

        //   block   0:    animdata_name = L1OPHTH,          hash =   0,    nb_records =    54
        //   block   1:    animdata_name = L2OPHTH,          hash =   1,    nb_records =    57
        //   block   2:    animdata_name = F9OPHTH,          hash =   2,    nb_records =    53
        //   block   3:    animdata_name = Q1ONHTH,          hash =   3,    nb_records =    42
        //   block   4:    animdata_name = S0ONHTH,          hash =   4,    nb_records =    41
        //   block   5:    animdata_name = S1ONHTH,          hash =   5,    nb_records =    51
        //   block   6:    animdata_name = S2ONHTH,          hash =   6,    nb_records =    54
        //   block   7:    animdata_name = U1ONHTH,          hash =   7,    nb_records =    40
        //   block   8:    animdata_name = U2ONHTH,          hash =   8,    nb_records =    47
        //   block   9:    animdata_name = W1ONHTH,          hash =   9,    nb_records =    62
        //   block  10:    animdata_name = W2ONHTH,          hash =  10,    nb_records =    67
        //   block  11:    animdata_name = Y1ONHTH,          hash =  11,    nb_records =    63
        //   block  12:    animdata_name = Z1ONHTH,          hash =  12,    nb_records =    60
        //   block  13:    animdata_name = Z2ONHTH,          hash =  13,    nb_records =    64
        //   block  14:    animdata_name = Z3ONHTH,          hash =  14,    nb_records =    60
        //   block  15:    animdata_name = Z4ONHTH,          hash =  15,    nb_records =    60
        //   block  16:    animdata_name = Z5ONHTH,          hash =  16,    nb_records =    59
        //   block  17:    animdata_name = Z4OPHTH,          hash =  17,    nb_records =    62
        //   block  18:    animdata_name = Z5OPHTH,          hash =  18,    nb_records =    58
        //   block  19:    animdata_name = Z2NUHTH,          hash =  19,    nb_records =    57
        //   block  20:    animdata_name = Z3NUHTH,          hash =  20,    nb_records =    48
        //   block  21:    animdata_name = Z4NUHTH,          hash =  21,    nb_records =    51
        //   block  22:    animdata_name = Z5NUHTH,          hash =  22,    nb_records =    45
        //   block  23:    animdata_name = Y7NUHTH,          hash =  23,    nb_records =    38
        //   block  24:    animdata_name = Y8NUHTH,          hash =  24,    nb_records =    34
        //   block  25:    animdata_name = Y9NUHTH,          hash =  25,    nb_records =    40
        //   block  26:    animdata_name = UBOPHTH,          hash =  26,    nb_records =    45
        //   block  27:    animdata_name = YAONHTH,          hash =  27,    nb_records =    35
        //   block  28:    animdata_name = ZAONHTH,          hash =  28,    nb_records =    37
        //   block  29:    animdata_name = YCONHTH,          hash =  29,    nb_records =    54
        //   block  30:    animdata_name = ZCONHTH,          hash =  30,    nb_records =    53
        //   block  31:    animdata_name = ZDONHTH,          hash =  31,    nb_records =    41
        //   block  32:    animdata_name = ZEONHTH,          hash =  32,    nb_records =    50
        //   block  33:    animdata_name = ZDOPHTH,          hash =  33,    nb_records =    43
        //   block  34:    animdata_name = ZEOPHTH,          hash =  34,    nb_records =    47
        //   block  35:    animdata_name = ZHONHTH,          hash =  35,    nb_records =    45
        //   block  36:    animdata_name = ZCNUHTH,          hash =  36,    nb_records =    41
        //   block  37:    animdata_name = ZHOPHTH,          hash =  37,    nb_records =    41
        //   block  38:    animdata_name = ZENUHTH,          hash =  38,    nb_records =    36
        //   block  39:    animdata_name = ZLONHTH,          hash =  39,    nb_records =    36
        //   block  40:    animdata_name = YNONHTH,          hash =  40,    nb_records =    31
        //   block  41:    animdata_name = ZLOPHTH,          hash =  41,    nb_records =    38
        //   block  42:    animdata_name = YPONHTH,          hash =  42,    nb_records =    29
        //   block  43:    animdata_name = YQONHTH,          hash =  43,    nb_records =    19
        //   block  44:    animdata_name = ZQONHTH,          hash =  44,    nb_records =    20
        //   block  45:    animdata_name = ZRONHTH,          hash =  45,    nb_records =    23
        //   block  46:    animdata_name = ZSONHTH,          hash =  46,    nb_records =    26
        //   block  47:    animdata_name = ZROPHTH,          hash =  47,    nb_records =    16
        //   block  48:    animdata_name = ZSOPHTH,          hash =  48,    nb_records =    17
        //   block  49:    animdata_name = ZVONHTH,          hash =  49,    nb_records =    18
        //   block  50:    animdata_name = ZWONHTH,          hash =  50,    nb_records =    17
        //   block  51:    animdata_name = ZVOPHTH,          hash =  51,    nb_records =    12
        //   block  52:    animdata_name = ZYONHTH,          hash =  52,    nb_records =    15
        //   block  53:    animdata_name = YYOPHTH,          hash =  53,    nb_records =    11
        //   block  54:    animdata_name = ZYOPHTH,          hash =  54,    nb_records =    10
        //   block  55:    animdata_name = ZVNUHTH,          hash =  55,    nb_records =     5
        //   block  56:    animdata_name = ZWNUHTH,          hash =  56,    nb_records =     6
        //   block  57:    animdata_name = YYNUHTH,          hash =  57,    nb_records =     3
        //   block  58:    animdata_name = ZYNUHTH,          hash =  58,    nb_records =     4
        //   block  59:    animdata_name = ZZWLHTH,          hash =  59,    nb_records =     2
        //   block  60:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  61:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  62:    animdata_name = SOTWXBW,          hash =  62,    nb_records =     1
        //   block  63:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  64:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  65:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  66:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  67:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  68:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  69:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  70:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  71:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  72:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  73:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  74:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  75:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  76:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  77:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  78:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  79:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  80:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  81:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  82:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  83:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  84:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  85:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  86:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  87:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  88:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  89:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  90:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  91:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  92:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  93:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  94:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  95:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  96:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  97:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  98:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block  99:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 100:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 101:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 102:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 103:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 104:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 105:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 106:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 107:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 108:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 109:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 110:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 111:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 112:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 113:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 114:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 115:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 116:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 117:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 118:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 119:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 120:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 121:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 122:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 123:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 124:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 125:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 126:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 127:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 128:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 129:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 130:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 131:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 132:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 133:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 134:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 135:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 136:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 137:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 138:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 139:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 140:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 141:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 142:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 143:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 144:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 145:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 146:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 147:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 148:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 149:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 150:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 151:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 152:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 153:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 154:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 155:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 156:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 157:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 158:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 159:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 160:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 161:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 162:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 163:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 164:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 165:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 166:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 167:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 168:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 169:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 170:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 171:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 172:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 173:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 174:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 175:    animdata_name = 0AA11HS,          hash = 175,    nb_records =     1
        //   block 176:    animdata_name = 0AA21HS,          hash = 176,    nb_records =     2
        //   block 177:    animdata_name = 0AA22HS,          hash = 177,    nb_records =     1
        //   block 178:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 179:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 180:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 181:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 182:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 183:    animdata_name = 10A1HTH,          hash = 183,    nb_records =     1
        //   block 184:    animdata_name = 10A2HTH,          hash = 184,    nb_records =     1
        //   block 185:    animdata_name = 21A1HTH,          hash = 185,    nb_records =     1
        //   block 186:    animdata_name = 40A1HTH,          hash = 186,    nb_records =     3
        //   block 187:    animdata_name = 40A2HTH,          hash = 187,    nb_records =     3
        //   block 188:    animdata_name = 15A1HTH,          hash = 188,    nb_records =     2
        //   block 189:    animdata_name = 43A1HTH,          hash = 189,    nb_records =     2
        //   block 190:    animdata_name = 44A1HTH,          hash = 190,    nb_records =     2
        //   block 191:    animdata_name = 45A1HTH,          hash = 191,    nb_records =     1
        //   block 192:    animdata_name = 64A1HTH,          hash = 192,    nb_records =     3
        //   block 193:    animdata_name = 65A1HTH,          hash = 193,    nb_records =     2
        //   block 194:    animdata_name = BAA21HS,          hash = 194,    nb_records =     3
        //   block 195:    animdata_name = BAA22HS,          hash = 195,    nb_records =     4
        //   block 196:    animdata_name = BAA22HT,          hash = 196,    nb_records =     3
        //   block 197:    animdata_name = 0ADD1HS,          hash = 197,    nb_records =     2
        //   block 198:    animdata_name = 0ADD2HS,          hash = 198,    nb_records =     1
        //   block 199:    animdata_name =        ,          hash =   0,    nb_records =     0
        //   block 200:    animdata_name = 0BA1HTH,          hash = 200,    nb_records =     2
        //   block 201:    animdata_name = FEA11HS,          hash = 201,    nb_records =     7
        //   block 202:    animdata_name = 20S1HTH,          hash = 202,    nb_records =     8
        //   block 203:    animdata_name = 10S3HTH,          hash = 203,    nb_records =     5
        //   block 204:    animdata_name = F0A1HTH,          hash = 204,    nb_records =     9
        //   block 205:    animdata_name = F0A2HTH,          hash = 205,    nb_records =    10
        //   block 206:    animdata_name = 60S1HTH,          hash = 206,    nb_records =    11
        //   block 207:    animdata_name = 61S1HTH,          hash = 207,    nb_records =    13
        //   block 208:    animdata_name = 62S1HTH,          hash = 208,    nb_records =    14
        //   block 209:    animdata_name = 62S2HTH,          hash = 209,    nb_records =    10
        //   block 210:    animdata_name = 15DDHTH,          hash = 210,    nb_records =     7
        //   block 211:    animdata_name = GMA12HS,          hash = 211,    nb_records =     7
        //   block 212:    animdata_name = GMA22HS,          hash = 212,    nb_records =     9
        //   block 213:    animdata_name = L3A1HTH,          hash = 213,    nb_records =     8
        //   block 214:    animdata_name = L3A2HTH,          hash = 214,    nb_records =     7
        //   block 215:    animdata_name = M4A1HTH,          hash = 215,    nb_records =     6
        //   block 216:    animdata_name = M5A1HTH,          hash = 216,    nb_records =     7
        //   block 217:    animdata_name = M6A1HTH,          hash = 217,    nb_records =     7
        //   block 218:    animdata_name = K9A1HTH,          hash = 218,    nb_records =     5
        //   block 219:    animdata_name = K9A2HTH,          hash = 219,    nb_records =    10
        //   block 220:    animdata_name = D0S1HTH,          hash = 220,    nb_records =    12
        //   block 221:    animdata_name = D1S1HTH,          hash = 221,    nb_records =    20
        //   block 222:    animdata_name = E1S1HTH,          hash = 222,    nb_records =    21
        //   block 223:    animdata_name = E2S1HTH,          hash = 223,    nb_records =    19
        //   block 224:    animdata_name = D4S1HTH,          hash = 224,    nb_records =    21
        //   block 225:    animdata_name = D5S1HTH,          hash = 225,    nb_records =    22
        //   block 226:    animdata_name = D6S1HTH,          hash = 226,    nb_records =    20
        //   block 227:    animdata_name = D7S1HTH,          hash = 227,    nb_records =    17
        //   block 228:    animdata_name = D8S1HTH,          hash = 228,    nb_records =    15
        //   block 229:    animdata_name = D9S1HTH,          hash = 229,    nb_records =    19
        //   block 230:    animdata_name = D9S2HTH,          hash = 230,    nb_records =    26
        //   block 231:    animdata_name = D9S3HTH,          hash = 231,    nb_records =    19
        //   block 232:    animdata_name = D9S4HTH,          hash = 232,    nb_records =    16
        //   block 233:    animdata_name = 62ONHTH,          hash = 233,    nb_records =    17
        //   block 234:    animdata_name = 70OPHTH,          hash = 234,    nb_records =    15
        //   block 235:    animdata_name = N5S1HTH,          hash = 235,    nb_records =    19
        //   block 236:    animdata_name = N6S1HTH,          hash = 236,    nb_records =    23
        //   block 237:    animdata_name = N7S1HTH,          hash = 237,    nb_records =    37
        //   block 238:    animdata_name = DBS1HTH,          hash = 238,    nb_records =    31
        //   block 239:    animdata_name = DBS2HTH,          hash = 239,    nb_records =    29
        //   block 240:    animdata_name = DDS1HTH,          hash = 240,    nb_records =    30
        //   block 241:    animdata_name = DDS2HTH,          hash = 241,    nb_records =    27
        //   block 242:    animdata_name = DDS3HTH,          hash = 242,    nb_records =    27
        //   block 243:    animdata_name = DDS4HTH,          hash = 243,    nb_records =    30
        //   block 244:    animdata_name = C0ONHTH,          hash = 244,    nb_records =    30
        //   block 245:    animdata_name = D0ONHTH,          hash = 245,    nb_records =    29
        //   block 246:    animdata_name = D1ONHTH,          hash = 246,    nb_records =    34
        //   block 247:    animdata_name = DKS1HTH,          hash = 247,    nb_records =    35
        //   block 248:    animdata_name = GIS1HTH,          hash = 248,    nb_records =    43
        //   block 249:    animdata_name = OBS1HTH,          hash = 249,    nb_records =    50
        //   block 250:    animdata_name = F3ONHTH,          hash = 250,    nb_records =    50
        //   block 251:    animdata_name = H2ONHTH,          hash = 251,    nb_records =    46
        //   block 252:    animdata_name = F5ONHTH,          hash = 252,    nb_records =    46
        //   block 253:    animdata_name = H2OPHTH,          hash = 253,    nb_records =    60
        //   block 254:    animdata_name = L1ONHTH,          hash = 254,    nb_records =    55
        //   block 255:    animdata_name = L2ONHTH,          hash = 255,    nb_records =    54

        // printf("   block %3i, hash = %5i, nb_records = %5li\n", curr_block, hash, nb_rec);
        fflush(stdout);
        curr_block++;

        // update block pointer & records number
        if (nb_rec) {
            // rec_ptr = (ANIM_DATA_RECORD_S *) lptr;
            // ‰∏Ä‰∏™Âπ≥Èù¢ÁªìÊûÑ, Â∫èÂàó‰∏≠ÊòØANIM_DATA_RECORD_SÁöÑ‰∏çÊñ≠ÂÜôÂÖ•
            glb_ds1edit.anim_data.block_pointer[hash] = rec_ptr;
            glb_ds1edit.anim_data.nb_records[hash]    = nb_rec;
        }

        // next block, if any
        // skip nb_rec records of 160 bytes each
        // why
        lptr += 40 * nb_rec;
        if ( (UBYTE *) lptr >= ((UBYTE *) glb_ds1edit.anim_data.buffer + glb_ds1edit.anim_data.buffer_size) ) {
            done = TRUE;
        }
    }
    printf("\n");
}


// ==========================================================================
// 'name' is the cof name, WITHOUT the 'data\global\...' in front.
// The ".cof" extension can be in the name, but it won't be used
int animdata_get_cof_info(char * name, long * fpd, long * speed)
{
//	typedef struct ANIM_DATA_RECORD_S {
//      char  cof_name[8];
//      long  frames_per_dir;
//      long  speed;
//      UBYTE flags[144];
//   } ANIM_DATA_RECORD_S;

   ANIM_DATA_RECORD_S * rec_ptr;
   UBYTE              hash;
   int                i;
   char               rec_name[80];


   hash = animdata_hash_value(name);
   printf("%s is hash %i", name, hash);
   if (glb_ds1edit.anim_data.block_pointer[hash])
   {
      rec_ptr = glb_ds1edit.anim_data.block_pointer[hash];
      for (i=0; i < glb_ds1edit.anim_data.nb_records[hash]; i++)
      {
         memset(rec_name, 0, sizeof(rec_name));
         strncpy(rec_name, rec_ptr[i].cof_name, 8);
         if (stricmp(rec_name, name) == 0)
         {
            * fpd   = rec_ptr[i].frames_per_dir;
            * speed = rec_ptr[i].speed;
            printf(", record %i in that block\n", i);
            fflush(stdout);
            return 0;
         }
      }
   }
   * fpd   = 0;
   * speed = 0;
   printf(", but error : not found in there\n");
   fflush(stdout);
   return -1;
}
#include "structs.h"
#include "misc.h"
#include "dc6info.h"


// ==========================================================================
void dc6_decomp_norm(void * src, BITMAP * dst, long size, int x0, int y0)
{
   UBYTE * ptr = (UBYTE *) src;
   long  i;
   int   i2, x=x0, y=y0, c, c2;
   

   for (i=0; i<size; i++)
   {
	   //cŒ™øÿ÷∆◊÷∑˚:
	   //	c==0x80( 0b1000,0000 ):ªª––(“≤æÕ «x“∆∂ØµΩ–– ◊,y“∆∂ØµΩœ¬“ª––)
	   //   c◊Ó∏ﬂŒªŒ™1,µ´≤ª «0x80( 0b1XXXXXX ):µ±«∞––Ã¯∂Ø0b0XXXXXXX(cµƒµÕ7Œª,◊Ó¥Û128,πª”√¡À~)
	   //  128¥Û∏≈3¿Â√◊∞…
	   //   »Ù◊Ó∏ﬂŒª≤ª «1,‘ÚΩ”œ¬¿¥Œ™c∏ˆœÒÀÿ ˝æ›
       //
       //
       //   Œ“‘⁄œÎ, ∏…¬Ô≤ª”√c=0x00(0000,0000)√Ë ˆªª––
       //   ∂¯c=(0XXX,XXXX)√Ë ˆ––ƒ⁄Ã¯◊™, c=(1XXX,XXXX)√Ë ˆ¡¨–¯ ˝æ›?
       //   ’‚ª·µº÷¬“ª∏ˆŒ Ã‚: ˝æ›÷¡…Ÿ∂ºŒ™c=128(1000,0000)≥§,∂¯ µº ≤ª“ª∂®¬˙◊„
      c = * (ptr ++);

      if (c == 0x80) {
		  //jmp code
		  // 0x80: 0b1000,0000
         x = x0;
         y--;
      } else if (c & 0x80){
         x += c & 0x7F;
	  }else {
         for (i2=0; i2<c; i2++)
         {
            c2 = * (ptr ++);
            i++;
            putpixel(dst, x, y, c2);
            x++;
         }
      }
   }
}


// ==========================================================================
// cmap must point to a table of 256 bytes
void dc6_decomp_cmap(void * src, BITMAP * dst, long size, int x0, int y0,
                     UBYTE * cmap)
{
   UBYTE * ptr = (UBYTE *) src;
   long  i;
   int   i2, x=x0, y=y0, c, c2;
   

   for (i=0; i<size; i++)
   {
      c = * (ptr ++);

      if (c == 0x80)
      {
         x = x0;
         y--;
      }
      else if (c & 0x80)
         x += c & 0x7F;
      else
      {
         for (i2=0; i2<c; i2++)
         {
            c2 = * (ptr ++);
            i++;
            putpixel(dst, x, y, cmap[c2]);
            x++;
         }
      }
   }
}


// ==========================================================================
//º”‘ÿ.dc6
int anim_load_dc6(char * name, COF_S * cof, int lay_idx, long user_dir,
                  UBYTE * palshift)
{
   LAY_INF_S  * lay;
   int        entry, i, size, w, h, x1, y1, x2, y2;
   char       * buff;
   long       dir = 0, * lptr, offset, len;
   long       dc6_ver, dc6_unk1, dc6_unk2, dc6_dir, dc6_fpd, * dc6_fptr,
              f_w, f_h, f_offx, f_offy, f_x1, f_x2, f_y1, f_y2,
              f_len;
   UBYTE      * f_data;
   

   if ((cof == NULL) || (lay_idx >= COMPOSIT_NB))
      return 1;
   lay = & cof->lay_inf[lay_idx];

   // load dc6 file
   //æÕ «÷±Ω”øΩ±¥µΩbuff∞…..
   entry = misc_load_mpq_file(name, & buff, & len, FALSE);
   if (entry == -1)
      return 1;

   // decode dc6 header datas
   lptr     = (long *) buff;
   // .dc6 version, must be 6
   dc6_ver  = lptr[0];
   //unknown1,2
   dc6_unk1 = lptr[1];
   dc6_unk2 = lptr[2];
   //
   dc6_dir  = lptr[4];
   dc6_fpd  = lptr[5];

   //…Ò¬Ì? ”¶∏√ «¥”lprt6ø™ º¡ÀdccµƒŒƒº˛ƒ⁄»›..
   //&lptr[6] := lprt+6

   //file pointer
   dc6_fptr = & lptr[6];

   if ((dc6_ver != 6) || (dc6_unk1 != 1) || (dc6_unk2 != 0))
   {
      free(buff);
      return 1;
   }

   // valid direction ?
   if (dc6_dir != cof->dir)
   {
      free(buff);
      return 1;
   }
   
   // choose direction
   switch (cof->dir)
   {
      case  1 : dir = glb_ds1edit.new_dir1[user_dir];  break;
      case  4 : dir = glb_ds1edit.new_dir4[user_dir];  break;
      case  8 : dir = glb_ds1edit.new_dir8[user_dir];  break;
      case 16 : dir = glb_ds1edit.new_dir16[user_dir]; break;
      case 32 : dir = glb_ds1edit.new_dir32[user_dir]; break;
   }

   // decode dc6 direction

   // search the direction "box"
   //’‚∏ˆbox «≤ª «∫Õdt1 tool¿Ô√Êƒ«∏ˆbox”–µ„¡™œµ?
   //±Ì æ’˚∏ˆÕº”–∂‡¥Ûæÿ–Œ?
   x1 = y1 = 0x7FFFFFFFL;
   x2 = y2 = 0x80000000L;
   for (i=0; i < dc6_fpd; i++)
   {
	   //’‚“™“ªframe“ªframeµƒ∂¡»°¡À...
      // get pointer to frame header
      offset = dc6_fptr[dir * dc6_fpd + i];
      if (offset >= len)
      {
         free(buff);
         return 1;
      }
      lptr = (long *) (buff + offset);

      // update the box limits
      f_w    = lptr[1];
      f_h    = lptr[2];
      f_offx = lptr[3];
      f_offy = lptr[4];

      f_x1 = f_offx;
      f_x2 = f_x1 + f_w - 1;
      f_y2 = f_offy;
      f_y1 = f_y2 - f_h + 1;
      
	  //’‚ «‘⁄Õ≥º∆ ≤√¥∂´∂´√¥...
      if (f_x1 < x1)
         x1 = f_x1;
      if (f_x2 > x2)
         x2 = f_x2;
      if (f_y1 < y1)
         y1 = f_y1;
      if (f_y2 > y2)
         y2 = f_y2;
   }
   w = x2 - x1 + 1;
   h = y2 - y1 + 1;

   if ((w <= 0) || (h <= 0))
   {
      free(buff);
      return 1;
   }
      
   lay->off_x = x1;
   lay->off_y = y1;
   
   // allocate the bitmaps
   //Œ“¿’∏ˆ≤¡≤¡..∑÷≈‰¡À“ª¥ÛøÈ
   size = dc6_fpd * sizeof(BITMAP *);
   lay->bmp_num = dc6_fpd;
   lay->bmp = (BITMAP **) malloc(size);
   if (lay->bmp == NULL)
   {
      free(buff);
      return 1;
   }
   memset(lay->bmp, 0, size);

   // make the bitmaps
   for (i=0; i < dc6_fpd; i++)
   {
      // get pointer to frame header
      offset = dc6_fptr[dir * dc6_fpd + i];
      if (offset >= len)
      {
         while (i)
         {
            i--;
            destroy_bitmap(lay->bmp[i]);
         }
         free(buff);
         return 1;
      }
      lptr = (long *) (buff + offset);

      // get frame datas
      f_w    = lptr[1];
      f_h    = lptr[2];
      f_offx = lptr[3];
      f_offy = lptr[4];


	  //ÕºœÒ ˝æ›..≥§∂»,»ª∫Û « ˝æ›
      f_len  = lptr[7];
      f_data = (UBYTE *) (& lptr[8]);

      // make a BITMAP
      lay->bmp[i] = create_bitmap(w, h);
      if (lay->bmp[i] == NULL)
      {
         while (i)
         {
            i--;
            destroy_bitmap(lay->bmp[i]);
         }
         free(buff);
         return 1;
      }
      clear(lay->bmp[i]);

      // decode dc6 datas
      if (palshift == NULL)
      {
         dc6_decomp_norm(
            f_data,              // src
            lay->bmp[i],         // dst
            f_len,               // length
            f_offx - x1,         // x0
            h - 1 + f_offy - y2  // y0
         );
      }
      else
      {
         dc6_decomp_cmap(
            f_data,              // src
            lay->bmp[i],         // dst
            f_len,               // length
            f_offx - x1,         // x0
            h - 1 + f_offy - y2, // y0
            palshift             // cmap
         );
      }
   }
   free(buff);
   return 0;
}
#include <stdio.h>
#include <string.h>
#include "types.h"

#ifdef WIN32
   #pragma warning (push)
   #pragma warning (disable  : 4312 )
#endif

#include <allegro.h>

#ifdef WIN32
   #pragma warning (pop)
#endif

#include "dccinfo.h"

#define DCCINFO_SAVE_PCX


// ==========================================================================
// just a simple (but necessary) initialization
void dcc_init(void)
{
    //∫Œ≤ª÷±Ω”≥ı ºªØ..ªπ“™’‚—˘?≤ª∑˚∫œ◊˜’ﬂ∑Á∏Ò
   int i,
       temp[16] = {0, 1, 2, 4, 6, 8, 10, 12, 14, 16, 20, 24, 26, 28, 30, 32};

   for (i=0; i<16; i++)
      dcc_bits_width_table[i] = temp[i];

   memset(dcc_error, 0, sizeof(dcc_error));
}


// ==========================================================================
// copy 'bytes_number' bytes into 'dest' from the current byte position
//    in the bitstream
// return 0 on success, non-zero if error
int dcc_read_bytes(DCC_BITSTREAM_S * bs, int bytes_number, void * dest)
{
   int i;

   // in case
   if (bs->cur_bit)
   {
       //±ÿ–Î’˚ÃÂµƒ∂¡»°“ª∏ˆ◊÷Ω⁄,∂¯≤ªƒ‹¥”◊÷Ω⁄÷–º‰∂¡»°
      sprintf(dcc_error, "dcc_read_bytes() : bytes reading must be aligned "
                         "on a byte boundary (cur_bit = %i)\n", bs->cur_bit);
      return 1;
   }
   
   // copy bytes
   for (i=0; i < bytes_number; i++)
   {
      if (bs->cur_bit_num >= bs->size)
      {
          //bit_stream÷–√ª”–’‚√¥∂‡◊÷Ω⁄

//typedef struct DCC_BITSTREAM_S
//{
//   UBYTE  * data;      // pointer to the start of the bitstream
//   UDWORD size;        // size of the bitstream, in bits
//   UDWORD cur_byte;    // byte cursor
//   UBYTE  cur_bit;     // bit cursor in the byte of current byte cursor
//                       //    (from 0 to 7 : lowest bit to highest bit)
//   UDWORD cur_bit_num; // bit cursor in the bitstream (not in the byte)
//                       //    this also indicate the # of bits already read
//} DCC_BITSTREAM_S;


          //’‚¿ÔÀµµƒ∫‹«Â≥˛, cur_bit_num «÷∏’‚∏ˆbit_stream÷–π≤”–∂‡…Ÿ∏ˆ”––ß‘™Àÿ
          //“≤æÕ «Àµcur_bit_num÷–÷∏ æµƒ «bit_stream÷–ø…”√◊÷Ω⁄µƒ±ﬂΩÁ.length()
          //size «’˚∏ˆbit_stream◊Ó¥Ûƒ‹»›ƒ…µƒ◊÷Ω⁄≥§∂».size()
          //cur_byte∫Õcur_bit≤≈ «÷∏ æµ±«∞øΩ±¥µΩ¡Àƒ«¿Ô
          //
          //À˘“‘’‚¿Ô”–’‚∏ˆ≈–∂œ
         sprintf(dcc_error, "dcc_read_bytes() : want to read behind "
                            "the end (%li >= %li)\n",
                            bs->cur_bit_num, bs->size);
         return 1;
      }
      * (((UBYTE *) dest) + i) = bs->data[bs->cur_byte];
      bs->cur_byte ++;
      bs->cur_bit_num += 8;
   }

   // end
   return 0;
}


// ==========================================================================
// copy 'bits_number' bits into 'dest' from the current byte & bit position
//    in the bitstream
// is_signed = TRUE / FALSE
// the dest variable MUST BE 32 bits width
// return 0 on success, non-zero if error
int dcc_read_bits(DCC_BITSTREAM_S * bs, int bits_number, int is_signed,
                  UDWORD * dest )
{
   int b, dest_bit = 0, dest_byte = 0;


   // init to zero
   * dest = 0;
   
/*
   // no bits to read
   if (bits_number == 0)
      return 0; // reading 0 bits is NOT an error, this is to avoid some
                // checks if the data is 0 bit size before reading them,
                // this check is done here

   TODO ? : if want to read a bitstream which don't exists (size = 0),
      return a 0. Seems a good idea. Might remove many further checks...
*/

   // in case
   if (bits_number < 0)
   {
      sprintf(dcc_error, "dcc_read_bits() : can't read %i bits\n",
         bits_number);
      return 1;
   }

   if (bits_number > 32)
   {
	   //∑µªÿ÷µ¬Ô
      sprintf(dcc_error, "dcc_read_bits() : can't read more than 32 bits "
                         "at once\n");
      return 1;
   }

   // copy all necessary bits
   for (b=0; b < bits_number; b++)
   {
      if (bs->cur_bit_num >= bs->size)
      {
         sprintf(dcc_error, "dcc_read_bits() : want to read behind "
                            "the end (%li >= %li)\n",
                            bs->cur_bit_num, bs->size);
         return 1;
      }

      // copy 1 bit
      if ( bs->data[bs->cur_byte] & (1 << bs->cur_bit) )
         * (((UBYTE *) dest) + dest_byte) |= (1 << dest_bit);

      // prepare next bit to read
      dest_bit++;
      if (dest_bit >= 8)
      {
         dest_bit = 0;
         dest_byte++;
      }
      bs->cur_bit++;
      bs->cur_bit_num++;
      if (bs->cur_bit >= 8)
      {
         bs->cur_bit = 0;
         bs->cur_byte++;
      }
   }

   // signed value handle
   if (is_signed == FALSE)
      return 0;
      
   // else it's a signed value (1 bit value will be 0 or -1, NOT 1)
   // so check if we have read a negative value
   if ((* dest) & (1 << (bits_number-1)) )
   {
      // negative : extend its sign
      (* dest) |= ~ ((1 << bits_number) - 1);
   }

   return 0;
}


// ==========================================================================
// read 1 frame header, from a direction bitstream
// return 0 on success, non-zero if error
int dcc_frame_header_bitstream(DCC_S *dcc, DCC_BITSTREAM_S *bs, int d, int f)
{
   DCC_DIRECTION_S * dir = & dcc->direction[d];

//typedef struct DCC_FRAME_S
//{
//   UDWORD variable0;
//   UDWORD width;
//   UDWORD height;
//   long   xoffset;
//   long   yoffset;
//   UDWORD optional_bytes;
//   UDWORD coded_bytes;
//
//   UBYTE  * optional_bytes_data;
//
//   // next var : UBYTE should be enough
//   //    but my bitstream reading function need a 32 bits wide variable
//   UDWORD bottom_up;
//
//   // cells infos
//   DCC_CELL_S * cell;
//   int        nb_cells_w;
//   int        nb_cells_h;
//
//   // not in file, for my own purpose
//   DCC_BOX_S box;
//
//   // final bitmap
//   BITMAP * bmp;
//   
//} DCC_FRAME_S;

   //ø…“‘ø¥≥ˆ¿¥’‚¿ÔframeæÕ «√Ë ˆ√ø“ªframeµƒ ˝æ›Ω·ππ
   //’‚∏ˆdccæÕ «“ª’˚∏ˆ∂Øª≠π˝≥Ã¡À
   DCC_FRAME_S     * frm = & dcc->frame[d][f];
   int             sign, width=0, i;
   void            * ptr = NULL;
   char            add_error[80], str[30];

   
   // read frame datas
   for (i=0; i<8; i++)
   {
      sign = FALSE;
      switch(i)
      {
         case 0 :
            width = dir->variable0_bits;
            ptr   = & frm->variable0;
            strcpy(str, "variable0");
            break;
            
         case 1 :
            width = dir->width_bits;
            ptr   = & frm->width;
            strcpy(str, "width");
            break;
            
         case 2 :
            width = dir->height_bits;
            ptr   = & frm->height;
            strcpy(str, "height");
            break;
            
         case 3 :
            sign  = TRUE;
            width = dir->xoffset_bits;
            ptr   = & frm->xoffset;
            strcpy(str, "xoffset");
            break;
            
         case 4 :
            sign  = TRUE;
            width = dir->yoffset_bits;
            ptr   = & frm->yoffset;
            strcpy(str, "yoffset");
            break;
            
         case 5 :
            width = dir->optional_bytes_bits;
            ptr   = & frm->optional_bytes;
            strcpy(str, "optional_bytes");
            break;
            
         case 6 :
            width = dir->coded_bytes_bits;
            ptr   = & frm->coded_bytes;
            strcpy(str, "coded_bytes");
            break;
            
         case 7 :
            width = 1;
            ptr   = & frm->bottom_up;
            strcpy(str, "bottom_up");
            break;
      }
      if (dcc_read_bits(bs, dcc_bits_width_table[width], sign, ptr))
      {
         sprintf(add_error, "frame header %i, %s\n", f, str);
         strcat(dcc_error, add_error);
         return 1;
      }
   }
      
   // frame box
   dcc->frame[d][f].box.xmin = dcc->frame[d][f].xoffset;
   dcc->frame[d][f].box.xmax = dcc->frame[d][f].box.xmin + dcc->frame[d][f].width - 1;

   if (dcc->frame[d][f].bottom_up) // bottom-up:µﬂµπ
   {
      dcc->frame[d][f].box.ymin = dcc->frame[d][f].yoffset;
      dcc->frame[d][f].box.ymax = dcc->frame[d][f].box.ymin + dcc->frame[d][f].height - 1;
   } else {
	   // top-down:◊‘…œ∂¯œ¬µƒ
      dcc->frame[d][f].box.ymax = dcc->frame[d][f].yoffset;
      dcc->frame[d][f].box.ymin = dcc->frame[d][f].box.ymax - dcc->frame[d][f].height + 1;
   }
   dcc->frame[d][f].box.width = dcc->frame[d][f].box.xmax - dcc->frame[d][f].box.xmin + 1;
   dcc->frame[d][f].box.height = dcc->frame[d][f].box.ymax - dcc->frame[d][f].box.ymin + 1;

   // end
   return 0;
}


// ==========================================================================
// init the bitstreams for this direction
void dcc_init_dir_bitstream(DCC_S * dcc, DCC_BITSTREAM_S * bs, int d)
{
   DCC_BITSTREAM_S * ec, * pm, * et, * rp, * pcd;
   UDWORD          glb_bit = (bs->cur_byte * 8) + bs->cur_bit;


   // init temporary bitstream pointers
   ec  = & dcc->direction[d].equal_cell_bitstream;
   pm  = & dcc->direction[d].pixel_mask_bitstream;
   et  = & dcc->direction[d].encoding_type_bitstream;
   rp  = & dcc->direction[d].raw_pixel_bitstream;
   pcd = & dcc->direction[d].pixel_code_and_displacment_bitstream;
   
   // equal cell bitstream
   if (dcc->direction[d].compression_flag & 0x02)
   {
      ec->data        = bs->data + (glb_bit / 8);
      ec->cur_bit     = (UBYTE) (glb_bit % 8);
      ec->cur_bit_num = 0;
      ec->cur_byte    = 0;
      ec->size        = dcc->direction[d].equal_cell_bitstream_size;
      glb_bit        += ec->size;
   }

   // pixel mask bitstream
   pm->data        = bs->data + (glb_bit / 8);
   pm->cur_bit     = (UBYTE) (glb_bit % 8);
   pm->cur_bit_num = 0;
   pm->cur_byte    = 0;
   pm->size        = dcc->direction[d].pixel_mask_bitstream_size;
   glb_bit        += pm->size;
   
   if (dcc->direction[d].compression_flag & 0x01)
   {
      // encoding type bitstream
      et->data        = bs->data + (glb_bit / 8);
      et->cur_bit     = (UBYTE) (glb_bit % 8);
      et->cur_bit_num = 0;
      et->cur_byte    = 0;
      et->size        = dcc->direction[d].encoding_type_bitstream_size;
      glb_bit        += et->size;

      // raw pixel bitstream
      rp->data        = bs->data + (glb_bit / 8);
      rp->cur_bit     = (UBYTE) (glb_bit % 8);
      rp->cur_bit_num = 0;
      rp->cur_byte    = 0;
      rp->size        = dcc->direction[d].raw_pixel_bitstream_size;
      glb_bit        += rp->size;
   }

   // pixel code and displacment bitstream
   pcd->data        = bs->data + (glb_bit / 8);
   pcd->cur_bit     = (UBYTE) (glb_bit % 8);
   pcd->cur_bit_num = 0;
   pcd->cur_byte    = 0;
   pcd->size        = bs->size - glb_bit;

// debug
/*
printf("current bitstream\n");
printf("   data        = %p\n",  bs->data);
printf("   size        = %lu\n", bs->size);
printf("   cur_byte    = %lu\n", bs->cur_byte);
printf("   cur_bit     = %i\n",  bs->cur_bit);
printf("   cur_bit_num = %lu\n", bs->cur_bit_num);

printf("equal cell bitstream\n");
printf("   data        = %p\n",  ec->data);
printf("   size        = %lu\n", ec->size);
printf("   cur_byte    = %lu\n", ec->cur_byte);
printf("   cur_bit     = %i\n",  ec->cur_bit);
printf("   cur_bit_num = %lu\n", ec->cur_bit_num);

printf("pixel mask bitstream\n");
printf("   data        = %p\n",  pm->data);
printf("   size        = %lu\n", pm->size);
printf("   cur_byte    = %lu\n", pm->cur_byte);
printf("   cur_bit     = %i\n",  pm->cur_bit);
printf("   cur_bit_num = %lu\n", pm->cur_bit_num);

printf("encoding type cell bitstream\n");
printf("   data        = %p\n",  et->data);
printf("   size        = %lu\n", et->size);
printf("   cur_byte    = %lu\n", et->cur_byte);
printf("   cur_bit     = %i\n",  et->cur_bit);
printf("   cur_bit_num = %lu\n", et->cur_bit_num);

printf("raw_pixel bitstream\n");
printf("   data        = %p\n",  rp->data);
printf("   size        = %lu\n", rp->size);
printf("   cur_byte    = %lu\n", rp->cur_byte);
printf("   cur_bit     = %i\n",  rp->cur_bit);
printf("   cur_bit_num = %lu\n", rp->cur_bit_num);

printf("pixel code & displacment cell bitstream\n");
printf("   data        = %p\n",  pcd->data);
printf("   size        = %lu\n", pcd->size);
printf("   cur_byte    = %lu\n", pcd->cur_byte);
printf("   cur_bit     = %i\n",  pcd->cur_bit);
printf("   cur_bit_num = %lu\n", pcd->cur_bit_num);
*/
}


// ==========================================================================
// read the optional datas (if any) from 1 direction bitstream
// return 0 on success, non-zero if error
int dcc_optional_datas(DCC_S * dcc, DCC_BITSTREAM_S * bs, int d)
{
   UDWORD size = 0;
   int    f;
   char   add_error[80];

   
   // check if any optional datas
   for (f=0; f < dcc->header.frames_per_dir; f++)
      size += dcc->frame[d][f].optional_bytes;
   if (size == 0)
      return 0; // nothing to read
      
   // byte boundary
   if (bs->cur_bit)
   {
      // skip alignment bits
      bs->cur_bit_num += 8 - bs->cur_bit;
      bs->cur_bit = 0;
      bs->cur_byte ++;
   }

   // read the datas
   for (f=0; f < dcc->header.frames_per_dir; f++)
   {
      size = dcc->frame[d][f].optional_bytes;
      if (size)
      {
         // malloc
         dcc->frame[d][f].optional_bytes_data = (UBYTE *) malloc (size);
         if (dcc->frame[d][f].optional_bytes_data == NULL)
         {
            sprintf(dcc_error,
               "dcc_optional_datas() : can't allocate "
               "%li bytes for optional_byte_data\n"
               "direction %i, frame %i\n",
               size, d, f);
            return 1;
         }

         // get them
         if (dcc_read_bytes(bs, size, dcc->frame[d][f].optional_bytes_data))
         {
            sprintf(add_error, "direction %i, frame %i\n", d, f);
            strcat(dcc_error, add_error);
            return 1;
         }
      }
   }

   // end
   return 0;
}


// ==========================================================================
// read the size of the other bitstreams from 1 direction bitstream
// return 0 on success, non-zero if error
int dcc_other_bitstream_size(DCC_S * dcc, DCC_BITSTREAM_S * bs, int d)
{
   char add_error[80];

   
   // equal cell bitstream
   if (dcc->direction[d].compression_flag & 0x02)
   {
      if (dcc_read_bits(bs, 20, FALSE,
             & dcc->direction[d].equal_cell_bitstream_size))
      {
         sprintf(add_error,
                 "direction %i, equal_cell_bitstream_size\n", d);
         strcat(dcc_error, add_error);
         return 1;
      }
   }
   
   // pixel mask bitstream
   if (dcc_read_bits(bs, 20, FALSE,
          & dcc->direction[d].pixel_mask_bitstream_size))
   {
      sprintf(add_error,
              "direction %i, pixel_mask_bitstream_size\n", d);
      strcat(dcc_error, add_error);
      return 1;
   }
   
   if (dcc->direction[d].compression_flag & 0x01)
   {
      // encoding type bitstream
      if (dcc_read_bits(bs, 20, FALSE,
             & dcc->direction[d].encoding_type_bitstream_size))
      {
         sprintf(add_error,
                 "direction %i, encoding_type_bitstream_size\n", d);
         strcat(dcc_error, add_error);
         return 1;
      }

      // raw pixel bitstream
      if (dcc_read_bits(bs, 20, FALSE,
             & dcc->direction[d].raw_pixel_bitstream_size))
      {
         sprintf(add_error,
                 "direction %i, raw_pixel_bitstream_size\n", d);
         strcat(dcc_error, add_error);
         return 1;
      }
   }

   // end
   return 0;
}


// ==========================================================================
// read the 256 bits of the pixel values key from 1 direction bitstream
// TODO : may need big optimization... but that's not a process that is
//   use heavilly in a dcc decoding, so I can also left it in this state
// return 0 on success, non-zero if error
int dcc_pixel_values_key(DCC_S * dcc, DCC_BITSTREAM_S * bs, int d)
{
   char   add_error[80];
   int    i, idx = 0;
   UDWORD tmp;

   for (i=0; i<256; i++)
   {
      if (dcc_read_bits(bs, 1, FALSE, & tmp))
      {
         sprintf(add_error,
                 "direction %i, pixel_values %i\n", d, i);
         strcat(dcc_error, add_error);
         return 1;
      }
      if (tmp)
         dcc->direction[d].pixel_values[idx++] = (UBYTE) i;
   }

   // end
   return 0;
}


// ==========================================================================
// make the cells for the frame buffer, to prepare the stage 1 & 2
// return 0 on success, non-zero if error
// ’‚∏ˆ≥Ã–ÚÕÍ»´√ªø¥∂Æ
int dcc_prepare_buffer_cells(DCC_S * dcc, int d)
{
   DCC_DIRECTION_S * dir = & dcc->direction[d];
   DCC_CELL_S      * cell;
   int             buffer_w, buffer_h, tmp, nb_cell_w, nb_cell_h, nb_cell,
                   size, * cell_w, * cell_h, i, x0, y0, x, y;

   buffer_w = dir->box.width;
   buffer_h = dir->box.height;


   tmp = buffer_w - 1;
   nb_cell_w = 1 + (tmp / 4);
      
   tmp = buffer_h - 1;
   nb_cell_h = 1 + (tmp / 4);

//typedef struct DCC_CELL_S
//{
//   int    x0, y0;  // for frame cells in stage 2
//   int    w, h;
//
//   int    last_w, last_h;   // width & size of the last frame cell that used
//                            // this buffer cell (for stage 2)
//   int    last_x0, last_y0;
//   
//   BITMAP * bmp;   // sub-bitmap in the buffer bitmap
//} DCC_CELL_S; // maybe I'll make 2 kind of cells, 1 for frame-buffer cells,
//              // the other for the frame cells...
//
//


   nb_cell = nb_cell_w * nb_cell_h;
   size = nb_cell * sizeof(DCC_CELL_S);
   dir->buffer_ptr = (DCC_CELL_S *) malloc(size);
   if (dir->buffer_ptr == NULL)
   {
      sprintf(dcc_error, "dcc_prepare_buffer_cells() :\n"
                         "can't allocate %i bytes for dir->buffer_ptr\n",
                         size);
      return 1;
   }
   memset(dir->buffer_ptr, 0, size);

   size   = nb_cell_w * sizeof(int);
   cell_w = (int *) malloc(size);
   if (cell_w == NULL)
   {
      sprintf(dcc_error, "dcc_prepare_buffer_cells() :\n"
                         "can't allocate %i bytes for cell_w\n",
                         size);
      return 1;
   }

   size   = nb_cell_h * sizeof(int);
   cell_h = (int *) malloc(size);
   if (cell_h == NULL)
   {
      free(cell_w);
      sprintf(dcc_error, "dcc_prepare_buffer_cells() :\n"
                         "can't allocate %i bytes for cell_h\n",
                         size);
      return 1;
   }

   if (nb_cell_w == 1)
      cell_w[0] = buffer_w;
   else
   {
      for (i=0; i < (nb_cell_w - 1); i++)
         cell_w[i] = 4;
      cell_w[nb_cell_w - 1] = buffer_w - (4 * (nb_cell_w - 1));
   }

   if (nb_cell_h == 1)
      cell_h[0] = buffer_h;
   else
   {
      for (i=0; i < (nb_cell_h - 1); i++)
         cell_h[i] = 4;
      cell_h[nb_cell_h - 1] = buffer_h - (4 * (nb_cell_h - 1));
   }

   dir->nb_cells_w = nb_cell_w;
   dir->nb_cells_h = nb_cell_h;

   y0 = 0;
   for (y=0; y < nb_cell_h; y++)
   {
      x0 = 0;
      for (x=0; x < nb_cell_w; x++)
      {
         cell      = & dir->buffer_ptr[x + (y * nb_cell_w)];
         cell->w   = cell_w[x];
         cell->h   = cell_h[y];
         cell->bmp = create_sub_bitmap(dir->bmp, x0, y0, cell->w, cell->h);
         if (cell->bmp == NULL)
         {
            sprintf(dcc_error, "dcc_prepare_buffer_cells() :\n"
                               "can't create sub_bitmap for cell->bmp x0=%i, y0=%i\n",
                               x0, y0);
            return 1;
         }
         x0 += 4;
      }
      y0 += 4;
   }

   free(cell_w);
   free(cell_h);

   return 0;
}


// ==========================================================================
// make the cells of 1 frame, called during stage 1, but used mainly
// for stage 2
// return 0 on success, non-zero if error
int dcc_prepare_frame_cells(DCC_S * dcc, int d, int f)
{
   DCC_DIRECTION_S * dir   = & dcc->direction[d];
   DCC_FRAME_S     * frame = & dcc->frame[d][f];
   DCC_CELL_S      * cell = NULL;
   int             frame_w, frame_h, w, h, tmp,
                   nb_cell_w, nb_cell_h, nb_cell,
                   size, * cell_w, * cell_h, i, x0, y0, x, y;

   frame_w = frame->box.width;
   frame_h = frame->box.height;

   // width (in # of pixels) in 1st column
   w = 4 - ((frame->box.xmin - dir->box.xmin) % 4);
   
   if ((frame_w - w) <= 1) // if 2nd column is 0 or 1 pixel width
      nb_cell_w = 1;
   else
   {
      // so, we have minimum 2 pixels behind 1st column
      tmp = frame_w - w - 1; // tmp is minimum 1, can't be 0
      nb_cell_w = 2 + (tmp / 4);
      if ((tmp % 4) == 0)
         nb_cell_w--;
   }

   h = 4 - ((frame->box.ymin - dir->box.ymin) % 4);
   if ((frame_h - h) <= 1)
      nb_cell_h = 1;
   else
   {
      tmp = frame_h - h - 1;
      nb_cell_h = 2 + (tmp / 4);
      if ((tmp % 4) == 0)
         nb_cell_h--;
   }

   nb_cell = nb_cell_w * nb_cell_h;
   size = nb_cell * sizeof(DCC_CELL_S);
   frame->cell = (DCC_CELL_S *) malloc(size);
   if (frame->cell == NULL)
   {
      sprintf(dcc_error, "dcc_prepare_frame_cells() :\n"
                         "can't allocate %i bytes for frame->cell\n",
                         size);
      return 1;
   }
   memset(frame->cell, 0, size);

   size   = nb_cell_w * sizeof(int);
   cell_w = (int *) malloc(size);
   if (cell_w == NULL)
   {
      sprintf(dcc_error, "dcc_prepare_frame_cells() :\n"
                         "can't allocate %i bytes for cell_w\n",
                         size);
      return 1;
   }

   size   = nb_cell_h * sizeof(int);
   cell_h = (int *) malloc(size);
   if (cell_h == NULL)
   {
      free(cell_w);
      sprintf(dcc_error, "dcc_prepare_frame_cells() :\n"
                         "can't allocate %i bytes for cell_h\n",
                         size);
      return 1;
   }

   if (nb_cell_w == 1)
      cell_w[0] = frame_w;
   else
   {
      cell_w[0] = w;
      for (i=1; i < (nb_cell_w - 1); i++)
         cell_w[i] = 4;
      cell_w[nb_cell_w - 1] = frame_w - w - (4 * (nb_cell_w - 2));
   }

   if (nb_cell_h == 1)
      cell_h[0] = frame_h;
   else
   {
      cell_h[0] = h;
      for (i=1; i < (nb_cell_h - 1); i++)
         cell_h[i] = 4;
      cell_h[nb_cell_h - 1] = frame_h - h - (4 * (nb_cell_h - 2));
   }

   frame->nb_cells_w = nb_cell_w;
   frame->nb_cells_h = nb_cell_h;

   y0 = frame->box.ymin - dir->box.ymin;
   for (y=0; y < nb_cell_h; y++)
   {
      x0 = frame->box.xmin - dir->box.xmin;
      for (x=0; x < nb_cell_w; x++)
      {
         cell = & frame->cell[x + (y * nb_cell_w)];
         cell->x0  = x0;
         cell->y0  = y0;
         cell->w   = cell_w[x];
         cell->h   = cell_h[y];
         cell->bmp = create_sub_bitmap(dir->bmp, x0, y0, cell->w, cell->h);
         x0 += cell->w;
      }
      y0 += cell->h;
   }

   free(cell_w);
   free(cell_h);

   return 0;
}


// ==========================================================================
// stage 1 of the decompression of the direction frames
// return 0 on success, non-zero if error
int dcc_fill_pixel_buffer(DCC_S * dcc, int d)
{
   DCC_DIRECTION_S * dir = & dcc->direction[d];
   DCC_FRAME_S     * frame;
   DCC_PB_ENTRY_S  * old_entry, * new_entry;
   long            cell0_x, cell0_y, cell_w, cell_h;
   UDWORD          tmp, pixel_mask=0, encoding_type, last_pixel, read_pixel[4],
                   pix_displ;
   int             nb_cell, size;
   int             i, f, curr_cell_x, curr_cell_y, curr_cell;
   int             nb_pix_table[16] =
                      {0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4};
   int             x, y, nb_pix, next_cell, curr_idx,
                   pb_idx = -1; // current entry of pixel_buffer
   DCC_PB_ENTRY_S  ** cell_buffer;
   int             buff_w, buff_h, decoded_pix;
   char            add_error[256];


   // create & init pixel buffer
// PixelBuffer entry
//typedef struct DCC_PB_ENTRY_S
//{
//   UBYTE      val[4];
//   int        frame;
//   int        frame_cell_index;
//} DCC_PB_ENTRY_S;


   size = DCC_MAX_PB_ENTRY * sizeof(DCC_PB_ENTRY_S);
   dir->pixel_buffer = (DCC_PB_ENTRY_S *) malloc(size);
   if (dir->pixel_buffer == NULL)
   {
      sprintf(dcc_error, "dcc_fill_pixel_buffer() : can't allocate "
                         "%i bytes for pixel_buffer (max entry = %i)\n",
                         size, DCC_MAX_PB_ENTRY);
      return 1;
   }
   memset(dir->pixel_buffer, 0, size);
   for (i=0; i < DCC_MAX_PB_ENTRY; i++)
   {
      dir->pixel_buffer[i].frame            = -1;
      dir->pixel_buffer[i].frame_cell_index = -1;
   }

   // frame buffer, will be simply called as "buffer" for now
   dir->bmp = create_bitmap(dir->box.width, dir->box.height);
   if (dir->bmp == NULL)
   {
      sprintf(dcc_error, "dcc_fill_pixel_buffer() : can't create buffer bitmap of %ld * %ld pixels\n", dir->box.width, dir->box.height);
      return 1;
   }
   clear(dir->bmp); // all 0

   // create sub-bitmaps into this dir->bmp, 1 for each cells
   //ø¥µΩ’‚¿ÔæÕ√ª‘ı√¥ø¥√˜∞◊¡À..
   //2012/3/30
   if (dcc_prepare_buffer_cells(dcc, d))
      return 1;

   // create & init cell_buffer (for stage 1 only)
   // this buffer is a table of pointer to the current pixelbuffer entry
   // of 1 buffer cell
   buff_w  = dir->nb_cells_w;
   buff_h  = dir->nb_cells_h;
   nb_cell = buff_w * buff_h;
   size    = nb_cell * sizeof(DCC_PB_ENTRY_S *);
   cell_buffer = (DCC_PB_ENTRY_S **) malloc(size);
   if (cell_buffer == NULL)
   {
      sprintf(dcc_error, "dcc_fill_pixel_buffer() : can't allocate "
                         "%i bytes for cell_buffer (%i cells)\n",
                         size, nb_cell);
      return 1;
   }
   memset(cell_buffer, 0, size);

   // for all frames of this direction
   for (f=0; f < dcc->header.frames_per_dir; f++)
   {
      // make cells of this frame
      if (dcc_prepare_frame_cells(dcc, d, f))
      {
         free(cell_buffer);
         return 1;
      }

      frame   = & dcc->frame[d][f];
      cell_w  = frame->nb_cells_w;
      cell_h  = frame->nb_cells_h;
      cell0_x = (frame->box.xmin - dir->box.xmin) / 4;
      cell0_y = (frame->box.ymin - dir->box.ymin) / 4;
      
      // for each cells of this frame
      for (y=0; y < cell_h; y++)
      {
         curr_cell_y = cell0_y + y;
         for (x=0; x < cell_w; x++)
         {
            curr_cell_x = cell0_x + x;
            curr_cell   = curr_cell_x + (curr_cell_y * buff_w);
            if (curr_cell >= nb_cell)
            {
               sprintf(dcc_error, "dcc_fill_pixel_buffer() : "
                  "can't check the cell %i in cell_buffer,\n"
                  "run-time max cell is %i\n"
                  "dir %i, frm %i, x=%i, y=%i\n",
                  curr_cell, nb_cell,
                  d, f, x, y);
               free(cell_buffer);
               return 1;
            }

            // check if this cell need a new entry in pixel_buffer
            next_cell = FALSE;
            if (cell_buffer[curr_cell] != NULL)
            {
               if (dir->equal_cell_bitstream_size)
               {
                  if (dcc_read_bits( & dir->equal_cell_bitstream,
                                     1, FALSE, & tmp))
                  {
                     sprintf(add_error, "dcc_fill_pixel_buffer() : "
                        "equal_cell bitstream\ndirection %i, frame %i, "
                        "curr_cell %i\n",
                         d, f, curr_cell);
                     strcat(dcc_error, add_error);
                     free(cell_buffer);
                     return 1;
                  }
               }
               else
                  tmp = 0;
               if (tmp == 0)
               {
                  if (dcc_read_bits( & dir->pixel_mask_bitstream,
                                     4, FALSE, & pixel_mask))
                  {
                     sprintf(add_error, "dcc_fill_pixel_buffer() : "
                        "pixel_mask bitstream\n"
                        "direction %i, frame %i, curr_cell %i\n"
                        "x=%i, y=%i\n",
                         d, f, curr_cell, x, y);
                     strcat(dcc_error, add_error);
                     free(cell_buffer);
                     return 1;
                  }
                                 
               }
               else
                  next_cell = TRUE;
            }
            else
               pixel_mask = 0x0F;

            if (next_cell == FALSE)
            {
               // decode the pixels

               // read_pixel[] is a stack, where we "push" the pixel code
               read_pixel[0] = read_pixel[1] = 0;
               read_pixel[2] = read_pixel[3] = 0;
               last_pixel    = 0;
               nb_pix        = nb_pix_table[pixel_mask];
               if (nb_pix && dir->encoding_type_bitstream_size)
               {
                  if (dcc_read_bits( & dir->encoding_type_bitstream,
                                     1, FALSE, & encoding_type))
                  {
                     sprintf(add_error, "dcc_fill_pixel_buffer() :\n   "
                        "encoding_type bitstream, direction %i, frame %i, "
                        "curr_cell %i\n"
                        "   nb_pix = %i, curr_cell_x y = %i %i\n",
                         d, f, curr_cell, nb_pix, curr_cell_x, curr_cell_y);
                     strcat(dcc_error, add_error);
                     free(cell_buffer);
                     return 1;
                  }
               }
               else
                  encoding_type = 0;
               decoded_pix = 0;
               for (i=0; i < nb_pix; i++)
               {
                  if (encoding_type)
                  {
                     if (dcc_read_bits( & dir->raw_pixel_bitstream,
                                        8, FALSE, & read_pixel[i]))
                     {
                        sprintf(add_error, "dcc_fill_pixel_buffer() :\n   "
                           "raw_pixel bitstream, direction %i, frame %i, "
                           "curr_cell %i\n"
                           "   nb_pix = %i, curr_cell_x y = %i %i\n",
                           d, f, curr_cell, nb_pix, curr_cell_x, curr_cell_y);
                        strcat(dcc_error, add_error);
                        free(cell_buffer);
                        return 1;
                     }
                  }
                  else
                  {
                     read_pixel[i] = last_pixel;
                     if (dcc_read_bits(
                        & dir->pixel_code_and_displacment_bitstream,
                        4, FALSE, & pix_displ))
                     {
                        sprintf(add_error, "dcc_fill_pixel_buffer() :\n   "
                           "pixel_code_and_displacment bitstream, direction %i, frame %i, "
                           "curr_cell %i\n",
                            d, f, curr_cell);
                        strcat(dcc_error, add_error);
                        free(cell_buffer);
                        return 1;
                     }
                     read_pixel[i] += pix_displ;
                     while (pix_displ == 15)
                     {
                        if (dcc_read_bits(
                           & dir->pixel_code_and_displacment_bitstream,
                           4, FALSE, & pix_displ))
                        {
                           sprintf(add_error, "dcc_fill_pixel_buffer() :\n   "
                              "pixel_code_and_displacment bitstream, direction %i, frame %i, "
                              "curr_cell %i\n",
                               d, f, curr_cell);
                           strcat(dcc_error, add_error);
                           free(cell_buffer);
                           return 1;
                        }
                        read_pixel[i] += pix_displ;
                     }
                  }
                  if (read_pixel[i] == last_pixel)
                  {
                     read_pixel[i] = 0; // discard this pixel
                     i = nb_pix;        // stop the decoding of pixels
                  }
                  else
                  {
                     last_pixel = read_pixel[i];
                     decoded_pix++;
                  }
               }
               
               // we have the 4 pixels code for the new entry in pixel_buffer
               old_entry = cell_buffer[curr_cell];
               pb_idx++;
               if (pb_idx >= DCC_MAX_PB_ENTRY)
               {
                  sprintf(dcc_error, "dcc_fill_pixel_buffer() : "
                     "can't add a new entry in pixel buffer,\nmax is %i\n"
                     "direction %i, frame %i, curr_cell %i\n"
                     "   nb_pix = %i, curr_cell_x y = %i %i\n",
                     DCC_MAX_PB_ENTRY, d, f, curr_cell, nb_pix,
                     curr_cell_x, curr_cell_y);
                  free(cell_buffer);
                  return 1;
               }
               new_entry = & dir->pixel_buffer[pb_idx];
               curr_idx  = decoded_pix - 1; // we'll "pop" them
               for (i=0; i<4; i++)
               {
                  if (pixel_mask & (1 << i))
                  {
                     if (curr_idx >= 0) // if stack is not empty, pop it
                        new_entry->val[i] = (UBYTE) read_pixel[curr_idx--];
                     else // else pop a 0
                        new_entry->val[i] = 0;
                  }
                  else
                     new_entry->val[i] = old_entry->val[i];
               }
               cell_buffer[curr_cell]      = new_entry;
               new_entry->frame            = f;
               new_entry->frame_cell_index = x + (y * cell_w);
            }
         }
      }
   }

   // prepare the stage 2
   //    replace pixel codes in pixel_buffer by their true values
   for (i=0; i <= pb_idx; i++)
   {
      for (x=0; x<4; x++)
      {
         y = dir->pixel_buffer[i].val[x];
         dir->pixel_buffer[i].val[x] = dir->pixel_values[y];
      }
   }

   // end
   dir->pb_nb_entry = pb_idx + 1;
   free(cell_buffer);
   return 0;
}


// ==========================================================================
int dcc_save_frame(DCC_S * dcc, int d, int f, BITMAP * frm_bmp)
{
   DCC_FRAME_S * fptr = & dcc->frame[d][f];

   fptr->bmp = create_bitmap(frm_bmp->w, frm_bmp->h);
   if (fptr->bmp == NULL)
   {
      sprintf(dcc_error, "dcc_save_frame() : can't create final frame "
                         "bitmap of %i * %i pixels\n",
                         frm_bmp->w, frm_bmp->h);
      return 1;
   }
   blit(frm_bmp, fptr->bmp, 0, 0, 0, 0, frm_bmp->w, frm_bmp->h);


#ifdef DCCINFO_SAVE_PCX
   {
      char    tmp[30];
      PALETTE tmppal;
      FILE    * in;
      int     i;

      in = fopen("act1.dat", "rb");
      if (in != NULL)
      {
         for (i=0; i<256; i++)
         {
            tmppal[i].b = (UBYTE) fgetc(in) >> 2;
            tmppal[i].g = (UBYTE) fgetc(in) >> 2;
            tmppal[i].r = (UBYTE) fgetc(in) >> 2;
         }
         fclose(in);
         sprintf(tmp, "d%02i-f%03i.pcx", d, f);
         save_pcx(tmp, frm_bmp, tmppal);
      }
      else
         return 1;
   }
#endif

   return 0;
}


// ==========================================================================
// stage 2 of the decompression of the direction frames
// return 0 on success, non-zero if error
int dcc_make_frames(DCC_S * dcc, int d)
{
   DCC_DIRECTION_S * dir = & dcc->direction[d];
   DCC_PB_ENTRY_S  * pbe = dir->pixel_buffer;
   DCC_FRAME_S     * frame;
   DCC_CELL_S      * buff_cell, * cell;
   UDWORD          pix;
   int             nb_cell, nb_bit,
                   cell_x, cell_y, cell_idx,
                   x, y, f, c;
   BITMAP          * frm_bmp;
   char            add_error[256];


   // initialised the last_w & last_h of the buffer cells
   for (c=0; c < dir->nb_cells_w * dir->nb_cells_h; c++)
   {
      dir->buffer_ptr[c].last_w  = -1;
      dir->buffer_ptr[c].last_h  = -1;
   }

   // create the temp frame bitmap (size = current direction box)
   frm_bmp = create_bitmap(dir->box.width, dir->box.height);
   if (frm_bmp == NULL)
   {
      sprintf(dcc_error, "dcc_make_frames() : can't create tmp frame bitmap of %ld * %ld pixels", dir->box.width, dir->box.height);
      return 1;
   }
      
   // for all frames
   for (f=0; f < dcc->header.frames_per_dir; f++)
   {
      clear(frm_bmp); // clear the final frame bitmap (to index 0)
      frame = & dcc->frame[d][f];
      nb_cell = frame->nb_cells_w * frame->nb_cells_h;

      // for all cells of this frame
      for (c=0; c < nb_cell; c++)
      {
         // frame cell
         cell = & frame->cell[c];

         // buffer cell
         cell_x    = cell->x0 / 4;
         cell_y    = cell->y0 / 4;
         cell_idx  = cell_x + (cell_y * dir->nb_cells_w);
         buff_cell = & dir->buffer_ptr[cell_idx];
         
         // equal cell checks
         if ((pbe->frame != f) || (pbe->frame_cell_index != c))
         {
            // this buffer cell have an equalcell bit set to 1
            //    so either copy the frame cell or clear it
            
            if ((cell->w != buff_cell->last_w) || (cell->h != buff_cell->last_h))
            {
               // different sizes
               clear(cell->bmp); // set all pixels of the frame cell to 0
            }
            else
            {
               // same sizes
               
               // copy the old frame cell into its new position
               blit(dir->bmp, dir->bmp,
                    buff_cell->last_x0, buff_cell->last_y0,
                    cell->x0, cell->y0,
                    cell->w, cell->h
               );
               
               // copy it again, into the final frame bitmap
               blit(cell->bmp, frm_bmp,
                    0, 0,
                    cell->x0, cell->y0,
                    cell->w, cell->h
               );
            }
         }
         else
         {
            // fill the frame cell with pixels
            
            if (pbe->val[0] == pbe->val[1])
            {
               // fill FRAME cell to color val[0]
               clear_to_color(cell->bmp, pbe->val[0]);
            }
            else
            {
               if (pbe->val[1] == pbe->val[2])
                  nb_bit = 1;
               else
                  nb_bit = 2;

               // fill FRAME cell with pixels
               for (y=0; y < cell->h; y++)
               {
                  for (x=0; x < cell->w; x++)
                  {
                     if (dcc_read_bits(
                        & dcc->direction[d].pixel_code_and_displacment_bitstream,
                        nb_bit, FALSE, & pix))
                     {
                        sprintf(add_error, "dcc_make_frame() :\n   "
                           "pixel_code_and_displacment bitstream, direction %i, frame %i, "
                           "curr_cell %i\n",
                        d, pbe->frame, pbe->frame_cell_index);
                        strcat(dcc_error, add_error);
                        return 1;
                     }
                     putpixel(cell->bmp, x, y, pbe->val[pix]);
                  }
               }
            }

            // copy the frame cell into the frame bitmap
            blit(cell->bmp, frm_bmp,
                 0, 0,
                 cell->x0, cell->y0,
                 cell->w, cell->h
            );

            // next pixelbuffer entry
            pbe++;
         }

         // for the buffer cell that was used by this frame cell,
         // save the width & size of the current frame cell
         // (needed for further tests about equalcell)
         buff_cell->last_w  = cell->w;
         buff_cell->last_h  = cell->h;

         // and save its origin, for further copy when equalcell
         buff_cell->last_x0 = cell->x0;
         buff_cell->last_y0 = cell->y0;
      }

      // save frame
      dcc_save_frame(dcc, d, f, frm_bmp);
   }

   // end
   destroy_bitmap(frm_bmp);
   return 0;
}


// ==========================================================================
// read 1 direction bitstream
// return 0 on success, non-zero if error
int dcc_dir_bitstream(DCC_S * dcc, int d)
{
   DCC_BITSTREAM_S bs;
   int             f;
   char            add_error[80];
   
   // if already done, return
   if (dcc->direction[d].bmp != NULL)
      return 0;
   
   // in case
   if ((d < 0) || (d >= dcc->header.directions))
   {
      sprintf(dcc_error, "dcc_dir_bitstream() : invalid direction, %i is "
                         "not in the range [0; %i]\n",
                         d, dcc->header.directions);
      return 1;
   }

   // init direction bitstream
   bs.cur_bit     = 0;
   bs.cur_bit_num = 0;
   bs.cur_byte    = 0;
   bs.data        = dcc->ptr + dcc->header.dir_offset[d];
   if (d == dcc->header.directions - 1)
      bs.size = 8 * (dcc->size - dcc->header.dir_offset[d]);
   else
      bs.size = 8 * (dcc->header.dir_offset[d + 1] -
                     dcc->header.dir_offset[d]);
   
   // read direction datas
   // œ¬√Ê «∞¥’’ ˝æ›Ω·ππ¿¥µƒ
   if (dcc_read_bits( & bs, 32, FALSE, & dcc->direction[d].outsize_coded))
   {
      sprintf(add_error, "direction %i, outsize_coded\n", d);
      strcat(dcc_error, add_error);
      return 1;
   }
   
   if (dcc_read_bits( & bs, 2, FALSE, & dcc->direction[d].compression_flag))
   {
      sprintf(add_error, "direction %i, compression_flag\n", d);
      strcat(dcc_error, add_error);
      return 1;
   }
   
   if (dcc_read_bits( & bs, 4, FALSE, & dcc->direction[d].variable0_bits))
   {
      sprintf(add_error, "direction %i, variable0_bits\n", d);
      strcat(dcc_error, add_error);
      return 1;
   }
   
   if (dcc_read_bits( & bs, 4, FALSE, & dcc->direction[d].width_bits))
   {
      sprintf(add_error, "direction %i, width_bits\n", d);
      strcat(dcc_error, add_error);
      return 1;
   }
   
   if (dcc_read_bits( & bs, 4, FALSE, & dcc->direction[d].height_bits))
   {
      sprintf(add_error, "direction %i, height_bits\n", d);
      strcat(dcc_error, add_error);
      return 1;
   }
   
   if (dcc_read_bits( & bs, 4, FALSE, & dcc->direction[d].xoffset_bits))
   {
      sprintf(add_error, "direction %i, xoffset_bits\n", d);
      strcat(dcc_error, add_error);
      return 1;
   }
   
   if (dcc_read_bits( & bs, 4, FALSE, & dcc->direction[d].yoffset_bits))
   {
      sprintf(add_error, "direction %i, yoffset_bits\n", d);
      strcat(dcc_error, add_error);
      return 1;
   }
   
   if (dcc_read_bits( & bs, 4, FALSE, & dcc->direction[d].optional_bytes_bits))
   {
      sprintf(add_error, "direction %i, optional_bytes_bits\n", d);
      strcat(dcc_error, add_error);
      return 1;
   }
   
   if (dcc_read_bits( & bs, 4, FALSE, & dcc->direction[d].coded_bytes_bits))
   {
      sprintf(add_error, "direction %i, coded_bytes_bits\n", d);
      strcat(dcc_error, add_error);
      return 1;
   }

   
   // init direction box min & max (NOT ZERO !)
   dcc->direction[d].box.xmin = dcc->direction[d].box.ymin = 0x7FFFFFFFL;
   dcc->direction[d].box.xmax = dcc->direction[d].box.ymax = 0x80000000L;

   
   // read frames header
   for (f=0; f < dcc->header.frames_per_dir; f++)
   {
	   //À˘”–µƒ ˝æ›≤ª «’‚¿Ô∂¡»°µƒ..
      if (dcc_frame_header_bitstream(dcc, & bs, d, f))
      {
         sprintf(add_error, "direction %i, frames header\n", d);
         strcat(dcc_error, add_error);
         return 1;
      }

      // direction box
      if (dcc->frame[d][f].box.xmin < dcc->direction[d].box.xmin)
         dcc->direction[d].box.xmin = dcc->frame[d][f].box.xmin;

      if (dcc->frame[d][f].box.ymin < dcc->direction[d].box.ymin)
         dcc->direction[d].box.ymin = dcc->frame[d][f].box.ymin;

      if (dcc->frame[d][f].box.xmax > dcc->direction[d].box.xmax)
         dcc->direction[d].box.xmax = dcc->frame[d][f].box.xmax;

      if (dcc->frame[d][f].box.ymax > dcc->direction[d].box.ymax)
         dcc->direction[d].box.ymax = dcc->frame[d][f].box.ymax;
   }
   dcc->direction[d].box.width = dcc->direction[d].box.xmax - dcc->direction[d].box.xmin + 1;
   dcc->direction[d].box.height = dcc->direction[d].box.ymax - dcc->direction[d].box.ymin + 1;

   // optional bytes data
   if (dcc_optional_datas(dcc, & bs, d))
      return 1;
   
   // another bitstreams size
   if (dcc_other_bitstream_size(dcc, & bs, d))
      return 1;

   // pixel values key (256 bits)
   if (dcc_pixel_values_key(dcc, & bs, d))
      return 1;

   // init the other bitstreams
   dcc_init_dir_bitstream(dcc, & bs, d);

   // stage 1 : fill the pixelbuffer
   if (dcc_fill_pixel_buffer(dcc, d))
      return 1;

   // stage 2 : build the frames
   if (dcc_make_frames(dcc, d))
      return 1;

   // end
   if (dcc->direction[d].pixel_buffer)
   {
      free(dcc->direction[d].pixel_buffer);
      dcc->direction[d].pixel_buffer = NULL;
   }

   // check for not obvious decoding error
   if (dcc->direction[d].equal_cell_bitstream_size !=
       dcc->direction[d].equal_cell_bitstream.cur_bit_num)
   {
      sprintf(dcc_error, "direction %i, equal_cell bitstream not read completly while it should\n", d);
      strcat(dcc_error, add_error);
      return 1;
   }
   if (dcc->direction[d].pixel_mask_bitstream_size !=
       dcc->direction[d].pixel_mask_bitstream.cur_bit_num)
   {
      sprintf(dcc_error, "direction %i, pixel_mask bitstream not read completly while it should\n", d);
      strcat(dcc_error, add_error);
      return 1;
   }
   if (dcc->direction[d].encoding_type_bitstream_size !=
       dcc->direction[d].encoding_type_bitstream.cur_bit_num)
   {
      sprintf(dcc_error, "direction %i, encoding_type bitstream not read completly while it should\n", d);
      strcat(dcc_error, add_error);
      return 1;
   }
   if (dcc->direction[d].pixel_code_and_displacment_bitstream.cur_bit_num + 7
        < dcc->direction[d].pixel_code_and_displacment_bitstream.size)
   {
      sprintf(dcc_error, "direction %i, pixel_code_and_displacment bitstream not read completly while it should\n", d);
      strcat(dcc_error, add_error);
      return 1;
   }
   
   return 0;
}


// ==========================================================================
// read dcc file header
int dcc_file_header(DCC_S * dcc)
{
   DCC_BITSTREAM_S bs;
   int             i;
   
   if (dcc->header.already_decoded == TRUE)
      return 0;
      
   bs.cur_bit     = 0;
   bs.cur_bit_num = 0;
   bs.cur_byte    = 0;
   bs.data        = dcc->ptr;
   bs.size        = 8 * dcc->size;


   //’‚tmd√˜œ‘≤ª «“ª∏ˆ»À–¥µƒ¥˙¬Î
   //√≤À∆◊˜’ﬂ”√¡À«∞»Àµƒ¥˙¬Î
   //◊˜’ﬂ√ª”–’‚√¥∂¡»°◊÷Ω⁄µƒœ∞πﬂµƒ...


   
//typedef struct DCC_HEADER_S
//{
//   UBYTE file_signature;
//   UBYTE version;
//   UBYTE directions;
//   long  frames_per_dir;
//   long  tag; // always 1. A data's presence bitfield maybe,
//              //    like 0x01 = "final_dc6_size data present" ?
//   long  final_dc6_size;
//   long  dir_offset [DCC_MAX_DIR];
//
//   int   already_decoded;
//} DCC_HEADER_S;

   
   if (dcc_read_bytes( & bs, 1, & dcc->header.file_signature))
      return 1;
      
   if (dcc_read_bytes( & bs, 1, & dcc->header.version))
      return 1;

   if (dcc_read_bytes( & bs, 1, & dcc->header.directions))
      return 1;

   if (dcc_read_bytes( & bs, 4, & dcc->header.frames_per_dir))
      return 1;

//   long  tag; // always 1. A data's presence bitfield maybe,
   if (dcc_read_bytes( & bs, 4, & dcc->header.tag))
      return 1;

   if (dcc_read_bytes( & bs, 4, & dcc->header.final_dc6_size))
      return 1;

   for (i=0; i < dcc->header.directions; i++)
      if (dcc_read_bytes( & bs, 4, & dcc->header.dir_offset[i]))
         return 1;

   // end
   dcc->header.already_decoded = TRUE;
   return 0;
}


// ==========================================================================
// read a dcc and decode it
// dir_bitfield is a bitfield : set the bit(s) for the direction(s) to decode
// return 0 on sucess, non-zero if error
//Œ“º«µ√direction◊Ó∂‡ø…“‘¥ÔµΩ32∏ˆ∑ΩœÚ..∏’∫√long”–32bits
//’‚∏ˆ∂´Œ˜æÕ «”√¿¥÷∏ ædirectionµƒ
int dcc_decode(DCC_S * dcc, long dir_bitfield)
{
   int d;
   
   // init the dcc_bits_width_table[]
   //ΩˆΩˆ≥ı ºªØ¡À dcc_bits_width_table ˝◊È∂¯“—
   dcc_init();

   // init direction box min & max (NOT ZERO !)
   dcc->box.xmin = dcc->box.ymin = 0x7FFFFFFFL; // highest long number
   dcc->box.xmax = dcc->box.ymax = 0x80000000L; // lowest  long number
   
   // file header
   //∂¡»°Õ∑Œƒº˛
   if (dcc_file_header(dcc))
      return 1;
   
   // direction bitstream
   for (d=0; d<dcc->header.directions; d++)
   {
      if (dir_bitfield & (1 << d)) {
		  // dir_bitfield≤Œ ˝¥´»Îµƒ «1<<dir
		  // dir÷ª”–“ª∏ˆbit «1,∆‰À˚∂ºŒ™0
		  // ’‚∏ˆ‘⁄≤‚ ‘ƒ≥“ªbitµƒ∂´Œ˜, Œ“œÎ÷™µ¿directions“ª∞„ «∂‡…Ÿ???
         if (dcc_dir_bitstream(dcc, d))
            return 1;

         // dcc box
         if (dcc->direction[d].box.xmin < dcc->box.xmin)
            dcc->box.xmin = dcc->direction[d].box.xmin;

         if (dcc->direction[d].box.ymin < dcc->box.ymin)
            dcc->box.ymin = dcc->direction[d].box.ymin;

         if (dcc->direction[d].box.xmax > dcc->box.xmax)
            dcc->box.xmax = dcc->direction[d].box.xmax;

         if (dcc->direction[d].box.ymax > dcc->box.ymax)
            dcc->box.ymax = dcc->direction[d].box.ymax;
      }
   }
   dcc->box.width  = dcc->box.xmax - dcc->box.xmin + 1;
   dcc->box.height = dcc->box.ymax - dcc->box.ymin + 1;

   // end
   return 0;
}


// ==========================================================================
// output the dcc datas in a more usable form
void dcc_debug(DCC_S * dcc)
{
   int d, f, i;
  
   printf("file_signature = %i\n",  dcc->header.file_signature);
   printf("version        = %i\n",  dcc->header.version);
   printf("directions     = %i\n",  dcc->header.directions);
   printf("frames_per_dir = %li\n", dcc->header.frames_per_dir);
   printf("tag            = %li\n", dcc->header.tag);
   printf("final_dc6_size = %li bytes\n", dcc->header.final_dc6_size);

   printf("\nbox                = (%li, %li)  --->  (%li, %li)  =  %li * %li\n",
      dcc->box.xmin, dcc->box.ymin,
      dcc->box.xmax, dcc->box.ymax,
      dcc->box.width, dcc->box.height
   );

   for (d=0; d<dcc->header.directions; d++)
   {
      printf("\ndirection %2i\n", d);
      printf("   outsize_coded       = %li bytes\n", dcc->direction[d].outsize_coded);
      printf("   compression_flag    = %li\n", dcc->direction[d].compression_flag);
      printf("   variable0_bits      = %2lu  (%2i bits)\n", dcc->direction[d].variable0_bits,      dcc_bits_width_table[dcc->direction[d].variable0_bits]);
      printf("   width_bits          = %2lu  (%2i bits)\n", dcc->direction[d].width_bits,          dcc_bits_width_table[dcc->direction[d].width_bits]);
      printf("   height_bits         = %2lu  (%2i bits)\n", dcc->direction[d].height_bits,         dcc_bits_width_table[dcc->direction[d].height_bits]);
      printf("   xoffset_bits        = %2lu  (%2i bits)\n", dcc->direction[d].xoffset_bits,        dcc_bits_width_table[dcc->direction[d].xoffset_bits]);
      printf("   yoffset_bits        = %2lu  (%2i bits)\n", dcc->direction[d].yoffset_bits,        dcc_bits_width_table[dcc->direction[d].yoffset_bits]);
      printf("   optional_bytes_bits = %2lu  (%2i bits)\n", dcc->direction[d].optional_bytes_bits, dcc_bits_width_table[dcc->direction[d].optional_bytes_bits]);
      printf("   coded_bytes_bits    = %2lu  (%2i bits)\n", dcc->direction[d].coded_bytes_bits,    dcc_bits_width_table[dcc->direction[d].coded_bytes_bits]);
      printf("   box                 = (%li, %li)  --->  (%li, %li)  =  %li * %li\n",
         dcc->direction[d].box.xmin,
         dcc->direction[d].box.ymin,
         dcc->direction[d].box.xmax,
         dcc->direction[d].box.ymax,
         dcc->direction[d].box.width,
         dcc->direction[d].box.height
      );
      printf("   cells               = %i * %i = %i\n",
         dcc->direction[d].nb_cells_w,
         dcc->direction[d].nb_cells_h,
         dcc->direction[d].nb_cells_w * dcc->direction[d].nb_cells_h
      );
      printf("   CVDCC.DLL offsets   = %li, %li (in version < 3.0)\n\n",
         dcc->direction[d].box.xmin,
         dcc->direction[d].box.ymax
      );
      printf("   equal_cell_bitstream_size       = %8li bits (read %8li)\n", dcc->direction[d].equal_cell_bitstream_size, dcc->direction[d].equal_cell_bitstream.cur_bit_num);
      printf("   pixel_mask_bitstream_size       = %8li bits (read %8li)\n", dcc->direction[d].pixel_mask_bitstream_size, dcc->direction[d].pixel_mask_bitstream.cur_bit_num);
      printf("   encoding_type_bitstream_size    = %8li bits (read %8li)\n", dcc->direction[d].encoding_type_bitstream_size, dcc->direction[d].encoding_type_bitstream.cur_bit_num);
      printf("   raw_pixel_bitstream_size        = %8li bits (read %8li)\n", dcc->direction[d].raw_pixel_bitstream_size, dcc->direction[d].raw_pixel_bitstream.cur_bit_num);
      printf("   pixel_code_and_displacment.size = %8li bits (read %8li)\n", dcc->direction[d].pixel_code_and_displacment_bitstream.size, dcc->direction[d].pixel_code_and_displacment_bitstream.cur_bit_num);

      printf("\n   pixel_values :\n");
      for (i=0; i < 256; i++)
      {
         printf(" %3i", dcc->direction[d].pixel_values[i]);
         if ( ! ((i+1) % 16))
            printf("\n");
      }

      for (f=0; f<dcc->header.frames_per_dir; f++)
      {
         printf("\n   frame %3i\n", f);

         if (dcc->direction[d].variable0_bits)
            printf("      variable0      = %lu\n", dcc->frame[d][f].variable0);

         if (dcc->direction[d].width_bits)
            printf("      width          = %lu\n", dcc->frame[d][f].width);

         if (dcc->direction[d].height_bits)
            printf("      height         = %lu\n", dcc->frame[d][f].height);

         if (dcc->direction[d].xoffset_bits)
            printf("      xoffset        = %li\n", dcc->frame[d][f].xoffset);

         if (dcc->direction[d].yoffset_bits)
            printf("      yoffset        = %li\n", dcc->frame[d][f].yoffset);

         if (dcc->direction[d].optional_bytes_bits)
            printf("      optional_bytes = %lu\n", dcc->frame[d][f].optional_bytes);

         if (dcc->direction[d].coded_bytes_bits)
            printf("      coded_bytes    = %lu\n", dcc->frame[d][f].coded_bytes);

         printf("      bottom_up      = %li\n", dcc->frame[d][f].bottom_up);
         printf("      box            = (%li, %li)  --->  (%li, %li)  =  %li * %li\n",
            dcc->frame[d][f].box.xmin,
            dcc->frame[d][f].box.ymin,
            dcc->frame[d][f].box.xmax,
            dcc->frame[d][f].box.ymax,
            dcc->frame[d][f].box.width,
            dcc->frame[d][f].box.height
         );

         printf("      box2           = (%li, %li)  --->  (%li, %li)  =  %li * %li\n",
            dcc->frame[d][f].box.xmin - dcc->direction[d].box.xmin,
            dcc->frame[d][f].box.ymin - dcc->direction[d].box.ymin,
            dcc->frame[d][f].box.xmax - dcc->direction[d].box.xmin,
            dcc->frame[d][f].box.ymax - dcc->direction[d].box.ymin,
            dcc->frame[d][f].box.width,
            dcc->frame[d][f].box.height
         );

         printf("      cells          = %i * %i = %i\n",
            dcc->frame[d][f].nb_cells_w,
            dcc->frame[d][f].nb_cells_h,
            dcc->frame[d][f].nb_cells_w * dcc->frame[d][f].nb_cells_h
         );

         printf("      1st cell0_x, y = %d, %d\n", dcc->frame[d][f].cell[0].x0, dcc->frame[d][f].cell[0].y0);

         if (dcc->frame[d][f].optional_bytes)
         {
            printf("      optional datas =");
            for (i=0; i < (int) dcc->frame[d][f].optional_bytes; i++)
               printf(" %02X", dcc->frame[d][f].optional_bytes_data[i]);
            printf("\n");
         }
      }
   }
   printf("\ndcc_error[] :\n%s", dcc_error);
}


// ==========================================================================
// copy the file from disk into mem
// return NULL on error, check dcc_error in this case
// if success, return a pointer on a DCC_S structure
//    it's up to you to free the memory at the end of the program
//    with the help of dcc_destroy()
DCC_S * dcc_disk_load(char * dcc_name)
{
   DCC_S * dcc;
   FILE  * in;
   int   size;

   // open file
   in = fopen(dcc_name, "rb");
   if (in == NULL)
   {
      sprintf(dcc_error, "dcc_disk_load() : can't open %s\n", dcc_name);
      return NULL;
   }

   // malloc
   size = sizeof(DCC_S);
   dcc = (DCC_S *) malloc(size);
   if (dcc == NULL)
   {
      sprintf(dcc_error, "dcc_disk_load() : can't allocate %i bytes (main struct) "
                         "for %s\n", size, dcc_name);
      fclose(in);
      return NULL;
   }
   memset(dcc, 0, size);

   // get size of the file
   fseek(in, 0, SEEK_END);
   dcc->size = ftell(in);
   if (dcc->size < 0)
   {
      sprintf(dcc_error, "dcc_disk_load() : ftell() have return %li "
                         "for %s\n", dcc->size, dcc_name);
      fclose(in);
      free(dcc);
      return NULL;
   }
   fseek(in, 0, SEEK_SET);

   // buffer for the copy in mem
   dcc->ptr = (UBYTE *) malloc(dcc->size);
   if (dcc->ptr == NULL)
   {
      sprintf(dcc_error, "dcc_disk_load() : can't allocate %li bytes (buffer) "
                         "for %s\n", dcc->size, dcc_name);
      fclose(in);
      free(dcc);
      return NULL;
   }
   
   // fill buffer
   fread(dcc->ptr, dcc->size, 1, in);

   // end
   fclose(in);
   return dcc;
}


// ==========================================================================
// copy the file from mem into mem
// (this function make a copy of the buffer you give)
// return NULL on error, check dcc_error in this case
// if success, return a pointer on a DCC_S structure
//    it's up to you to free the memory at the end of the program
//    with the help of dcc_destroy()
DCC_S * dcc_mem_load(void * mem_ptr, int mem_size)
{
   DCC_S * dcc;
   int   size;

   // malloc
   size = sizeof(DCC_S);
   dcc = (DCC_S *) malloc(size);
   if (dcc == NULL)
   {
      sprintf(dcc_error, "dcc_mem_load() : can't allocate %i bytes "
         "(main struct)\n", size);
      return NULL;
   }
   memset(dcc, 0, size);

   // get size of the file
   dcc->size = mem_size;
   if (dcc->size < 0)
   {
      sprintf(dcc_error, "dcc_mem_load() : size is %i bytes\n", mem_size);
      free(dcc);
      return NULL;
   }

   // buffer for the copy in mem
   dcc->ptr = (UBYTE *) malloc(dcc->size);
   if (dcc->ptr == NULL)
   {
      sprintf(dcc_error, "dcc_mem_load() : can't allocate %li bytes "
         "(buffer)\n", dcc->size);
      free(dcc);
      return NULL;
   }
   
   // fill buffer
   memcpy(dcc->ptr, mem_ptr, mem_size);

   // end
   return dcc;
}


// ==========================================================================
// free a dcc from memory
void dcc_destroy(DCC_S * dcc)
{
   int d, f, nb_cell, i;

   
   if (dcc == NULL)
      return;

   // free the copy of the file in mem
   if (dcc->ptr != NULL)
   {
      free(dcc->ptr);
      dcc->ptr = NULL;
   }

   // free datas in all directions
   for (d=0; d < dcc->header.directions; d++)
   {
      // free datas in all frames for this direction
      for (f=0; f < dcc->header.frames_per_dir; f++)
      {
         // free optional bytes, if any
         if (dcc->frame[d][f].optional_bytes_data)
         {
            free(dcc->frame[d][f].optional_bytes_data);
            dcc->frame[d][f].optional_bytes_data = NULL;
         }

         // free frame cells & sub-bitmaps
         if (dcc->frame[d][f].cell)
         {
            nb_cell = dcc->frame[d][f].nb_cells_w * dcc->frame[d][f].nb_cells_h;
            for (i=0; i < nb_cell; i++)
               if (dcc->frame[d][f].cell[i].bmp)
                  destroy_bitmap(dcc->frame[d][f].cell[i].bmp);

            free(dcc->frame[d][f].cell);
            dcc->frame[d][f].cell = NULL;
         }

         //destroy frame bitmap
         if (dcc->frame[d][f].bmp)
            destroy_bitmap(dcc->frame[d][f].bmp);
      }

      // free pixels buffer
      if (dcc->direction[d].pixel_buffer)
      {
         free(dcc->direction[d].pixel_buffer);
         dcc->direction[d].pixel_buffer = NULL;
      }

      // destroy buffer cells & sub-bitmaps
      if (dcc->direction[d].buffer_ptr)
      {
         nb_cell = dcc->direction[d].nb_cells_w * dcc->direction[d].nb_cells_h;
         for (i=0; i < nb_cell; i++)
            if (dcc->direction[d].buffer_ptr[i].bmp)
               destroy_bitmap(dcc->direction[d].buffer_ptr[i].bmp);
               
         free(dcc->direction[d].buffer_ptr);
         dcc->direction[d].buffer_ptr = NULL;
      }

      // destroy buffer bitmap
      if (dcc->direction[d].bmp)
         destroy_bitmap(dcc->direction[d].bmp);
   }

   // free general structure of this dcc
   free(dcc);
}
#include <string.h>
#include "structs.h"
#include "dt1misc.h"
#include "error.h"
#include "editobj.h"
#include "wpreview.h"
#include "ds1misc.h"
#include "misc.h"


// ==========================================================================
// memory free of a ds1 (with the dt1 it uses, and some other buffers)
int ds1_free(int i)
{
   int d, total = 0;
   
   if (strlen(glb_ds1[i].name) == 0)
      return 0;

   fprintf(stderr, "      . %s\n", glb_ds1[i].name);
   fflush(stderr);

   // dt1 of this ds1
   fprintf(stderr, "         _ dt1s");
   fflush(stderr);
   for (d=0; d<DT1_IN_DS1_MAX; d++)
      dt1_del(glb_ds1[i].dt1_idx[d]);
      
   // block table
   fprintf(stderr, ", block table");
   fflush(stderr);
   if (glb_ds1[i].block_table != NULL)
   {
      total += glb_ds1[i].bt_num * sizeof(BLOCK_TABLE_S);
      free(glb_ds1[i].block_table);
   }

   // file buffer
   fprintf(stderr, ", file buffer");
   fflush(stderr);
   if (glb_ds1[i].file_buff != NULL)
   {
      total += glb_ds1[i].file_len;
      free(glb_ds1[i].file_buff);
   }

   // floors
   fprintf(stderr, ", floors");
   fflush(stderr);
   if (glb_ds1[i].floor_buff != NULL)
   {
      total += glb_ds1[i].floor_buff_len;
      free(glb_ds1[i].floor_buff);
   }
   if (glb_ds1[i].floor_buff2 != NULL)
   {
      total += glb_ds1[i].floor_buff_len;
      free(glb_ds1[i].floor_buff2);
   }

   // shadow
   fprintf(stderr, ", shadows");
   fflush(stderr);
   if (glb_ds1[i].shadow_buff != NULL)
   {
      total += glb_ds1[i].shadow_buff_len;
      free(glb_ds1[i].shadow_buff);
   }
   if (glb_ds1[i].shadow_buff2 != NULL)
   {
      total += glb_ds1[i].shadow_buff_len;
      free(glb_ds1[i].shadow_buff2);
   }

   // tag
   fprintf(stderr, ", unknown");
   fflush(stderr);
   if (glb_ds1[i].tag_buff != NULL)
   {
      total += glb_ds1[i].tag_buff_len;
      free(glb_ds1[i].tag_buff);
   }
   if (glb_ds1[i].tag_buff2 != NULL)
   {
      total += glb_ds1[i].tag_buff_len;
      free(glb_ds1[i].tag_buff2);
   }

   // walls
   fprintf(stderr, ", walls\n");
   fflush(stderr);
   if (glb_ds1[i].wall_buff != NULL)
   {
      total += glb_ds1[i].wall_buff_len;
      free(glb_ds1[i].wall_buff);
   }
   if (glb_ds1[i].wall_buff2 != NULL)
   {
      total += glb_ds1[i].wall_buff_len;
      free(glb_ds1[i].wall_buff2);
   }

   // groups
   if (glb_ds1[i].group != NULL)
      free(glb_ds1[i].group);

   // end
   memset(& glb_ds1[i], 0, sizeof(DS1_S));
   fprintf(stderr, "         bytes free = %i\n", total);
   fflush(stderr);
   return total;
}


// ==========================================================================
// search the wall tile, giving the orientation/prop1/2/3/4
void wprop_2_block(int i, CELL_W_S * w_ptr)
{
   long             orientation;
   long             main_index;
   long             sub_index;
   int              b;

   BLOCK_TABLE_S    * bt_ptr = glb_ds1[i].block_table;

   w_ptr->bt_idx = -1; // not found by default
   if (w_ptr->prop1 == 0) {
       // µ⁄“ª∏ˆ–‘÷ : ÷∏∂®µ±«∞ «∑Ò”–tile?
       // no tile here
      w_ptr->bt_idx = 0;
      return;
   }
      
   orientation = w_ptr->orientation;
   main_index  = (w_ptr->prop3 >> 4) + ((w_ptr->prop4 & 0x03) << 4);
   sub_index   = w_ptr->prop2;
   for (b=0; b<glb_ds1[i].bt_num; b++) {
      if ( (bt_ptr->orientation == orientation) && (bt_ptr->main_index  == main_index)  && (bt_ptr->sub_index   == sub_index)   && (bt_ptr->used_by_editor)) {
         w_ptr->bt_idx = b;
         return;
      }
      bt_ptr++;
   }

   // trick of O=18 M=3 I=1 ---> O=19 M=3 I=0
   if ((orientation == 18) || (orientation == 19)) {
      if (orientation == 18) {
         orientation = 19;
      } else {
         orientation = 18;
      }

      // search with same sub_index (just in case)
      bt_ptr = glb_ds1[i].block_table;
      for (b=0; b<glb_ds1[i].bt_num; b++) {
         if ( (bt_ptr->orientation == orientation) && (bt_ptr->main_index  == main_index)  && (bt_ptr->sub_index   == sub_index)   && (bt_ptr->used_by_editor) ) {
            w_ptr->bt_idx = b;
            return;
         }
         bt_ptr++;
      }

      // search with sub_index = 0
      sub_index = 0;
      bt_ptr = glb_ds1[i].block_table;
      for (b=0; b<glb_ds1[i].bt_num; b++) {
         if ( (bt_ptr->orientation == orientation) && (bt_ptr->main_index  == main_index)  && (bt_ptr->sub_index   == sub_index)   && (bt_ptr->used_by_editor) ) {
            w_ptr->bt_idx = b;
            return;
         }
         bt_ptr++;
      }
   }
}


// ==========================================================================
// search the floor tile, giving the prop1/2/3/4
void fprop_2_block(int i, CELL_F_S * f_ptr)
{
   long          main_index, sub_index;
   int           b;
   BLOCK_TABLE_S * bt_ptr = glb_ds1[i].block_table;

   f_ptr->bt_idx = -1; // not found by default
   if (f_ptr->prop1 == 0) {
      // no tile here
      f_ptr->bt_idx = 0;
      return;
   }
   
   main_index  = (f_ptr->prop3 >> 4) + ((f_ptr->prop4 & 0x03) << 4);
   sub_index   = f_ptr->prop2;
   for (b=0; b<glb_ds1[i].bt_num; b++) {
      if ( (bt_ptr->orientation == 0)          && (bt_ptr->main_index  == main_index) && (bt_ptr->sub_index   == sub_index)  && (bt_ptr->used_by_editor) ) {
         f_ptr->bt_idx = b;
         return;
      }
      bt_ptr++;
   }
}


// ==========================================================================
// search the shadow tile, giving the prop1/2/3/4
void sprop_2_block(int i, CELL_S_S * s_ptr)
{
   BLOCK_TABLE_S * bt_ptr = glb_ds1[i].block_table;
   long          main_index, sub_index;
   int           b;

   s_ptr->bt_idx = -1; // not found by default
   if (s_ptr->prop1 == 0) {
      // no tile here
      s_ptr->bt_idx = 0;
      return;
   }
      
   main_index  = (s_ptr->prop3 >> 4) + ((s_ptr->prop4 & 0x03) << 4);
   sub_index   = s_ptr->prop2;
   for (b=0; b<glb_ds1[i].bt_num; b++) {
      if ( (bt_ptr->orientation == 13)         && (bt_ptr->main_index  == main_index) && (bt_ptr->sub_index   == sub_index)  && (bt_ptr->used_by_editor) ) {
         s_ptr->bt_idx = b;
         return;
      }
      bt_ptr++;
   }
}


// ==========================================================================
// search all the tiles (ds1 to dt1 relations)
// ’‚∏ˆπ¿º∆∫‹÷ÿ“™
void ds1_make_prop_2_block(int i)
{
   CELL_F_S         *f_ptr;
   CELL_S_S         *s_ptr;
   CELL_W_S         *w_ptr;

   int              x, y, n;
   
   w_ptr = glb_ds1[i].wall_buff;
   f_ptr = glb_ds1[i].floor_buff;
   s_ptr = glb_ds1[i].shadow_buff;

   for (y=0; y<glb_ds1[i].height; y++) {
      for (x=0; x<glb_ds1[i].width; x++) {

         for (n=0; n<glb_ds1[i].wall_num; n++) {
            wprop_2_block(i, w_ptr);
            w_ptr++;
         }
         for (n=0; n<glb_ds1[i].floor_num; n++) {
            fprop_2_block(i, f_ptr);
            f_ptr++;
         }
         for (n=0; n<glb_ds1[i].shadow_num; n++)
         {
            sprop_2_block(i, s_ptr);
/*
if (s_ptr->prop1)
{
 printf("shadow %3i, %3i : %3i %3i %3i %3i --> ",
 x, y,
 s_ptr->prop1,
 s_ptr->prop2,
 s_ptr->prop3,
 s_ptr->prop4);
 sprop_2_block(i, s_ptr);
 if (s_ptr->bt_idx == -1)
    printf("NOT FOUND with orientation 13\n");
 else
    printf("block table %i\n", s_ptr->bt_idx);
}
else
 sprop_2_block(i, s_ptr);
*/ 
            s_ptr++;
         }
      }
   }
}


// ==========================================================================
// read a ds1
//    load the file into memory, then copy the datas into the right structures
//    init some var, to prepare its display (zoom, center, layer mask...)
// if new_width OR new_height is <= 0, then no change to the size of the ds1, else
// it'll crop or add necessary Tiles 
int ds1_read(const char * ds1name, int ds1_idx, int new_width, int new_height)
{
    FILE        * in;
    CELL_F_S    * f_ptr[FLOOR_MAX_LAYER];
    CELL_S_S    * s_ptr[SHADOW_MAX_LAYER];
    CELL_T_S    * t_ptr[TAG_MAX_LAYER];
    CELL_W_S    * w_ptr[WALL_MAX_LAYER];
    CELL_W_S    * o_ptr[WALL_MAX_LAYER];
    OBJ_LABEL_S * label;

    int         o, x, y, nb_layer, size, n, p, ds1_len, done, cx, cy, dx, dy;
    int         current_valid_obj_idx=0;
    int         max_subtile_width;
    int         max_subtile_height;
    long        w_num, f_num, s_num, t_num, * ptr, npc, path;
    int         lay_stream[14];
    int         dir_lookup[25] = {
                    0x00, 0x01, 0x02, 0x01, 0x02, 0x03, 0x03, 0x05, 0x05, 0x06,
                    0x06, 0x07, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,
                    0x0F, 0x10, 0x11, 0x12, 0x14 };
    UBYTE       * bptr;
    void        * ds1_buff;
    int         obj_path_warn_wrote = FALSE, last_o, nb;
    char        tmp[150], * cptr;
    long        tile_x, tile_y, zoom;
    long        incr;

    DEBUG_MESSAGE("ds1_read(\"%s\"):in\n", ds1name);

    if(ds1_idx >= DS1_MAX){
        FATAL_EXIT("not enough free ds1 slot for %s, max is %i", ds1name, DS1_MAX);
    }

    if (strlen(glb_ds1[ds1_idx].name)){
        FATAL_EXIT("ds1 slot %i is already used by %s", ds1_idx, glb_ds1[ds1_idx].name);
    }

    if (stricmp(glb_ds1[ds1_idx].name, ds1name) == 0){
        FATAL_EXIT( "ds1 slot %i is already loaded (%s)", ds1_idx, glb_ds1[ds1_idx].name);
    }

    // take file name without path
    x = strlen(ds1name) - 1;
    // ∑¥œÚΩ¯––, æÕ «Œ™¡À»°≥ˆ xxx.xx∏Ò ΩµƒŒƒº˛√˚
    // Œ“≤¡, ƒ«ds1Œƒº˛æÕ÷ªƒ‹∫Õø…÷¥––Œƒº˛‘⁄“ª∆¡À
    while ((x >= 0) && (ds1name[x] != '\\') && (ds1name[x] != '/') && (ds1name[x] != ':')){
        x--;
    }
    if (x == 0){
        strcpy(glb_ds1[ds1_idx].filename, ds1name);
    }else{
        strcpy(glb_ds1[ds1_idx].filename, ds1name + x + 1);
    }
    strcpy(glb_ds1[ds1_idx].name, ds1name);

    // initialise max number of objects
    // 100
    // ◊˜’ﬂ∞—’‚¿‡max∂º¥Ê¥¢µΩ±‰¡øƒ⁄≤ø¡À
    glb_ds1[ds1_idx].current_obj_max = OBJ_MAX_START;

    // drawing_orderƒ·¬Í «∏ˆ…Ò¬Ì∂´Œ˜∞°??????????????????????
    //’‚¿Ô“ª÷±ø¥≤ª∂Æ∞°”–ƒæ”–∞°!!!!!!!!!!!!!!!!!!!!!!
    size = glb_ds1[ds1_idx].current_obj_max * sizeof(int);
    glb_ds1[ds1_idx].drawing_order = (int *)calloc(glb_ds1[ds1_idx].current_obj_max, sizeof(int));
    if(glb_ds1[ds1_idx].drawing_order == NULL){
        FATAL_EXIT("not enough mem (%i bytes) for glb_ds1[].drawing_order of %s\n", size, ds1name);
    }

    // obj
    size = glb_ds1[ds1_idx].current_obj_max * sizeof(OBJ_S);
    glb_ds1[ds1_idx].obj = (OBJ_S *) calloc(glb_ds1[ds1_idx].current_obj_max, sizeof(OBJ_S));
    if (glb_ds1[ds1_idx].obj == NULL){
        FATAL_EXIT("not enough mem (%i bytes) for glb_ds1[].obj of %s\n", size, ds1name);
    }

    // obj_undo
    glb_ds1[ds1_idx].obj_undo = (OBJ_S *)calloc(glb_ds1[ds1_idx].current_obj_max, sizeof(OBJ_S));
    if (glb_ds1[ds1_idx].obj_undo == NULL){
        FATAL_EXIT("not enough mem (%i bytes) for glb_ds1[].obj_undo of %s\n", size, ds1name);
    }

    // layers mask
    for (x=0; x < WALL_MAX_LAYER; x++){
        glb_ds1[ds1_idx].wall_layer_mask[x] = 1;
    }

    for (x=0; x < FLOOR_MAX_LAYER; x++){
        glb_ds1[ds1_idx].floor_layer_mask[x] = 1;
    }

    for (x=0; x < SHADOW_MAX_LAYER; x++){
        glb_ds1[ds1_idx].shadow_layer_mask[x] = 3; // transparent is default
    }

    glb_ds1[ds1_idx].objects_layer_mask    = OL_NONE;
    glb_ds1[ds1_idx].paths_layer_mask      = 1;
    glb_ds1[ds1_idx].walkable_layer_mask   = 0;
    glb_ds1[ds1_idx].subtile_help_display  = 1;
    glb_ds1[ds1_idx].animations_layer_mask = 1;
    glb_ds1[ds1_idx].special_layer_mask    = 1;

    // load from disk into memory
    //∂¡»Î“ª∏ˆ.ds1
    in = fopen(ds1name, "rb");
    if(in == NULL){
        FATAL_EXIT("can't open %s\n", ds1name);
    }
    fseek(in, 0, SEEK_END);
    ds1_len = ftell(in);
    fseek(in, 0, SEEK_SET);
    ds1_buff = (void *) malloc(ds1_len);
    if(ds1_buff == NULL){
        fclose(in);
        FATAL_EXIT("not enough mem (%i bytes) for %s\n", ds1_len, ds1name);
    }
    fread(ds1_buff, ds1_len, 1, in);
    fclose(in);

    // inits
    w_num = 0; // # of wall & orientation layers
    f_num = 0; // # of floor layer
    s_num = 1; // # of shadow layer, always here
    t_num = 0; // # of tag layer
    ptr   = (long *)ds1_buff;


    //“‘œ¬ «ds1µƒ ˝æ›Ω·ππ
    //typedef struct DS1_S
    //{
    //   char          dt1_idx[DT1_IN_DS1_MAX];
    //   int           dt1_mask[DT1_IN_DS1_MAX];
    //   int           txt_act;
    //   BLOCK_TABLE_S * block_table;
    //   int           bt_num;
    //   UBYTE         wall_layer_mask[WALL_MAX_LAYER];
    //   UBYTE         floor_layer_mask[FLOOR_MAX_LAYER];
    //   char          shadow_layer_mask[SHADOW_MAX_LAYER];
    //   OL_ENUM       objects_layer_mask;
    //   UBYTE         paths_layer_mask;
    //   UBYTE         walkable_layer_mask;
    //   UBYTE         animations_layer_mask;
    //   UBYTE         special_layer_mask;
    //   int           subtile_help_display;
    //   char          name[256];    // long filename with paths
    //   char          filename[50]; // short filename
    //   UNDO_S        undo;
    //
    //   // from file
    //   long          version;
    //   long          tag_type;
    //   long          width;    // from file, +1
    //   long          height;   // from file, +1
    //   long          act;      // from file, +1
    //
    //   // files in the ds1 (not used by the game)
    //   long          file_num;
    //   char          * file_buff;
    //   int           file_len;
    //   
    //   // floors
    //   CELL_F_S      * floor_buff,   // buffer for all floor layers
    //                 * floor_buff2;  // 2nd buffer, for copy/paste
    //   int           floor_buff_len; // sizeof the floor buffer (in bytes)
    //   int           floor_num;      // # of layers in floor buffer
    //   int           floor_line;     // width * floor_num
    //   int           floor_len;      // floor_line * height
    //   
    //   // shadow
    //   CELL_S_S      * shadow_buff,   // buffer for all shadow layers
    //                 * shadow_buff2;  // 2nd buffer, for copy/paste
    //   int           shadow_buff_len; // sizeof the shadow buffer (in bytes)
    //   int           shadow_num;      // # of layers in shadow buffer
    //   int           shadow_line;     // width * shadow_num
    //   int           shadow_len;      // shadow_line * height
    //   
    //   // walls
    //   CELL_W_S      * wall_buff,    // buffer for all wall layers
    //                 * wall_buff2;   // 2nd buffer, for copy/paste
    //   int           wall_buff_len;  // sizeof the wall buffer (in bytes)
    //   int           wall_num;       // # of layers in wall buffer
    //   int           wall_line;      // width * wall_num
    //   int           wall_len;       // wall_line * height
    //
    //   // tag
    //   CELL_T_S      * tag_buff,   // buffer for all unk layers
    //                 * tag_buff2;  // 2nd buffer, for copy/paste
    //   int           tag_buff_len; // sizeof the unk buffer (in bytes)
    //   int           tag_num;      // # of layers in unk buffer
    //   int           tag_line;     // width * unk_num
    //   int           tag_len;      // unk_line * height
    //
    //   // groups for tag layer
    //   long          group_num;
    //   int           group_size;
    //   GROUP_S       * group;
    //
    //   // internal
    //   ZOOM_E        cur_zoom;
    //   int           tile_w;
    //   int           tile_h;
    //   int           height_mul;
    //   int           height_div;
    //   SCROLL_S      cur_scroll;
    //
    //   // screen position and size for this ds1
    //   WIN_PREVIEW_S own_wpreview;
    //   
    //   // objects and npc paths (paths are in obj struct)
    //   int           * drawing_order;
    //   OBJ_S         * obj;
    //   OBJ_S         * obj_undo;
    //   long          obj_num;
    //   long          obj_num_undo;
    //   int           can_undo_obj;
    //   int           draw_edit_obj; // edit Type-Id of objects, FALSE / TRUE
    //   WIN_EDT_OBJ_S win_edt_obj;
    //
    //   // current animated floor frame
    //   int           cur_anim_floor_frame;
    //
    //   // path editing window of this ds1
    //   PATH_EDIT_WIN_S path_edit_win;
    //
    //   // save count
    //   UDWORD save_count;
    //
    //   // current number of objects
    //   long current_obj_max;
    //} DS1_S;
    //
    //


    // copy datas from buffer into ds1 struct :
    // Œ“≤¡.. ÷π§Ω‚Œˆ∞°
    // ’‚¿Ô ÷π§Ω‚Œˆµƒ‘≠“Ú÷˜“™ «”–∏˜÷÷µƒ∞Ê±æ≤Ó±
    //  ˝æ›Ω·ππ≤ªÃ´“ª÷¬

    // version
    glb_ds1[ds1_idx].version = *ptr;
    ptr++;

    // widht
	// width ∫Õheight∂ºº”¡À1, Œ™ ≤¬
    glb_ds1[ds1_idx].width = (* ptr) + 1;
    ptr++;

    // height
    glb_ds1[ds1_idx].height = (* ptr) + 1;
    ptr++;

    // will we use new size ?
    if ((new_width <= 0) || (new_height <= 0))
    {
        new_width  = glb_ds1[ds1_idx].width;
        new_height = glb_ds1[ds1_idx].height;
    }

    // act
	// act1µΩµ◊ «∏ˆ…Ò¬Ì“‚Àº
    glb_ds1[ds1_idx].act = 1;
    //Œ“µ˜ ‘µƒ ±∫Úversion «18¡À
    if(glb_ds1[ds1_idx].version >= 8){
        glb_ds1[ds1_idx].act = (* ptr) + 1;
        ptr++;
        if (glb_ds1[ds1_idx].act > 5){
            // “≤æÕ «Àµ..ACT¥Û”⁄5µƒ∂ºπÈ”⁄5¡À
            // ACT6’‚–© «¥Ê‘⁄µƒ, ÷ª «∆¡±Œ¡À?
            glb_ds1[ds1_idx].act = 5;
        }
    }

    // tag_type
    glb_ds1[ds1_idx].tag_type = 0;
    if(glb_ds1[ds1_idx].version >= 10){
        glb_ds1[ds1_idx].tag_type = *ptr;
        ptr++;

        // adjust eventually the # of tag layer
        if ((glb_ds1[ds1_idx].tag_type == 1) || (glb_ds1[ds1_idx].tag_type == 2)){
            t_num = 1;
        }
    }

    // debug
    printf("\nversion         : %li\n", glb_ds1[ds1_idx].version);
    printf("width           : %li\n", glb_ds1[ds1_idx].width);
    printf("height          : %li\n", glb_ds1[ds1_idx].height);
    printf("act             : %li\n", glb_ds1[ds1_idx].act);
    printf("tag_type        : %li\n", glb_ds1[ds1_idx].tag_type);

    // filenames
    glb_ds1[ds1_idx].file_num = 0;
    if(glb_ds1[ds1_idx].version >= 3){

        glb_ds1[ds1_idx].file_num = * ptr;
        ptr++;
        n = 0;
        printf("filenames       : %li\n", glb_ds1[ds1_idx].file_num);

        for(x=0; x<glb_ds1[ds1_idx].file_num; x++){
            // Œ“µ˜ ‘µƒ’‚∏ˆds1÷–file_num = 9
			// ∑÷± «:
					 // 1 : \d2\data\global\tiles\act4\mesa\floor.tg1
                     // 2 : \d2\data\global\tiles\act4\mesa\inv_wall.tg1
                     // 3 : \d2\data\global\tiles\act4\mesa\stairs.tg1
                     // 4 : \d2\data\global\tiles\act4\fort\foregate.tg1
                     // 5 : \d2\data\global\tiles\act4\fort\plaza.tg1
                     // 6 : \d2\data\global\tiles\act4\fort\interior.tg1
                     // 7 : \d2\data\global\tiles\act4\fort\exterior.tg1
                     // 8 : \d2\data\global\tiles\act1\barracks\warp.tg1
                     // 9 : \d2\data\global\tiles\act1\barracks\inviswal.tg1
            // √ª”–“∆∂Øptr ∂¯ «“∆∂Øœ¬±Ín
            // ”–∏ˆstrlen,À˘“‘±ÿ»ª√ø∏ˆŒƒº˛√˚∫Û”–“ª∏ˆ\0,≤ª»ª≤ªƒ‹π§◊˜
            // ’‚¿Ô÷ª «¥Ú”°¡À√ø∏ˆŒƒº˛√˚
            // ∂¡»Î.file_buff‘⁄∫Û√Ê
            printf("   %2i : %s\n", x + 1, ((char *) ptr) + n);
            n += (strlen( ((char *) ptr) + n) + 1);
        }

        glb_ds1[ds1_idx].file_buff = (void *) malloc(n);
        if(glb_ds1[ds1_idx].file_buff == NULL){
            free(ds1_buff);
            FATAL_EXIT("not enough mem (%i bytes) for files in the ds1\n", n);
        }
        glb_ds1[ds1_idx].file_len = n;
        //∂¡»ÎÀ˘”–Œƒº˛√˚
        //µΩ“ª∏ˆŒƒº˛ª∫≥Â«¯
        memcpy(glb_ds1[ds1_idx].file_buff, ptr, n);
        ptr = (long *) (((char *) ptr) + n);
    }
    else{
        printf("no filenames\n");
    }

    // skip 2 dwords ?
    if ((glb_ds1[ds1_idx].version >= 9) && (glb_ds1[ds1_idx].version <= 13)){
        ptr += 2;
    }

    // number of wall, floor and tag layers
    //tag layerµΩµ◊ «∏ˆ…Ò¬Ì∂´Œ˜
    if(glb_ds1[ds1_idx].version >= 4){
        // Ω¯»Î
        // number of wall (and orientation) layers
        w_num = * ptr;
        ptr++;

        // number of floor layers
        if(glb_ds1[ds1_idx].version >= 16){
            f_num = * ptr;
            ptr++;
        }else{
            f_num = 1; // default # of floor layer
        }
    }else{
        // in version < 4
        // # of layers hardcoded
        w_num = 1;
        f_num = 1;
        t_num = 1;
    }

    // which order ?
    if (glb_ds1[ds1_idx].version < 4)
    {
        lay_stream[0] =  1; // wall 1
        lay_stream[1] =  9; // floor 1
        lay_stream[2] =  5; // orientation 1
        lay_stream[3] = 12; // tag
        lay_stream[4] = 11; // shadow
        nb_layer = 5;
    }else{
        // ‘À––’‚¿Ô
        // lay_stream «∏ˆ…Ò¬Ì∂´Œ˜
        // ’‚¿Ô≥πµ◊√‘√£ø¥≤ª∂Æ
        // ◊Ó∫Û…˙≥…µƒ:
        // lay_stream[]µƒ÷µ»Áœ¬:
        // N±Ì æ√ª”–≥ı ºªØ
                    //    lay_stream[0]  = 1
                    //    lay_stream[1]  = 5
                    //    lay_stream[2]  = 2
                    //    lay_stream[3]  = 6
                    //    lay_stream[4]  = 3
                    //    lay_stream[5]  = 7
                    //    lay_stream[6]  = 4
                    //    lay_stream[7]  = 8
                    //    lay_stream[8]  = 9
                    //    lay_stream[9]  = 10
                    //    lay_stream[10] = 11
                    //    lay_stream[11] = N
                    //    lay_stream[12] = N
                    //    lay_stream[13] = N
        nb_layer = 0;
        for (x=0; x<w_num; x++) {
            lay_stream[nb_layer++] = 1 + x; // wall x
            lay_stream[nb_layer++] = 5 + x; // orientation x
        }
        for (x=0; x<f_num; x++){
            lay_stream[nb_layer++] = 9 + x; // floor x
        }
        if (s_num){
            lay_stream[nb_layer++] = 11;    // shadow
        }
        if (t_num){
            lay_stream[nb_layer++] = 12;    // tag
        }
    }
    //  ‰≥ˆ: layers          : (2 * 4 walls) + 2 floors + 1 shadow + 0 tag
    // Œ™ ≤√¥wall «2*4ƒÿ????
    printf("layers:  (2 * %li walls) + %li floors + %li shadow" " + %li tag\n", w_num, f_num, s_num, t_num);

    // layers num
    if(glb_config.always_max_layers){
        f_num = FLOOR_MAX_LAYER;
        w_num = WALL_MAX_LAYER;
    }
    glb_ds1[ds1_idx].floor_num  = f_num;    //2
    glb_ds1[ds1_idx].shadow_num = s_num;    //1
    glb_ds1[ds1_idx].tag_num    = t_num;    //0
    glb_ds1[ds1_idx].wall_num   = w_num;    //4

    //“‘œ¬ «Àƒ◊Èbuffer
    // floor buffer
    glb_ds1[ds1_idx].floor_line     = new_width * glb_ds1[ds1_idx].floor_num;
    glb_ds1[ds1_idx].floor_len      = glb_ds1[ds1_idx].floor_line * new_height;
    glb_ds1[ds1_idx].floor_buff_len = glb_ds1[ds1_idx].floor_len * sizeof(CELL_F_S);
    glb_ds1[ds1_idx].floor_buff     = (CELL_F_S *) malloc(glb_ds1[ds1_idx].floor_buff_len);
    if(glb_ds1[ds1_idx].floor_buff == NULL){
        free(ds1_buff);
        FATAL_EXIT("not enough mem (%i bytes) for floor buffer\n", glb_ds1[ds1_idx].floor_buff_len);
    }
    memset(glb_ds1[ds1_idx].floor_buff, 0, glb_ds1[ds1_idx].floor_buff_len);

    //’‚∏ˆ”¶∏√ «”√”⁄∏¥÷∆≤Ÿ◊˜µƒ..ø…“‘≤ªπ‹
    glb_ds1[ds1_idx].floor_buff2     = (CELL_F_S *) malloc(glb_ds1[ds1_idx].floor_buff_len);
    if(glb_ds1[ds1_idx].floor_buff2 == NULL){
        free(ds1_buff);
        FATAL_EXIT("not enough mem (%i bytes) for floor 2nd buffer\n", glb_ds1[ds1_idx].floor_buff_len);
    }
    memset(glb_ds1[ds1_idx].floor_buff2, 0, glb_ds1[ds1_idx].floor_buff_len);

    // shadow buffer
    glb_ds1[ds1_idx].shadow_line     = new_width * glb_ds1[ds1_idx].shadow_num;
    glb_ds1[ds1_idx].shadow_len      = glb_ds1[ds1_idx].shadow_line * new_height;
    glb_ds1[ds1_idx].shadow_buff_len = glb_ds1[ds1_idx].shadow_len * sizeof(CELL_S_S);
    glb_ds1[ds1_idx].shadow_buff     = (CELL_S_S *) malloc(glb_ds1[ds1_idx].shadow_buff_len);
    if(glb_ds1[ds1_idx].shadow_buff == NULL){
        free(ds1_buff);
        FATAL_EXIT("not enough mem (%i bytes) for shadow buffer\n", glb_ds1[ds1_idx].shadow_buff_len);
    }
    memset(glb_ds1[ds1_idx].shadow_buff, 0, glb_ds1[ds1_idx].shadow_buff_len);

    glb_ds1[ds1_idx].shadow_buff2     = (CELL_S_S *) malloc(glb_ds1[ds1_idx].shadow_buff_len);
    if (glb_ds1[ds1_idx].shadow_buff2 == NULL){
        free(ds1_buff);
        FATAL_EXIT("not enough mem (%i bytes) for shadow 2nd buffer\n", glb_ds1[ds1_idx].shadow_buff_len);
    }
    memset(glb_ds1[ds1_idx].shadow_buff2, 0, glb_ds1[ds1_idx].shadow_buff_len);

    // tag buffer
    glb_ds1[ds1_idx].tag_line     = new_width * glb_ds1[ds1_idx].tag_num;
    glb_ds1[ds1_idx].tag_len      = glb_ds1[ds1_idx].tag_line * new_height;
    glb_ds1[ds1_idx].tag_buff_len = glb_ds1[ds1_idx].tag_len * sizeof(CELL_T_S);
    glb_ds1[ds1_idx].tag_buff     = (CELL_T_S *) malloc(glb_ds1[ds1_idx].tag_buff_len);
    if (glb_ds1[ds1_idx].tag_buff == NULL) {
        free(ds1_buff);
        FATAL_EXIT("not enough mem (%i bytes) for tag buffer\n", glb_ds1[ds1_idx].tag_buff_len);
    }
    memset(glb_ds1[ds1_idx].tag_buff, 0, glb_ds1[ds1_idx].tag_buff_len);

    glb_ds1[ds1_idx].tag_buff2     = (CELL_T_S *) malloc(glb_ds1[ds1_idx].tag_buff_len);
    if(glb_ds1[ds1_idx].tag_buff2 == NULL){
        free(ds1_buff);
        FATAL_EXIT("not enough mem (%i bytes) for tag 2nd buffer\n", glb_ds1[ds1_idx].tag_buff_len);
    }
    memset(glb_ds1[ds1_idx].tag_buff2, 0, glb_ds1[ds1_idx].tag_buff_len);

    // wall buffer
    glb_ds1[ds1_idx].wall_line     = new_width * glb_ds1[ds1_idx].wall_num;
    glb_ds1[ds1_idx].wall_len      = glb_ds1[ds1_idx].wall_line * new_height;
    glb_ds1[ds1_idx].wall_buff_len = glb_ds1[ds1_idx].wall_len * sizeof(CELL_W_S);
    glb_ds1[ds1_idx].wall_buff     = (CELL_W_S *) malloc(glb_ds1[ds1_idx].wall_buff_len);
    if(glb_ds1[ds1_idx].wall_buff == NULL){
        free(ds1_buff);
        FATAL_EXIT("not enough mem (%i bytes) for wall buffer\n", glb_ds1[ds1_idx].wall_buff_len);
    }
    memset(glb_ds1[ds1_idx].wall_buff, 0, glb_ds1[ds1_idx].wall_buff_len);

    glb_ds1[ds1_idx].wall_buff2     = (CELL_W_S *) malloc(glb_ds1[ds1_idx].wall_buff_len);
    if(glb_ds1[ds1_idx].wall_buff2 == NULL){
        free(ds1_buff);
        FATAL_EXIT("not enough mem (%i bytes) for wall 2nd buffer\n", glb_ds1[ds1_idx].wall_buff_len);
    }
    memset(glb_ds1[ds1_idx].wall_buff2, 0, glb_ds1[ds1_idx].wall_buff_len);

    // read tiles of layers

    // set pointers
    for (x=0; x<FLOOR_MAX_LAYER; x++){
        f_ptr[x] = glb_ds1[ds1_idx].floor_buff + x;
    }

    for (x=0; x<SHADOW_MAX_LAYER; x++){
        s_ptr[x] = glb_ds1[ds1_idx].shadow_buff + x;
    }

    for (x=0; x<TAG_MAX_LAYER; x++){
        t_ptr[x] = glb_ds1[ds1_idx].tag_buff + x;
    }

    for (x=0; x<WALL_MAX_LAYER; x++){
        o_ptr[x] = w_ptr[x] = glb_ds1[ds1_idx].wall_buff + x;
    }

    bptr  = (UBYTE *) ptr;

    // ◊˜’ﬂƒ„≤ªæÕœÎÃÓ»Î“ªœ¬Ω·ππÃÂ√¥..Œ™ ≤√¥∏„µ√’‚√¥»√»À≤ª√˜∞◊
    for(n=0; n < nb_layer; n++){
        for(y=0; y < glb_ds1[ds1_idx].height; y++){
            for(x=0; x < glb_ds1[ds1_idx].width; x++){

                //			’‚ «lay_stream[]µƒ¿¥¿˙.. «÷±Ω”«ø––∏≥÷µµƒ
                //			 nb_layer = 0;
                //			 for (x=0; x<w_num; x++)
                //			 {
                //				 lay_stream[nb_layer++] = 1 + x; // wall x
                //				 lay_stream[nb_layer++] = 5 + x; // orientation x
                //			 }
                //			 for (x=0; x<f_num; x++)
                //				 lay_stream[nb_layer++] = 9 + x; // floor x
                //			 if (s_num)
                //				 lay_stream[nb_layer++] = 11;    // shadow
                //			 if (t_num)
                //				 lay_stream[nb_layer++] = 12;    // tag

                switch(lay_stream[n]){
                    //lay_stream[]µƒ÷µ»Áœ¬:
                    //    lay_stream[0]  = 1
                    //    lay_stream[1]  = 5
                    //    lay_stream[2]  = 2
                    //    lay_stream[3]  = 6
                    //    lay_stream[4]  = 3
                    //    lay_stream[5]  = 7
                    //    lay_stream[6]  = 4
                    //    lay_stream[7]  = 8
                    //    lay_stream[8]  = 9
                    //    lay_stream[9]  = 10
                    //    lay_stream[10] = 11

                    // walls
                    case  1:
                    case  2:
                    case  3:
                    case  4:
                        // ’‚¿Ôµƒ1234‘¥◊‘”⁄’‚“ªæ‰~
                        //			 for (x=0; x<w_num; x++)
                        //			 {
                        //				 lay_stream[nb_layer++] = 1 + x; // wall x
                        //				 lay_stream[nb_layer++] = 5 + x; // orientation x
                        //			 }
                        //
                        
                        // ptr = (long *)ds1_buff;
                        // ptr «÷∏œÚµƒds1÷±Ω”∂¡»°µΩƒ⁄¥Êµƒ ˝æ›
                        // √ø¥Œ÷∏œÚ“ªøÈcell_w_s, ◊ÓÕ‚≤„—≠ª∑“ª¥Œ∫Û, 4øÈcell_w_s∂ºÃÓ¬˙
                        // »ª∫Ûcell_w_sµƒ«∞4∏ˆ∑÷¡ø(»Áœ¬)¡¨–¯¥Ê∑≈, À˘“‘Õ®π˝bptr++¿¥∑√Œ µΩ≤¢ÃÓ»Î
                        // »ª∫Ûw_ptr += w_num, ◊¢“‚≤ª «w_ptr++
                        // ’‚ «“ÚŒ™w_ptr «“ª∏ˆ cell_w_s *w_ptr[N], “≤ø…“‘¿ÌΩ‚∫‹cell_w_s**±‰¡ø
                        // ∂¯√ø∏ˆtile”–w_num(4)∏ˆcell_w_s, ’‚¿Ô◊ÓÕ‚≤„—≠ª∑ «n, ƒ⁄≤„≤≈ «w∫Õh
                        // œ‡¡⁄¡Ω¥Œ÷Æº‰µƒwptr «Ã¯¡À“ª∏ˆtileµƒ, ’‚æÕ–Ë“™Ã¯w_num∏ˆcell_w_s, ≤≈ƒ‹µΩœ¬“ª∏ˆtileµƒcell_w_s
                        // »Áπ˚◊Óƒ⁄≤„—≠ª∑ «n, æÕ «wptr++
                        //
                        //        typedef struct CELL_W_S
                        //        {
                        //           UBYTE prop1;
                        //           UBYTE prop2;
                        //           UBYTE prop3;
                        //           UBYTE prop4;
                        //           ...
                        //         }CELL_W_S;
                        if((x < new_width) && (y < new_height)){
                            p                 =   lay_stream[n] - 1; // 1234->0123
                            w_ptr[p]->prop1   =   * bptr;
                            bptr++;
                            w_ptr[p]->prop2   =   * bptr;
                            bptr++;
                            w_ptr[p]->prop3   =   * bptr;
                            bptr++;
                            w_ptr[p]->prop4   =   * bptr;
                            bptr++;
                            w_ptr[p]         +=   w_num;
                        }
                        else{
                            bptr += 4;
                        }
                        break;

                        // orientations
                        // ø¥µΩ’‚¿Ô 2012.04.06
                        // orientation∫Õwall’‚–© «Õ¨“ªº∂±µƒ‘™Àÿ√¥?????
                        // Œ““ª÷±√ªø¥∂Æ orientation  «∏ˆ ≤√¥∂´Œ˜..≥ØœÚ???
                        //
                        // ’‚¿Ô5678“≤‘¥◊‘”⁄’‚“ªæ‰~
                        //			 for (x=0; x<w_num; x++)
                        //			 {
                        //				 lay_stream[nb_layer++] = 1 + x; // wall x
                        //				 lay_stream[nb_layer++] = 5 + x; // orientation x
                        //			 }
                    case  5:
                    case  6:
                    case  7:
                    case  8:
                        if((x < new_width) && (y < new_height)){
                            p = lay_stream[n] - 5;
                            if (glb_ds1[ds1_idx].version < 7){
                                o_ptr[p]->orientation = dir_lookup[* bptr];
                            }else{
                                //÷¥––µƒ’‚¿Ô...
                                o_ptr[p]->orientation = * bptr;
                            }
                            o_ptr[p] += w_num;
                        }
                        bptr += 4;
                        break;

                        // floors
                        // 9 10 «µ•∂¿µƒ∏≥÷µ
                    case  9:
                    case 10:
                        if((x < new_width) && (y < new_height)){
                            p               = lay_stream[n] - 9;
                            f_ptr[p]->prop1 = * bptr;
                            bptr++;
                            f_ptr[p]->prop2 = * bptr;
                            bptr++;
                            f_ptr[p]->prop3 = * bptr;
                            bptr++;
                            f_ptr[p]->prop4 = * bptr;
                            bptr++;
                            f_ptr[p]       += f_num;
                        }else{
                            bptr += 4;
                        }
                        break;

                        // shadow
                    case 11:
                        if((x < new_width) && (y < new_height)){
                            p               = lay_stream[n] - 11;
                            s_ptr[p]->prop1 = * bptr;
                            bptr++;
                            s_ptr[p]->prop2 = * bptr;
                            bptr++;
                            s_ptr[p]->prop3 = * bptr;
                            bptr++;
                            s_ptr[p]->prop4 = * bptr;
                            bptr++;
                            s_ptr[p]       += s_num;
                        }else{
                            bptr += 4;
                        }
                        break;

                        // tag
                    case 12:
                        if ((x < new_width) && (y < new_height))
                        {
                            p = lay_stream[n] - 12;
                            t_ptr[p]->num = (UDWORD) * ((UDWORD *) bptr);
                            t_ptr[p] += t_num;
                        }
                        bptr += 4;
                        break;
                }
            }

            // in case of bigger width
            p = new_width - glb_ds1[ds1_idx].width;
            //Œ“µ˜ ‘µƒ ±∫Ú, ’‚¿Ô√Ê¥”¿¥√ª”–÷¥––π˝~
            if(p > 0){
                switch (lay_stream[n]){
                    // walls
                    case  1:
                    case  2:
                    case  3:
                    case  4:
                        w_ptr[lay_stream[n] - 1] += p * w_num;
                        break;

                        // orientations
                    case  5:
                    case  6:
                    case  7:
                    case  8:
                        o_ptr[lay_stream[n] - 5] += p * w_num;
                        break;

                        // floors
                    case  9:
                    case 10:
                        f_ptr[lay_stream[n] - 9] += p * f_num;
                        break;

                        // shadow
                    case 11:
                        s_ptr[lay_stream[n] - 11] += p * s_num;
                        break;

                        // tag
                    case 12:
                        t_ptr[lay_stream[n] - 12] += p * t_num;
                        break;
                }
            }
        }
    }

    // update new size of the ds1
    glb_ds1[ds1_idx].width  = new_width;
    glb_ds1[ds1_idx].height = new_height;

    // now we're on the objects data
    ptr = (long *) bptr;

    glb_ds1[ds1_idx].obj_num = 0;
    if (glb_ds1[ds1_idx].version >= 2){
        glb_ds1[ds1_idx].obj_num = *ptr;
        ptr++;

        printf("objects         : %li\n", glb_ds1[ds1_idx].obj_num);

        if(glb_ds1[ds1_idx].obj_num > glb_ds1[ds1_idx].current_obj_max){
            // Ã´∂‡÷◊√¥∞Ï, ‘ˆº”“ª–©ƒ⁄¥Ê
            incr = 1 + glb_ds1[ds1_idx].obj_num - glb_ds1[ds1_idx].current_obj_max;
            if (misc_increase_ds1_objects_max(ds1_idx, incr) != 0){
                free(ds1_buff);
                FATAL_EXIT("too many objects (%ld), editor max is <%i>\n", glb_ds1[ds1_idx].obj_num, glb_ds1[ds1_idx].current_obj_max);
            }
        }

        current_valid_obj_idx = 0;
        // width∫Õheight∂º «“‘tileŒ™µ•Œª
        // ∂¯“ª∏ˆtile”–5∏ˆsubtile..À˘“‘’‚¿Ô’‚—˘
        max_subtile_width     = new_width * 5;
        max_subtile_height    = new_height * 5;
        for(n=0; n < glb_ds1[ds1_idx].obj_num; n++){
            //≥ı ºªØobjectµƒ∂º‘⁄’‚¿Ô..√≤À∆“ª∏ˆ“ª∏ˆµƒÃÓ–¥~
            glb_ds1[ds1_idx].obj[current_valid_obj_idx].type  = *ptr;
            ptr++;
            glb_ds1[ds1_idx].obj[current_valid_obj_idx].id    = *ptr;
            ptr++;
            x = glb_ds1[ds1_idx].obj[current_valid_obj_idx].x = *ptr;
            ptr++;
            y = glb_ds1[ds1_idx].obj[current_valid_obj_idx].y = *ptr;
            ptr++;

            // Œ“µƒµ˜ ‘, ≤‚ ‘x «»´æ÷ªπ «µ±«∞tileƒ⁄≤ø
            //  ‰≥ˆΩ·π˚»Áœ¬, ’‚∏ˆΩ·π˚»√Œ“”–µ„√‘√£
            // œ‘»ª≤ª «»´æ÷µƒ, “≤≤ª «œ‡∂‘subtileµƒ
            // µ´ «“≤≤ªœÒtileƒ⁄≤øµƒ∞°~ “ÚŒ™tileµƒ¥Û–°Œ™160*80, µ´ «’‚¿Ô”–( 152, 97 )≥ˆœ÷
            // ∆Êπ÷
                // x =   55, y =   33
                // x =   55, y =   47
                // x =  155, y =   97
                // x =  152, y =   97
                // x =  147, y =   72
                // x =  143, y =   72
                // x =  129, y =   84
                // x =  128, y =   79
                // x =  125, y =   68
                // x =  121, y =   67
                // x =   96, y =   25
                // x =   94, y =   21
                // x =   92, y =   43
                // x =   90, y =   39
                // x =   84, y =   46
                // x =   81, y =   46
                // x =   97, y =   63
                // x =   94, y =   64
                // x =  135, y =   90
                // x =  130, y =   45
                // x =   83, y =   58
                // x =  104, y =   52
                // x =  104, y =   39
                // x =   90, y =   18
                // x =   80, y =   34
                // x =   77, y =   40
                // x =   77, y =   50
                // x =   80, y =   55
                // x =   37, y =   25
                // x =   37, y =   35
                // x =   37, y =   45
                // x =   37, y =   55
                // x =   21, y =   28
                // x =   83, y =   23
                // x =   44, y =   19
                // x =   22, y =    7
                // x =   19, y =   40
                // x =   20, y =   20
                // x =   23, y =    7
                // x =   17, y =   55
                // x =   17, y =   45
                // x =   17, y =   35
                // x =   17, y =   25
                // x =   82, y =   62
                // x =   83, y =   66
                // x =   80, y =   43
                // x =   86, y =   40
                // x =  126, y =   72
                // x =  142, y =   68
            printf( "x = %4d, y = %4d\n", x, y);

            if (glb_ds1[ds1_idx].version > 5){
                // flags
                glb_ds1[ds1_idx].obj[current_valid_obj_idx].ds1_flags = * ptr;
                ptr++;
            }

            // integrity check (not done by the game I believe)
            if((x >= 0) && (x < max_subtile_width) && (y >= 0) && (y < max_subtile_height)){
                // some init for the paths of this object
                glb_ds1[ds1_idx].obj[current_valid_obj_idx].path_num = 0;
                glb_ds1[ds1_idx].obj[current_valid_obj_idx].desc_idx = -1;
                glb_ds1[ds1_idx].obj[current_valid_obj_idx].flags    = 0;

                glb_ds1[ds1_idx].obj[current_valid_obj_idx].frame_delta = rand()%256;

                // Œ“œ÷‘⁄Õª»ª√˜∞◊, ƒ—µ¿subtile÷∏µƒ «ƒ«÷÷¡‚–Œ∑ΩøÈ
                // subcell÷∏µƒ «’˝∑Ω–Œ–°øÈ?
                //
                // “≤æÕ «Àµtile∫Õcell «Õ¨º∂µƒ, ÷ª≤ªπ˝“ª∏ˆŒ™¡‚–Œ, “ª∏ˆŒ™’˝∑Ω–Œ∂¯“—?
                    //typedef struct OBJ_LABEL_S
                    //{
                    //   int rx, ry; // upper/left corner of the label, relative to the sub-cell
                    //               // (in pixels, at zoom of 1:1)
                    //   int w, h;   // width & height (pixels)
                    //   int x0, y0; // pixels position on screen
                    //   int flags;
                    //   // for moving
                    //   int old_rx;
                    //   int old_ry;
                    //} OBJ_LABEL_S;
                label = & glb_ds1[ds1_idx].obj[current_valid_obj_idx].label;
                label->rx = label->ry = label->w = label->h = label->flags = 0;

                editobj_make_obj_desc(ds1_idx, current_valid_obj_idx);
                current_valid_obj_idx++;
            }else{
                // don't use that object
                memset( & glb_ds1[ds1_idx].obj[current_valid_obj_idx], 0, sizeof(glb_ds1[ds1_idx].obj[current_valid_obj_idx]) );
            }
        }
    }else{
        printf("no objects\n");
    }

    // update the new number of objects in that ds1
    glb_ds1[ds1_idx].obj_num = current_valid_obj_idx;

    // warning :
    // In fact there can be less groups than expected
    // like in data\global\tiles\act1\outdoors\trees.ds1
    // where the file stop right after the last tile_x group data
    // leaving the other datas unknown (tile_y, width, height), and npc paths unknown.

    if ( (glb_ds1[ds1_idx].version >= 12)  && ((glb_ds1[ds1_idx].tag_type == 1) || (glb_ds1[ds1_idx].tag_type == 2))) {
        // Œ“µ˜ ‘µƒ ±∫Ú’‚“ªøÈ√ª”–±ª÷¥––
        // ÷˜“™ «“ÚŒ™tag_type=0
        // skip 1 dword ?
        if (glb_ds1[ds1_idx].version >= 18){
            ptr++;
        }

        glb_ds1[ds1_idx].group_num = n = * ptr;
        ptr++;

        printf("groups          : %d\n", n);

        // malloc
        glb_ds1[ds1_idx].group_size = size = n * sizeof(GROUP_S);
        glb_ds1[ds1_idx].group = (GROUP_S *) malloc(size);
        if(glb_ds1[ds1_idx].group == NULL){
            free(ds1_buff);
            FATAL_EXIT("not enough mem (%i bytes) for groups\n", size);
        }
        memset(glb_ds1[ds1_idx].group, 0, size);

        // fill it
        for(x=0; x<n; x++){
            if ((UDWORD) ptr < (((UDWORD) ds1_buff) + ds1_len)){
                glb_ds1[ds1_idx].group[x].tile_x = * ptr;
            }
            ptr++;
            if ((UDWORD) ptr < (((UDWORD) ds1_buff) + ds1_len)){
                glb_ds1[ds1_idx].group[x].tile_y = * ptr;
            }
            ptr++;
            if ((UDWORD) ptr < (((UDWORD) ds1_buff) + ds1_len)){
                glb_ds1[ds1_idx].group[x].width  = * ptr;
            }
            ptr++;
            if ((UDWORD) ptr < (((UDWORD) ds1_buff) + ds1_len)){
                glb_ds1[ds1_idx].group[x].height = * ptr;
            }
            ptr++;
            if(glb_ds1[ds1_idx].version >= 13){
                if((UDWORD) ptr < (((UDWORD) ds1_buff) + ds1_len)){
                    glb_ds1[ds1_idx].group[x].unk = * ptr;
                }
                ptr++;
            }
        }
    }else{
        printf("no groups\n");
    }

    // now we're on the npc's paths datas
    //Œ“∂‘path≤ª∏––À»§, À˘“‘√ªø¥“≤√ªµ˜’˚
    if (glb_ds1[ds1_idx].version >= 14) {
        if ((UDWORD) ptr < (((UDWORD) ds1_buff) + ds1_len))
            npc = * ptr;
        else
            npc = 0;
        ptr++;
        printf("npc paths       : %li\n", npc);
        for (n=0; n<npc; n++)
        {
            path = * ptr;
            ptr++;
            x = * ptr;
            ptr++;
            y = * ptr;
            ptr++;

            // search of which object are these paths datas
            o = last_o = nb = 0;
            done = FALSE;
            while (! done)
            {
                if (o < glb_ds1[ds1_idx].obj_num)
                {
                    if ((glb_ds1[ds1_idx].obj[o].x == x) && (glb_ds1[ds1_idx].obj[o].y == y))
                    {
                        last_o = o;
                        nb++;
                        if (nb >= 2)
                            done = TRUE;
                    }
                    o++; // next object
                }
                else
                    done = TRUE;
            }

            if (nb >= 2)
            {
                // there are a least 2 objects at the same coordinates

                // put a warning
                if (obj_path_warn_wrote != TRUE)
                {
                    obj_path_warn_wrote = TRUE;
                    printf("\n" "ds1_read() : WARNING, there are at least 2 objects at the same coordinates for some paths datas.\n");
                }
                printf("   * Removing %ld paths points of 1 object at coordinates (%ld, %ld)\n", path, x, y);
                fflush(stdout);

                // first, delete already assigned paths
                for (o=0; o < glb_ds1[ds1_idx].obj_num; o++)
                {
                    if ((glb_ds1[ds1_idx].obj[o].x == x) && (glb_ds1[ds1_idx].obj[o].y == y) &&
                            (glb_ds1[ds1_idx].obj[o].path_num != 0))
                    {
                        for (p=0; p < glb_ds1[ds1_idx].obj[o].path_num; p++)
                        {
                            glb_ds1[ds1_idx].obj[o].path[p].x      = 0;
                            glb_ds1[ds1_idx].obj[o].path[p].y      = 0;
                            glb_ds1[ds1_idx].obj[o].path[p].action = 0;
                            glb_ds1[ds1_idx].obj[o].path[p].flags  = 0;
                        }
                        glb_ds1[ds1_idx].obj[o].path_num = 0;
                    }
                }

                // now, skip these paths
                if (glb_ds1[ds1_idx].version >= 15)
                {
                    for (p=0; p < path; p++)
                        ptr += 3; // skip 3 dwords per path
                }
                else
                {
                    for (p=0; p < path; p++)
                        ptr += 2; // skip 2 dwords only per path, no 'action'
                }
            }
            else
            {
                // only 1 object at these coordinates for paths, it's ok
                o = last_o;

                // does these paths are pointing to a valid object position ?
                if (o >= glb_ds1[ds1_idx].obj_num)
                {
                    // nope
                    // the game don't alert the user, so why me ?
                    // but we'll skip them
                    if (glb_ds1[ds1_idx].version >= 15)
                    {
                        for (p=0; p < path; p++)
                            ptr += 3; // skip 3 dwords per path
                    }
                    else
                    {
                        for (p=0; p < path; p++)
                            ptr += 2; // skip 2 dwords only per path, no 'action'
                    }
                }
                else
                {
                    // yep, valid object

                    if (path > WINDS1EDIT_PATH_MAX)
                    {
                        free(ds1_buff);
                        FATAL_EXIT("object %d have too much paths (%ld), editor max is %ld\n", o, path, WINDS1EDIT_PATH_MAX);
                    }

                    // all ok for assigning the paths to this object
                    glb_ds1[ds1_idx].obj[o].path_num = path;
                    for (p=0; p < path; p++)
                    {
                        glb_ds1[ds1_idx].obj[o].path[p].x = * ptr;
                        ptr++;
                        glb_ds1[ds1_idx].obj[o].path[p].y = * ptr;
                        ptr++;
                        if (glb_ds1[ds1_idx].version >= 15)
                        {
                            glb_ds1[ds1_idx].obj[o].path[p].action = * ptr;
                            ptr++;
                        }
                        else
                            glb_ds1[ds1_idx].obj[o].path[p].action = 1; // default action
                    }
                }
            }
        }
        editobj_make_obj_label(ds1_idx);
    }else{
        printf("no npc paths\n");
    }

    // sort objects, for drawing purpose
    // ∫‹πÿº¸µƒ∫Ø ˝~
    editobj_set_drawing_order(ds1_idx);

    // internal
    glb_ds1[ds1_idx].cur_zoom           = ZM_11;
    glb_ds1[ds1_idx].tile_w             = 160;
    glb_ds1[ds1_idx].tile_h             = 80;
    glb_ds1[ds1_idx].height_mul         = 1;
    glb_ds1[ds1_idx].height_div         = 1;
    glb_ds1[ds1_idx].cur_scroll.keyb.x  = glb_config.scroll.keyb.x;
    glb_ds1[ds1_idx].cur_scroll.keyb.y  = glb_config.scroll.keyb.y;
    glb_ds1[ds1_idx].cur_scroll.mouse.x = glb_config.scroll.mouse.x;
    glb_ds1[ds1_idx].cur_scroll.mouse.y = glb_config.scroll.mouse.y;

    // center it
    cx = glb_ds1[ds1_idx].width/2 + 1;
    cy = glb_ds1[ds1_idx].height/2;
    dx = (cy * -glb_ds1[ds1_idx].tile_w / 2) + (cx * glb_ds1[ds1_idx].tile_w / 2);
    dy = (cy *  glb_ds1[ds1_idx].tile_h / 2) + (cx * glb_ds1[ds1_idx].tile_h / 2);

    glb_ds1[ds1_idx].own_wpreview.x0 = dx - glb_config.screen.width  / 2;
    glb_ds1[ds1_idx].own_wpreview.y0 = dy - glb_config.screen.height / 2;
    glb_ds1[ds1_idx].own_wpreview.w  = glb_config.screen.width;
    glb_ds1[ds1_idx].own_wpreview.h  = glb_config.screen.height;

    change_zoom(ds1_idx, ZM_14); // start with zoom of 1:4 in this ds1

    // some inits
    cptr   = glb_ds1[ds1_idx].file_buff;
    tile_x = tile_y = zoom = -1;

    // workspace (user environment)
    if(glb_config.workspace_enable){
        // for all filenames
        //’‚∏ˆÀ´≤„—≠ª∑√ªø¥√˜∞◊~
        for(x=0; x<glb_ds1[ds1_idx].file_num; x++){
            // Œ“µ˜ ‘µƒ ±∫Úfile_numŒ™9
            // for all workspace datas

            for(y=0; y < WRKSPC_MAX; y++){
                // check if it's one of our datas

                // for all characters
                o = 0;
                // cptr÷∏œÚds1Œƒº˛∂¡»Îƒ⁄¥Ê∫Ûµƒƒ⁄¥ÊÕ∑≤ø
                //
                // typedef struct WRKSPC_DATAS_S{
                //    char * id;
                // } WRKSPC_DATAS_S;
                // ø…º˚glb_wrkspc_datasæÕŒ™“ª∏ˆ◊÷∑˚¥Æ ˝◊È∂¯“—
                //
                //
                // ’‚∏ˆwileµƒ“‚ÀºŒ™: cptr≤ªµΩfile_bufµƒƒ©Œ≤
                //             ≤¢«“: glb_wrkspc_datas◊÷∑˚¥Æ ˝◊È≤øŒªµ±«∞≤ªµΩƒ≥∏ˆ◊÷∑˚¥Æƒ©Œ≤
                //             ≤¢«“: cptr÷∏œÚµƒ◊÷∑˚∫Õµ±«∞◊÷∑˚¥Æ÷–µƒ◊÷∑˚œ‡Õ¨
                while( (cptr[o] != 0x00) && (glb_wrkspc_datas[y].id[o] != 0x00) && (cptr[o] == glb_wrkspc_datas[y].id[o]) ){
                    // continue on next character
                    o++;
                }
                if((glb_wrkspc_datas[y].id[o] == 0x00) && (cptr[o]== '=')){
                    // this is our data, read its value
                    // »Áπ˚µ±«∞glb_wrkspc_datasµΩΩ·Œ≤, «“cptr÷∏œÚ"="
                    o++;
                    if(cptr[o] != 0x00){
                        switch(y){
                            case WRKSPC_TILE_X:
                                sscanf(cptr + o, "%li", & tile_x);
                                break;
                            case WRKSPC_TILE_Y:
                                sscanf(cptr + o, "%li", & tile_y);
                                break;
                            case WRKSPC_ZOOM:
                                sscanf(cptr + o, "%li", & zoom);
                                break;
                            case WRKSPC_VERSION:
                                // just ignore it
                                break;
                            case WRKSPC_SAVE_COUNT:
                                sscanf(cptr + o, "%lu", & glb_ds1[ds1_idx].save_count);
                                break;
                        }
                    }
                }
            }

            // next filename
            cptr += (strlen(cptr) + 1);
        }

        // update ds1 values with workspace datas
        if(zoom != -1){
            change_zoom(ds1_idx, zoom);
        }
        if((tile_x != -1) && (tile_y != -1)){
            if(tile_x < 0){
                tile_x = 0;
            }
            if(tile_x >= glb_ds1[ds1_idx].width){
                tile_x = glb_ds1[ds1_idx].width - 1;
            }
            if(tile_y < 0){
                tile_y = 0;
            }
            if (tile_y >= glb_ds1[ds1_idx].height){
                tile_y = glb_ds1[ds1_idx].height - 1;
            }

            tile_x++;
            dx = (tile_y * -glb_ds1[ds1_idx].tile_w / 2) + (tile_x * glb_ds1[ds1_idx].tile_w / 2);
            dy = (tile_y *  glb_ds1[ds1_idx].tile_h / 2) + (tile_x * glb_ds1[ds1_idx].tile_h / 2);
            tile_x--;

            if(ds1_idx == 0){
                glb_ds1edit.win_preview.x0 = dx - glb_ds1edit.win_preview.w / 2;
                glb_ds1edit.win_preview.y0 = dy - glb_ds1edit.win_preview.h / 2;
            }
            glb_ds1[ds1_idx].own_wpreview.x0 = dx - glb_ds1edit.win_preview.w / 2;
            glb_ds1[ds1_idx].own_wpreview.y0 = dy - glb_ds1edit.win_preview.h / 2;
            glb_ds1[ds1_idx].own_wpreview.w  = glb_ds1edit.win_preview.w;
            glb_ds1[ds1_idx].own_wpreview.h  = glb_ds1edit.win_preview.h;
        }
    }

    // end, some last init
    free(ds1_buff);
    strncpy(glb_ds1[ds1_idx].undo.tag, "UNDO", sizeof(glb_ds1[ds1_idx].undo.tag));
    glb_ds1[ds1_idx].undo.cur_buf_num = -1;
    glb_ds1[ds1_idx].path_edit_win.obj_idx = -1;

    DEBUG_MESSAGE("ds1_read(\"%s\"):out\n", ds1name);
    return 0;
}
#include "structs.h"
#include "error.h"
#include "ds1save.h"
#include "wpreview.h"


// ==========================================================================
// as expected, save the ds1
//    if is_tmp_file == TRUE, will save a file "*.tmp", else "*-nnn.ds1"
void ds1_save(int ds1_idx, int is_tmp_file)
{
   CELL_W_S * w_ptr;
   CELL_S_S * s_ptr;
   CELL_F_S * f_ptr;
   CELL_T_S * t_ptr;
   int      i=0, x, y, t, cur_o=0, p, used, flen;
   FILE     * out;
   long     n, npc = 0, file_count,
            save_wall_num, save_floor_num;
   char     tmp[512], tmp_name[256], * cptr;
   int      ax, ay, cx, cy, is_data;


   // if no ds1 here, don't process it
   if (strlen(glb_ds1[ds1_idx].name) == 0)
      return;

   // file must have an extension
   strcpy(tmp, glb_ds1[ds1_idx].name);
   if (strlen(tmp) < 4) {
       FATAL_EXIT("ds1save(), glb_ds1[%i].ds1_name < 4 chars : \"%s\" (is_tmp_file = %i)", ds1_idx, glb_ds1[ds1_idx].name, is_tmp_file);
   }

   // set the .TMP or .DS1 extension
   tmp[strlen(tmp)-4] = 0;
   if (is_tmp_file)
   {
      // save a ds1 with the extension .tmp
      sprintf(tmp_name, "%s.tmp", tmp);
      if (file_exists(tmp_name, -1, NULL))
         remove(tmp_name);
   }
   else
   {
      // save a ds1 with the extension .ds1
      // 1st, rename the current .ds1 to an incremental name (for backup)

      // find the 1st free slot
      sprintf(tmp_name, "%s-%03i.ds1", tmp, i);
      while (file_exists(tmp_name, -1, NULL))
      {
         i++;
         sprintf(tmp_name, "%s-%03i.ds1", tmp, i);
      }

      // rename the original ds1 to that incremental name
      if (rename(glb_ds1[ds1_idx].name, tmp_name)) {
          FATAL_EXIT( "ds1save(), couldn't rename %s to %s", glb_ds1[ds1_idx].name, tmp_name);
      }

      // then, we can save the ds1
      strcpy(tmp_name, glb_ds1[ds1_idx].name);
   }

   // save the ds1, either with a .tmp or a .ds1 extension
   out = fopen(tmp_name, "wb");
   if (out == NULL) {
       FATAL_EXIT("ds1save(), can't write %s", tmp_name);
   }

   // version
   n = 18;
   fwrite(& n, 4, 1, out);

   // width
   n = glb_ds1[ds1_idx].width - 1;
   fwrite(& n, 4, 1, out);
   
   // height
   n = glb_ds1[ds1_idx].height - 1;
   fwrite(& n, 4, 1, out);
   
   // act
   n = glb_ds1[ds1_idx].act - 1;
   fwrite(& n, 4, 1, out);
   
   // tag type
   fwrite(& glb_ds1[ds1_idx].tag_type, 4, 1, out);

   // filenames

   // count how many filenames (not workspace datas)
   file_count = 0;
   cptr = glb_ds1[ds1_idx].file_buff;
   for (i=0; i < glb_ds1[ds1_idx].file_num; i++)
   {
      flen = strlen(cptr) + 1;
      is_data = FALSE;
      // for all workspace datas
      for(y=0; y < WRKSPC_MAX; y++)
      {
         // check if it's one of our datas

         // for all characters
         x = 0;
         while ( (cptr[x] != 0x00) &&
                 (glb_wrkspc_datas[y].id[x] != 0x00) &&
                 (cptr[x] == glb_wrkspc_datas[y].id[x])
               )
         {
            // continue on next character
            x++;
         }
         if ((glb_wrkspc_datas[y].id[x] == 0x00) && (cptr[x]== '='))
         {
            // this is our data, don't count it
            is_data = TRUE;
            break;
         }
      }
      if (is_data == FALSE)
            file_count++;
      // next filename
      cptr += flen;
   }
   if (glb_config.workspace_enable)
      file_count += WRKSPC_MAX;
   fwrite(& file_count, 4, 1, out);

   // write filenames (not workspace datas)
   cptr = glb_ds1[ds1_idx].file_buff;
   for (i=0; i < glb_ds1[ds1_idx].file_num; i++)
   {
      flen = strlen(cptr) + 1;
      is_data = FALSE;
      // for all workspace datas
      for(y=0; y < WRKSPC_MAX; y++)
      {
         // check if it's one of our datas

         // for all characters
         x = 0;
         while ( (cptr[x] != 0x00) &&
                 (glb_wrkspc_datas[y].id[x] != 0x00) &&
                 (cptr[x] == glb_wrkspc_datas[y].id[x])
               )
         {
            // continue on next character
            x++;
         }
         if ((glb_wrkspc_datas[y].id[x] == 0x00) && (cptr[x]== '='))
         {
            // this is our data, skip it
            is_data = TRUE;
            break;
         }
      }
      if (is_data == FALSE)
         fwrite(cptr, flen, 1, out);

      // next filename
      cptr += flen;
   }

   if (glb_config.workspace_enable)
   {
      // write all workspace datas
      ax = glb_ds1edit.win_preview.x0 + glb_ds1edit.win_preview.w / 2;
      ay = glb_ds1edit.win_preview.y0 + glb_ds1edit.win_preview.h / 2;
      coord_to_tile(ds1_idx, ax, ay, & cx, & cy);
      if ( (glb_ds1edit.mode == MOD_O) ||
           (glb_ds1edit.mode == MOD_P) ||
           (glb_ds1edit.mode == MOD_L) )
      {
         cx /= 5;
         cy /= 5;
      }
      for (i=0; i < WRKSPC_MAX; i++)
      {
         switch (i)
         {
            case WRKSPC_TILE_X :
               sprintf(tmp, "%s=%i", glb_wrkspc_datas[i].id, cx);
               fwrite(tmp, strlen(tmp) + 1, 1, out);
               break;

            case WRKSPC_TILE_Y :
               sprintf(tmp, "%s=%i", glb_wrkspc_datas[i].id, cy);
               fwrite(tmp, strlen(tmp) + 1, 1, out);
               break;

            case WRKSPC_ZOOM :
               sprintf(tmp, "%s=%i", glb_wrkspc_datas[i].id, glb_ds1[ds1_idx].cur_zoom);
               fwrite(tmp, strlen(tmp) + 1, 1, out);
               break;

            case WRKSPC_VERSION :
               sprintf(tmp, "%s=Build YYYY/MM/DD", glb_wrkspc_datas[i].id);
               fwrite(tmp, strlen(tmp) + 1, 1, out);
               break;

            case WRKSPC_SAVE_COUNT :
               glb_ds1[ds1_idx].save_count++;
               sprintf(tmp, "%s=%lu", glb_wrkspc_datas[i].id, glb_ds1[ds1_idx].save_count);
               fwrite(tmp, strlen(tmp) + 1, 1, out);
               break;
         }
      }
   }

   // minimize ds1 size
   save_wall_num  = glb_ds1[ds1_idx].wall_num;
   save_floor_num = glb_ds1[ds1_idx].floor_num;
   if (glb_config.minimize_ds1 == TRUE)
   {
      // how many wall layers are really used ?
      // (keep a minimum of 1)
      for (i = save_wall_num - 1; i >= 1; i--)
      {
         used = FALSE;

         for (y=0; y < glb_ds1[ds1_idx].height; y++)
         {
            for (x=0; x < glb_ds1[ds1_idx].width; x++)
            {
               t = (y * glb_ds1[ds1_idx].wall_line) + (x * glb_ds1[ds1_idx].wall_num);
               w_ptr = glb_ds1[ds1_idx].wall_buff + t + i;
               if ((w_ptr->prop1 | w_ptr->prop2 | w_ptr->prop3 | w_ptr->prop4 |
                    w_ptr->orientation) != 0)
               {
                  used = TRUE;
                  break;
               }
            }
            if (used)
               break;
         }
         if (used)
            break;
         else
            save_wall_num--;
      }

      // how many floor layers are really used ?
      // (keep a minimum of 1)
      for (i = save_floor_num - 1; i >= 1; i--)
      {
         used = FALSE;

         for (y=0; y < glb_ds1[ds1_idx].height; y++)
         {
            for (x=0; x < glb_ds1[ds1_idx].width; x++)
            {
               t = (y * glb_ds1[ds1_idx].floor_line) + (x * glb_ds1[ds1_idx].floor_num);
               f_ptr = glb_ds1[ds1_idx].floor_buff + t + i;
               if ((f_ptr->prop1 | f_ptr->prop2 | f_ptr->prop3 | f_ptr->prop4) != 0)
               {
                  used = TRUE;
                  break;
               }
            }
            if (used)
               break;
         }
         if (used)
            break;
         else
            save_floor_num--;
      }
   }


   // wall num
   fwrite(& save_wall_num,  4, 1, out);

   // floor num
   fwrite(& save_floor_num, 4, 1, out);

   // walls
   for (i=0; i < save_wall_num; i++)
   {
      // props layer
      for (y=0; y < glb_ds1[ds1_idx].height; y++)
      {
         for (x=0; x < glb_ds1[ds1_idx].width; x++)
         {
            t = (y * glb_ds1[ds1_idx].wall_line) + (x * glb_ds1[ds1_idx].wall_num);
            w_ptr = glb_ds1[ds1_idx].wall_buff + t + i;
            fputc(w_ptr->prop1, out);
            fputc(w_ptr->prop2, out);
            fputc(w_ptr->prop3, out);
            fputc(w_ptr->prop4, out);
         }
      }

      // orientation layer
      for (y=0; y < glb_ds1[ds1_idx].height; y++)
      {
         for (x=0; x < glb_ds1[ds1_idx].width; x++)
         {
            t = (y * glb_ds1[ds1_idx].wall_line) + (x * glb_ds1[ds1_idx].wall_num);
            w_ptr = glb_ds1[ds1_idx].wall_buff + t + i;
            fputc(w_ptr->orientation, out);
            fputc(0, out);
            fputc(0, out);
            fputc(0, out);
         }
      }
   }

   // floors
   for (i=0; i < save_floor_num; i++)
   {
      // props layer
      for (y=0; y < glb_ds1[ds1_idx].height; y++)
      {
         for (x=0; x < glb_ds1[ds1_idx].width; x++)
         {
            t = (y * glb_ds1[ds1_idx].floor_line) + (x * glb_ds1[ds1_idx].floor_num);
            f_ptr = glb_ds1[ds1_idx].floor_buff + t + i;
            fputc(f_ptr->prop1, out);
            fputc(f_ptr->prop2, out);
            fputc(f_ptr->prop3, out);
            fputc(f_ptr->prop4, out);
         }
      }
   }

   // shadows
   for (i=0; i < glb_ds1[ds1_idx].shadow_num; i++)
   {
      // props layer
      for (y=0; y < glb_ds1[ds1_idx].height; y++)
      {
         for (x=0; x < glb_ds1[ds1_idx].width; x++)
         {
            t = (y * glb_ds1[ds1_idx].shadow_line) + (x * glb_ds1[ds1_idx].shadow_num);
            s_ptr = glb_ds1[ds1_idx].shadow_buff + t + i;
            fputc(s_ptr->prop1, out);
            fputc(s_ptr->prop2, out);
            fputc(s_ptr->prop3, out);
            fputc(s_ptr->prop4, out);
         }
      }
   }

   // optional tag layer
   if (glb_ds1[ds1_idx].tag_type)
   {
      for (i=0; i<glb_ds1[ds1_idx].tag_num; i++)
      {
         // props layer
         for (y=0; y < glb_ds1[ds1_idx].height; y++)
         {
            for (x=0; x < glb_ds1[ds1_idx].width; x++)
            {
               t = (y * glb_ds1[ds1_idx].tag_line) + (x * glb_ds1[ds1_idx].tag_num);
               t_ptr = glb_ds1[ds1_idx].tag_buff + t + i;
               fwrite( & t_ptr->num, 4, 1, out);
            }
         }
      }
   }

   // objects
   fwrite(&glb_ds1[ds1_idx].obj_num, 4, 1, out);
   for (i=0; i < glb_ds1[ds1_idx].obj_num; i++)
   {
      fwrite(&glb_ds1[ds1_idx].obj[i].type,      4, 1, out);
      fwrite(&glb_ds1[ds1_idx].obj[i].id,        4, 1, out);
      fwrite(&glb_ds1[ds1_idx].obj[i].x,         4, 1, out);
      fwrite(&glb_ds1[ds1_idx].obj[i].y,         4, 1, out);
      fwrite(&glb_ds1[ds1_idx].obj[i].ds1_flags, 4, 1, out);
      if (glb_ds1[ds1_idx].obj[i].path_num)
         npc++;
   }

   // optional groups
   if (glb_ds1[ds1_idx].tag_type)
   {
      // put a 0 dword
      n = 0;
      fwrite(&n, 4, 1, out);

      // # of groups
      fwrite(&glb_ds1[ds1_idx].group_num, 4, 1, out);

      // groups
      for (i=0; i < glb_ds1[ds1_idx].group_num; i++)
      {
         fwrite(&glb_ds1[ds1_idx].group[i].tile_x, 4, 1, out);
         fwrite(&glb_ds1[ds1_idx].group[i].tile_y, 4, 1, out);
         fwrite(&glb_ds1[ds1_idx].group[i].width,  4, 1, out);
         fwrite(&glb_ds1[ds1_idx].group[i].height, 4, 1, out);
         fwrite(&glb_ds1[ds1_idx].group[i].unk,    4, 1, out);
      }
   }

   // npc paths
   fwrite(&npc, 4, 1, out);
   for (i=0; i < npc; i++)
   {
      while ( ! glb_ds1[ds1_idx].obj[cur_o].path_num)
         cur_o++;
      fwrite(&glb_ds1[ds1_idx].obj[cur_o].path_num, 4, 1, out);
      fwrite(&glb_ds1[ds1_idx].obj[cur_o].x,        4, 1, out);
      fwrite(&glb_ds1[ds1_idx].obj[cur_o].y,        4, 1, out);
      for (p=0; p < glb_ds1[ds1_idx].obj[cur_o].path_num; p++)
      {
         fwrite(&glb_ds1[ds1_idx].obj[cur_o].path[p].x,      4, 1, out);
         fwrite(&glb_ds1[ds1_idx].obj[cur_o].path[p].y,      4, 1, out);
         fwrite(&glb_ds1[ds1_idx].obj[cur_o].path[p].action, 4, 1, out);
      }
      cur_o++;
   }

   // end
   fclose(out);
}
#include "structs.h"
#include "dt1_draw.h"


// ==========================================================================
// draw a 3d-isometric sub-tile
void draw_sub_tile_isometric (BITMAP * dst, int x0, int y0, UBYTE * data, int length)
{
   UBYTE * ptr = data;
   int   x, y=0, n,
         xjump[15] = {14, 12, 10, 8, 6, 4, 2, 0, 2, 4, 6, 8, 10, 12, 14},
         nbpix[15] = {4, 8, 12, 16, 20, 24, 28, 32, 28, 24, 20, 16, 12, 8, 4};

   // 3d-isometric subtile is 256 bytes, no more, no less
   if (length != 256)
      return;

   // draw
   while (length > 0)
   {
      x = xjump[y];
      n = nbpix[y];
      length -= n;
      while (n)
      {
         putpixel(dst, x0+x, y0+y, * ptr);
         ptr++;
         x++;
         n--;
      }
      y++;
   }
}


// ==========================================================================
// draw a normal sub-tile (can be transparent, so there are "jump" coded)
void draw_sub_tile_normal (BITMAP * dst, int x0, int y0, UBYTE * data,
                           int length)
{
   UBYTE * ptr = data, b1, b2;
   int   x=0, y=0;

   // draw
   while (length > 0)
   {
      b1 = * ptr;
      b2 = * (ptr + 1);
      ptr += 2;
      length -= 2;
      if (b1 || b2)
      {
         x += b1;
         length -= b2;
         while (b2)
         {
            putpixel(dst, x0+x, y0+y, * ptr);
            ptr++;
            x++;
            b2--;
         }
      }
      else
      {
         x = 0;
         y++;
      }
   }
}
#include <string.h>
#include "structs.h"
#include "error.h"
#include "dt1_draw.h"
#include "misc.h"
#include "mpqview.h"
#include "dt1misc.h"


// ==========================================================================
// check if this dt1 is already loaded (multiple ds1 can use the same dt1)
int dt1_already_loaded(char * dt1name, int * idx)
{
    int i;

    for (i=0; i<DT1_MAX; i++) {
        if (stricmp(glb_dt1[i].name, dt1name) == 0) {
            * idx = i;
            return TRUE;
        }
    }
    * idx = -1;
    return FALSE;
}


// ==========================================================================
// memory free of a dt1
int dt1_free(int i)
{
    BITMAP  * bmp_ptr;
    int     size = glb_dt1[i].buff_len + glb_dt1[i].bh_buff_len;
    int     z, b;


    if (strlen(glb_dt1[i].name) == 0)
        return 0;

    fprintf(stderr, "      . %s\n", glb_dt1[i].name);
    fflush(stderr);

    // bitmaps in all zoom format
    for (z=0; z<ZM_MAX; z++)
    {
        if (glb_dt1[i].block_zoom[z] != NULL)
        {
            for (b=0; b < glb_dt1[i].block_num; b++)
            {
                bmp_ptr = * (glb_dt1[i].block_zoom[z] + b);
                if (bmp_ptr != NULL)
                {
                    size += bmp_ptr->w * bmp_ptr->h + sizeof(BITMAP);
                    destroy_bitmap(bmp_ptr);
                }
            }
            size += glb_dt1[i].bz_size[z];
            free(glb_dt1[i].block_zoom[z]);
        }
    }

    // block headers of dt1
    if (glb_dt1[i].bh_buffer != NULL)
    {
        free(glb_dt1[i].bh_buffer);
    }

    // dt1 buffer
    if (glb_dt1[i].buffer != NULL)
    {
        free(glb_dt1[i].buffer);
    }

    // end
    memset(& glb_dt1[i], 0, sizeof(DT1_S));
    return size;
}


// ==========================================================================
// a ds1 don't need to use a dt1 anymore
// if the dt1 is still use by another ds1, no change (except the usage count)
// else, free it
int dt1_del(int i)
{
    if ( (i < 0) || (i >= DT1_MAX))
        return 2;

    if (glb_dt1[i].ds1_usage <= 0)
        return 1;

    glb_dt1[i].ds1_usage--;
    if (glb_dt1[i].ds1_usage == 0)
        dt1_free(i);
    return 0;
}


// ==========================================================================
// fill the block header data of a dt1 with the data from the file
void dt1_bh_update(int i)
{
    BLOCK_S * bh_ptr = glb_dt1[i].bh_buffer;
    UBYTE   * ptr;
    int     b, t, idxtable[25] = {20, 21, 22, 23, 24,
        15, 16, 17, 18, 19,
        10, 11, 12, 13, 14,
        5,  6,  7,  8,  9,
        0,  1,  2,  3,  4};

    ptr = (UBYTE *) glb_dt1[i].buffer + glb_dt1[i].bh_start;
    for (b=0; b < glb_dt1[i].block_num; b++)
    {
        bh_ptr->direction    = * (long *)  ptr;
        bh_ptr->roof_y       = * (WORD *)  (ptr +  4);
        bh_ptr->sound        = * (UBYTE *) (ptr +  6);
        bh_ptr->animated     = * (UBYTE *) (ptr +  7);
        bh_ptr->size_y       = * (long *)  (ptr +  8);
        bh_ptr->size_x       = * (long *)  (ptr + 12);
        // skip 4 bytes : zeros1
        bh_ptr->orientation  = * (long *)  (ptr + 20);
        bh_ptr->main_index   = * (long *)  (ptr + 24);
        bh_ptr->sub_index    = * (long *)  (ptr + 28);
        bh_ptr->rarity       = * (long *)  (ptr + 32);
        // skip 4 bytes : unknown_a thru unknown_d
        for (t=0; t<25; t++)
            bh_ptr->sub_tiles_flags[idxtable[t]] = * (UBYTE *) (ptr + 40 + t);
        // skip 7 bytes : zeros2
        bh_ptr->tiles_ptr    = * (long *)  (ptr + 72);
        bh_ptr->tiles_length = * (long *)  (ptr + 76);
        bh_ptr->tiles_number = * (long *)  (ptr + 80);
        // skip 12 bytes : zeros3

        // next block header
        bh_ptr++;
        ptr += 96;
    }
}


// ==========================================================================
// fill the sub-tile structure with the right sub-header data from the file
void dt1_fill_subt(SUB_TILE_S * ptr, int i, long tiles_ptr, int s)
{
    UBYTE * st_ptr;

    st_ptr = (UBYTE *) glb_dt1[i].buffer + tiles_ptr + (20 * s);
    ptr->x_pos       = * (WORD *)  st_ptr;
    ptr->y_pos       = * (WORD *)  (st_ptr +  2);
    // skip 2 bytes : unknown1
    ptr->x_grid      = * (UBYTE *) (st_ptr +  6);
    ptr->y_grid      = * (UBYTE *) (st_ptr +  7);
    ptr->format      = * (WORD *)  (st_ptr +  8);
    ptr->length      = * (long *)  (st_ptr + 10);
    // skip 2 bytes : unknown2
    ptr->data_offset = * (long *)  ((UBYTE *)st_ptr + 16);
}


// ==========================================================================
// make the bitmap of 1 tile, for 1 zoom
void dt1_zoom(BITMAP * src, int i, int b, int z)
{
    BITMAP * dst;
    int    w = src->w, h = src->h, d=1;
    char   tmp_str[100];

    switch(z)
    {
        case ZM_11  : break;
        case ZM_12  : d =  2; break;
        case ZM_14  : d =  4; break;
        case ZM_18  : d =  8; break;
        case ZM_116 : d = 16; break;
    }
    w /= d;
    h /= d;
    dst = create_bitmap(w, h);
    if (dst == NULL)
    {
        FATAL_EXIT( "dt1_zoom(%i, %i, %i), can't make a bitmap of %i * %i pixels\n", i, b, z, w, h);
    }
    stretch_blit(src, dst, 0, 0, src->w, src->h, 0, 0, w, h);

    * (glb_dt1[i].block_zoom[z] + b) = dst;
}


// ==========================================================================
// make all bitmaps in all zoom of all tiles of 1 dt1
//‰ªéËøô‰∏™ÂáΩÊï∞Êù•Áúã:
//‰∏Ä‰∏™.dt1Êñá‰ª∂‰∏≠Êúâ‰∏™Â§ö‰∏™block,ÊØè‰∏™blockÊèèËø∞‰∫Ü‰∏Ä‰∏™tileÊàñËÄÖ‰∏Ä‰∏™Á´ãÁùÄÁöÑÂ¢ô‰ΩìÂçïÂÖÉ
//ÂèØËÉΩÂ∞±Âõ†‰∏∫Â¶ÇÊ≠§ÊâçÂØºËá¥‰∏çÊääblockÁõ¥Êé•Áß∞‰∏∫tile...(ÂùëÁàπÁöÑÂ¢ô‰Ωì...)
//ÁÑ∂ÂêéÊØè‰∏™block‰∏≠ÊúâÂ§ö‰∏™subtile,‰πüÂ∞±ÊòØÈÇ£ÁßçÂ∞èÊñπÊ†º
//Â¶ÇÊûúËØ•blockÊòØtile, ÂàôÊØè‰∏™sub-tile‰ºöËè±ÂΩ¢ÁªòÂà∂,Êü•Ë°®Â°´ÂÖ•
//Â¶ÇÊûúÊòØÂ¢ô‰Ωì..ÂàôÊØè‰∏™sub-tile‰ºöË∑≥Ë∑ÉÁªòÂà∂~(Á®ãÂ∫èÈáåÈù¢Êúâjump code~)
void dt1_all_zoom_make(int i)
{
    BLOCK_S       * b_ptr, * my_b_ptr; // pointers to current block header
    SUB_TILE_S    st_ptr;  // current sub-tile header
    BITMAP        * tmp_bmp, * sprite;
    int           b, w, h, s, x0, y0, length, y_add, z, mem_size;
    UBYTE         * data;
    WORD          format;
    long          orientation;
    char          tmp_str[100];
    int           t_mi, t_si, my_idx;

    b_ptr    = (BLOCK_S *) glb_dt1[i].bh_buffer;

    fprintf(stderr, "making zoom for glb_dt1[%i] (%s) ", i, glb_dt1[i].name);
    fflush(stderr);
    // get mem for table of pointers
    for (z=0; z<ZM_MAX; z++)
    {
        //‰∏Ä‰∏™blockÂ∞±ÊòØ‰∏Ä‰∏™tile???
        mem_size = sizeof(BITMAP *) * glb_dt1[i].block_num;
        glb_dt1[i].block_zoom[z] = (BITMAP **) malloc(mem_size);
        if (glb_dt1[i].block_zoom[z] == NULL) {
            FATAL_EXIT("dt1_all_zoom_make(%i), zoom %i, not enough mem for %i bytes\n", i, z, mem_size);
        }
        memset(glb_dt1[i].block_zoom[z], 0, mem_size);
        glb_dt1[i].bz_size[z] = mem_size;
    }

    // make the bitmaps
    for (b=0; b < glb_dt1[i].block_num; b++) // for each blocks of a dt1
    {
        //‰ªéËøôÈáåÊù•Áúã..Ë≤å‰ºº‰∏Ä‰∏™blockÂ∞±ÊòØ‰∏Ä‰∏™tile
        // get infos
        orientation = b_ptr->orientation;

        // prepare tmp bitmap size
        w = b_ptr->size_x;
        if ((orientation == 10) || (orientation == 11))
            w = 160; // set it to 160 because we'll draw infos over it later
        //Ëøô‰∏™Âú∞Êñπ...ÂõæÁâáÁöÑÈ´òÁõ¥Êé•ÊòØ‰∏™Ë¥üÂÄº...
        h = - b_ptr->size_y;

        // adjustment (which y line in the bitmap is the zero line ?)

        // by default, when orientation > 15 : lower wall
        y_add = 96;
        if ((orientation == 0) || (orientation == 15)) // floor or roof
        {
            if (b_ptr->size_y)
            {
                b_ptr->size_y = - 80;
                h = 80;
                y_add = 0;
            }
        }
        else if (orientation < 15) // upper wall, shadow, special
        {
            if (b_ptr->size_y)
            {
                b_ptr->size_y += 32;
                h -= 32;
                y_add = h;
            }
        }

        // anti-bug (for empty block)
        if ((w == 0) || (h == 0))
        {
            fprintf(stderr, "0");
            fflush(stderr);
            b_ptr ++;
            continue;
        }

        // normal block (non-empty)
        tmp_bmp = create_bitmap(w, h);
        if (tmp_bmp == NULL) {
            FATAL_EXIT("dt1_all_zoom_make(%i), can't make a bitmap of %i * %i pixels\n", i, w, h);
        }
        clear(tmp_bmp);

        // draw sub-tiles in this bitmap
        for (s=0; s < b_ptr->tiles_number; s++) // for each sub-tiles
        {
            //‰∏Ä‰∏™tileÁî±Â§ö‰∏™subtileÊûÑÊàêÁöÑ
            // get the sub-tile info
            dt1_fill_subt(& st_ptr, i, b_ptr->tiles_ptr, s);

            // get infos
            x0     = st_ptr.x_pos;
            y0     = y_add + st_ptr.y_pos;
            data   = (UBYTE *) ((UBYTE *)glb_dt1[i].buffer + b_ptr->tiles_ptr + st_ptr.data_offset);
            length = st_ptr.length;
            format = st_ptr.format;

            // draw the sub-tile
            if (format == 0x0001)
                //Ëøô‰∏™ÁîªÊ≥ïÊàëÂ∑≤ÁªèÁü•ÈÅì‰∫Ü
                //ÂèÇËßÅdt1 toolÁöÑËß£Êûê
                draw_sub_tile_isometric(tmp_bmp, x0, y0, data, length);
            else
                draw_sub_tile_normal(tmp_bmp, x0, y0, data, length);
        }

        // if a game's special tile, draw my own info over it
        if ( (glb_ds1edit.cmd_line.no_vis_debug == FALSE) &&
                (i != 0) && ((orientation == 10) || (orientation == 11))
           )
        {
            // get info
            t_mi     = b_ptr->main_index;
            t_si     = b_ptr->sub_index;
            my_b_ptr = (BLOCK_S *) glb_dt1[0].bh_buffer;

            // search same info in my dt1
            for (my_idx=0; my_idx < glb_dt1[0].block_num; my_idx++)
            {
                if ( (my_b_ptr[my_idx].orientation == orientation) &&
                        (my_b_ptr[my_idx].main_index  == t_mi) &&
                        (my_b_ptr[my_idx].sub_index   == t_si)
                   )
                {
                    // found it, draw that tile over the game's gfx
                    sprite = * (glb_dt1[0].block_zoom[ZM_11] + my_idx);
                    if (sprite != NULL)
                        draw_sprite(tmp_bmp, sprite, 0, tmp_bmp->h - sprite->h);

                    // stop the search
                    my_idx = glb_dt1[0].block_num;
                }
            }
        }

        // make zoom from the bitmap, for each zoom
        for (z=0; z<ZM_MAX; z++)
            dt1_zoom(tmp_bmp, i, b, z);

        // destroy tmp bitmap
        destroy_bitmap(tmp_bmp);

        // next block header
        b_ptr ++;
        fprintf(stderr, ".");
        fflush(stderr);
    }
    fprintf(stderr, "\n");
    fflush(stderr);
}


// ==========================================================================
// fill / make all the datas of 1 dt1
void dt1_struct_update(int i)
{
    void * ptr = glb_dt1[i].buffer;
    int  size;
    char tmp[100];

    if (ptr == NULL)
        return;
    //ÊàëÂãí‰∏™Êì¶Êì¶..Â•ΩÁõ¥Êé•....
    //ÂíåÈÇ£‰∏™dt1 toolÁöÑÊ∫êÁ†ÅÂØπÁÖßÁùÄÁúã
    glb_dt1[i].x1        = * (long *) ptr;
    glb_dt1[i].x2        = * (long *) ((UBYTE *)ptr + 4);
    glb_dt1[i].block_num = * (long *) ((UBYTE *)ptr + 268);
    glb_dt1[i].bh_start  = * (long *) ((UBYTE *)ptr + 272);

    // debug
    printf("struct data of glb_dt1[%i] :\n", i);
    printf("   x1        = %li\n",    glb_dt1[i].x1);
    printf("   x2        = %li\n",    glb_dt1[i].x2);
    printf("   block_num = %li\n",    glb_dt1[i].block_num);
    printf("   bh_start  = 0x%0lX\n", glb_dt1[i].bh_start);

    // blocks
    size = sizeof(BLOCK_S) * glb_dt1[i].block_num;
    glb_dt1[i].bh_buffer = (void *) malloc(size);
    if (glb_dt1[i].bh_buffer == NULL) {
        FATAL_EXIT("dt1_struct_update(%i), not enough memory for %i bytes\n", i, size);
    }
    glb_dt1[i].bh_buff_len = size;
    //nice~Âíådt1 toolÁöÑÊ∫êÁ†ÅÂèØ‰ª•ÂØπÂ∫î
    dt1_bh_update(i);
    dt1_all_zoom_make(i);
}


// ==========================================================================
// ask to load a dt1 from a mpq
// if the dt1 was already loaded by another ds1, just use the same dt1
//    (and update the usage counter)
// else load it
int dt1_add(char * dt1name)
{
    int  i, idx, entry;
    char tmp[256];

    if (dt1_already_loaded(dt1name, & idx) == TRUE) {
        glb_dt1[idx].ds1_usage++;
        return idx;
    } else {
        // search the first available dt1
        for (i=0; i<DT1_MAX; i++) {
            if (glb_dt1[i].ds1_usage == 0) {
                // this one is emtpy, now load it
                entry = misc_load_mpq_file(
                        dt1name,
                        (char **) & glb_dt1[i].buffer,
                        & glb_dt1[i].buff_len,
                        TRUE
                        );
                if (entry == -1) {
                    FATAL_EXIT("dt1_add() : file %s not found", dt1name);
                }

                // dt1 update
                strcpy(glb_dt1[i].name, dt1name);
                glb_dt1[i].ds1_usage = 1;
                //ÊääÁ¨¨i‰∏™.dt1Â°´ÂÖ•Êï∞ÊçÆÁªìÊûÑ‰∏≠~
                dt1_struct_update(i);

                // free the copy of the dt1 in mem
                free(glb_dt1[i].buffer);
                glb_dt1[i].buffer = NULL;
                glb_dt1[i].buff_len = 0;

                // tell to the ds1 which idx in the glb_dt1[] have been choosen
                return i;
            }
        }
        FATAL_EXIT("can not load %s from mpq,\ntoo much dt1 already loaded (%i)", dt1name, DT1_MAX);
        return -1; // useless, just for not having a vc6 warning
    }
}


// ==========================================================================
// to load ds1edit.dt1 from the data\ directory (not the mod_dir directory)
int dt1_add_special(char * dt1name)
{
    //ËøôÈáåËØªÂèñÁöÑÊòØds1edit.dt1 ‰∏≠Èó¥ÂÖ®ÊòØÈÇ£ÁßçÁâπÊÆäÂùó..‰∏ÄÁÇπÊÑèÊÄùÈÉΩÊ≤°Êúâ
    //‰∏çÊòØ‰∏ÄËà¨ÁöÑdt1...ÈÄöËøádt1 tool Â∞±ÂèØ‰ª•ÁúãÂà∞

    int  i, idx, entry;
    char tmp[256];

    if (dt1_already_loaded(dt1name, & idx) == TRUE) {
        glb_dt1[idx].ds1_usage++;
        return idx;
    } else {
        // search the first available dt1
        for (i=0; i<DT1_MAX; i++) {
            if (glb_dt1[i].ds1_usage == 0) {
                // load from ds1edit directory
                entry = mod_load_in_mem(".", dt1name, & glb_dt1[i].buffer, & glb_dt1[i].buff_len);
                if (entry == -1) {
                    FATAL_EXIT("(dt1_add_special) file %s not found", dt1name);
                } else {
                    printf(", found\n");
                }

                // dt1 update
                strcpy(glb_dt1[i].name, dt1name);
                glb_dt1[i].ds1_usage = 1;
                dt1_struct_update(i);

                // free the copy of the dt1 in mem
                free(glb_dt1[i].buffer);
                glb_dt1[i].buffer = NULL;
                glb_dt1[i].buff_len = 0;

                // tell to the ds1 which idx in the glb_dt1[] have been choosen
                return i;
            }
        }
        FATAL_EXIT("can not load %s from mpq,\ntoo much dt1 already loaded (%i)", dt1name, DT1_MAX);
        return -1; // useless, just for not having a vc6 warning
    }
}
#include "structs.h"
#include "misc.h"
#include "error.h"
#include "anim.h"
#include "editpath.h"
#include "editobj.h"


// ==========================================================================
// helper of the qsort function, for object drawing order
int editobj_qsort_helper_drawing_order(const void * e1, const void * e2)
{
   int   ds1_idx = glb_ds1edit.obj_order_ds1_idx;
   int   i1      = * ((int *) e1),
         i2      = * ((int *) e2);
   OBJ_S * o1, * o2;


   // primary order key  : tile position
   // secondary oder key : modified sub-tile position in that tile
   o1 = & glb_ds1[ds1_idx].obj[i1];
   o2 = & glb_ds1[ds1_idx].obj[i2];
   if (o1->ty == o2->ty){
      if (o1->tx == o2->tx){
         if (glb_ds1edit.obj_sub_tile_order[o1->sx][o1->sy] == glb_ds1edit.obj_sub_tile_order[o2->sx][o2->sy]){
            return i1 - i2;
         }else{
            return glb_ds1edit.obj_sub_tile_order[o1->sy][o1->sx] - glb_ds1edit.obj_sub_tile_order[o2->sy][o2->sx];
         }
      }else{
         return o1->tx - o2->tx;
      }
   }
   return o1->ty - o2->ty;
}


// ==========================================================================
// sort objects to prepare the drawing function
void editobj_set_drawing_order(int ds1_idx)
{
    OBJ_S       *obj;
    int          i;


    //   prepare the sort
    //
    //
    //   typedef struct OBJ_S
    //   {
    //
    //     long        type;
    //     long        id;
    //     long        x;     // sub-cell X
    //     long        y;     // sub-cell Y
    //     long        ds1_flags;
    //
    //     .......
    //     .......
    //
    //     // for sorting
    //     long        tx; // tile X
    //     long        ty; // tile Y
    //     long        sx; // sub-tile X
    //     long        sy; // sub-tile Y
    //
    //     .......
    //     .......
    //
    //   } OBJ_S;
    //
    //  …œ√Êµƒ ˝æ›Ω·ππ÷–
    //  tx∫ÕsxŒ“œ÷‘⁄π¿º∆ø…ƒ‹ «tile, “≤æÕ «¡‚–ŒµƒøÈ∫Õ◊÷øÈ
    //  x∫Õy◊˜’ﬂ±Í√˜ «sub-cell-X∫Õsub-cell-Y, ’‚±Ì æµƒ « ≤√¥ƒÿ?
    //   ¬ µ…œcell∫ÕsubsellŒ“ªπ√ª‘ı√¥∏„√˜∞◊
    //
    //  µ´ «◊Ó÷’≥Ã–Ú◊Ûœ¬Ω«”–∏ˆcell(x,y), ¿Ô√Ê±Í√˜cellµƒº∆ ˝∑Ω Ω «¡‚–Œµƒ∑Ω Ω


    // Œ““ª÷±√ª∑÷«Â≥˛: cell sub-cell tile sub-tile
    //  ‰≥ˆ¥Û∏≈ «»Á¥À:

        // obj =    0, tx =   11, ty =    6, sx =    0, sy =    3
        // obj =    1, tx =   11, ty =    9, sx =    0, sy =    2
        // obj =    2, tx =   31, ty =   19, sx =    0, sy =    2
        // obj =    3, tx =   30, ty =   19, sx =    2, sy =    2
        // obj =    4, tx =   29, ty =   14, sx =    2, sy =    2
        // obj =    5, tx =   28, ty =   14, sx =    3, sy =    2
        // obj =    6, tx =   25, ty =   16, sx =    4, sy =    4
        // obj =    7, tx =   25, ty =   15, sx =    3, sy =    4
        // obj =    8, tx =   25, ty =   13, sx =    0, sy =    3
        // obj =    9, tx =   24, ty =   13, sx =    1, sy =    2
        // obj =   10, tx =   19, ty =    5, sx =    1, sy =    0
        // obj =   11, tx =   18, ty =    4, sx =    4, sy =    1
        // obj =   12, tx =   18, ty =    8, sx =    2, sy =    3
        // obj =   13, tx =   18, ty =    7, sx =    0, sy =    4
        // obj =   14, tx =   16, ty =    9, sx =    4, sy =    1
        // obj =   15, tx =   16, ty =    9, sx =    1, sy =    1
        // obj =   16, tx =   19, ty =   12, sx =    2, sy =    3
        // obj =   17, tx =   18, ty =   12, sx =    4, sy =    4
        // obj =   18, tx =   27, ty =   18, sx =    0, sy =    0
        // obj =   19, tx =   26, ty =    9, sx =    0, sy =    0
        // obj =   20, tx =   16, ty =   11, sx =    3, sy =    3
        // obj =   21, tx =   20, ty =   10, sx =    4, sy =    2
        // obj =   22, tx =   20, ty =    7, sx =    4, sy =    4
        // obj =   23, tx =   18, ty =    3, sx =    0, sy =    3
        // obj =   24, tx =   16, ty =    6, sx =    0, sy =    4
        // obj =   25, tx =   15, ty =    8, sx =    2, sy =    0
        // obj =   26, tx =   15, ty =   10, sx =    2, sy =    0
        // obj =   27, tx =   16, ty =   11, sx =    0, sy =    0
        // obj =   28, tx =    7, ty =    5, sx =    2, sy =    0
        // obj =   29, tx =    7, ty =    7, sx =    2, sy =    0
        // obj =   30, tx =    7, ty =    9, sx =    2, sy =    0
        // obj =   31, tx =    7, ty =   11, sx =    2, sy =    0
        // obj =   32, tx =    4, ty =    5, sx =    1, sy =    3
        // obj =   33, tx =   16, ty =    4, sx =    3, sy =    3
        // obj =   34, tx =    8, ty =    3, sx =    4, sy =    4
        // obj =   35, tx =    4, ty =    1, sx =    2, sy =    2
        // obj =   36, tx =    3, ty =    8, sx =    4, sy =    0
        // obj =   37, tx =    4, ty =    4, sx =    0, sy =    0
        // obj =   38, tx =    4, ty =    1, sx =    3, sy =    2
        // obj =   39, tx =    3, ty =   11, sx =    2, sy =    0
        // obj =   40, tx =    3, ty =    9, sx =    2, sy =    0
        // obj =   41, tx =    3, ty =    7, sx =    2, sy =    0
        // obj =   42, tx =    3, ty =    5, sx =    2, sy =    0
        // obj =   43, tx =   16, ty =   12, sx =    2, sy =    2
        // obj =   44, tx =   16, ty =   13, sx =    3, sy =    1
        // obj =   45, tx =   16, ty =    8, sx =    0, sy =    3
        // obj =   46, tx =   17, ty =    8, sx =    1, sy =    0
        // obj =   47, tx =   25, ty =   14, sx =    1, sy =    2
        // obj =   48, tx =   28, ty =   13, sx =    2, sy =    3

    // ª˘±æø…“‘ø¥≥ˆsx∫Õsy∂º‘⁄0~4÷Æº‰, ∂¯tx∫Õty“≤‘⁄width∫Õheight÷Æº‰
    // √ª”–cellµƒ–≈œ¢
    for(i=0; i < glb_ds1[ds1_idx].obj_num; i++){
        obj     = & glb_ds1[ds1_idx].obj[i];
        obj->tx = obj->x / 5L;
        obj->sx = obj->x % 5L;
        obj->ty = obj->y / 5L;
        obj->sy = obj->y % 5L;
        printf( "obj = %4ld, tx = %4ld, ty = %4ld, sx = %4ld, sy = %4ld\n", i, obj->tx, obj->ty, obj->sx, obj->sy );
    }

    // force unused objects to be in last position
    // ∫√¿ÌΩ‚..”…”⁄÷ª”–obj_num∏ˆ, ∫Û√Êµƒ∂ºŒ™√ª”√µƒ
    // ÷±Ω”∞—ty∏≥÷µŒ™◊Ó¥Û..À˘“‘µΩ¡À◊Ó∫Û, À˘“‘ªπ «y≈≈–Ú∑Ω∑®∞°, ≤ªπ˝ «ty, À˘“‘≥…¡À2.5D
    //
    for (i = glb_ds1[ds1_idx].obj_num; i < glb_ds1[ds1_idx].current_obj_max; i++){
        glb_ds1[ds1_idx].obj[i].ty = 32000L;
    }

    // re-init the drawing order table to the default
    for (i=0; i < glb_ds1[ds1_idx].current_obj_max; i++){
        glb_ds1[ds1_idx].drawing_order[i] = i;
    }

    // sort it
    glb_ds1edit.obj_order_ds1_idx = ds1_idx;
    // editobj_qsort_helper_drawing_order ’‚¿ÔæÕÃ˘π˝¿¥¡À
    // ≤ªπ˝¥Û∏≈π˝≥Ã «:
    // »Áπ˚ty≤ª“ª÷¬, À≠ty–°œ»ª≠À≠
    // »Áπ˚tyœ‡µ», tx≤ª“ª÷¬, ‘ÚtxÀ≠–°œ»ª≠À≠
    // »Áπ˚tx∫Õty∂º «œ‡µ»µƒ, ‘Ú‘⁄obj_table÷–À≠‘⁄«∞œ»ª≠À≠
    // ¥Û∏≈æÕ «’‚∏ˆ“‚Àº
    qsort( glb_ds1[ds1_idx].drawing_order, glb_ds1[ds1_idx].obj_num, sizeof(int), editobj_qsort_helper_drawing_order );


    for (i=0; i < glb_ds1[ds1_idx].current_obj_max; i++){
        printf( "order = %4d, idx = %4d\n", i, glb_ds1[ds1_idx].drawing_order[i] );
    }

    // ’‚“ª∂Œµƒ ‰≥ˆΩ·π˚»Áœ¬, ¥”49ø™ ºŒ™’˝≥£≈≈–Ú, “ÚŒ™…œ√Ê∞—√ª”√µƒobj∂º…Ë÷√Œ™¡À◊Ó¥Û, À˘“‘»Á¥À
            // order =    0, idx =   35
            // order =    1, idx =   38
            // order =    2, idx =   34
            // order =    3, idx =   23
            // order =    4, idx =   37
            // order =    5, idx =   33
            // order =    6, idx =   11
            // order =    7, idx =   42
            // order =    8, idx =   32
            // order =    9, idx =   28
            // order =   10, idx =   10
            // order =   11, idx =    0
            // order =   12, idx =   24
            // order =   13, idx =   41
            // order =   14, idx =   29
            // order =   15, idx =   13
            // order =   16, idx =   22
            // order =   17, idx =   36
            // order =   18, idx =   25
            // order =   19, idx =   45
            // order =   20, idx =   46
            // order =   21, idx =   12
            // order =   22, idx =   40
            // order =   23, idx =   30
            // order =   24, idx =    1
            // order =   25, idx =   15
            // order =   26, idx =   14
            // order =   27, idx =   19
            // order =   28, idx =   26
            // order =   29, idx =   21
            // order =   30, idx =   39
            // order =   31, idx =   31
            // order =   32, idx =   27
            // order =   33, idx =   20
            // order =   34, idx =   43
            // order =   35, idx =   17
            // order =   36, idx =   16
            // order =   37, idx =   44
            // order =   38, idx =    9
            // order =   39, idx =    8
            // order =   40, idx =   48
            // order =   41, idx =   47
            // order =   42, idx =    5
            // order =   43, idx =    4
            // order =   44, idx =    7
            // order =   45, idx =    6
            // order =   46, idx =   18
            // order =   47, idx =    3
            // order =   48, idx =    2
            // order =   49, idx =   49     //’‚¿Ôø™ ºæÕ «∞—ty…Ë÷√Œ™◊Ó¥Ûµº÷¬µƒ, “ÚŒ™À˚√«∂º√ª”√π˝⁄¿
            // order =   50, idx =   50
            // order =   51, idx =   51
            // order =   52, idx =   52
            // order =   53, idx =   53
            // order =   54, idx =   54
            // order =   55, idx =   55
            // order =   56, idx =   56
            // order =   57, idx =   57
            // order =   58, idx =   58
            // order =   59, idx =   59
            // order =   60, idx =   60
            // order =   61, idx =   61
            // order =   62, idx =   62
            // order =   63, idx =   63
            // order =   64, idx =   64
            // order =   65, idx =   65
            // order =   66, idx =   66
            // order =   67, idx =   67
            // order =   68, idx =   68
            // order =   69, idx =   69
            // order =   70, idx =   70
            // order =   71, idx =   71
            // order =   72, idx =   72
            // order =   73, idx =   73
            // order =   74, idx =   74
            // order =   75, idx =   75
            // order =   76, idx =   76
            // order =   77, idx =   77
            // order =   78, idx =   78
            // order =   79, idx =   79
            // order =   80, idx =   80
            // order =   81, idx =   81
            // order =   82, idx =   82
            // order =   83, idx =   83
            // order =   84, idx =   84
            // order =   85, idx =   85
            // order =   86, idx =   86
            // order =   87, idx =   87
            // order =   88, idx =   88
            // order =   89, idx =   89
            // order =   90, idx =   90
            // order =   91, idx =   91
            // order =   92, idx =   92
            // order =   93, idx =   93
            // order =   94, idx =   94
            // order =   95, idx =   95
            // order =   96, idx =   96
            // order =   97, idx =   97
            // order =   98, idx =   98
            // order =   99, idx =   99
}


// ==========================================================================
// make the 'label' windows of all objects of 1 ds1
void editobj_make_obj_label(int ds1_idx)
{
   OBJ_LABEL_S * label;
   int         d, o, w, wtmp, h;
   long        type, id;


   for (o=0; o < glb_ds1[ds1_idx].obj_num; o++)
   {
      type  = glb_ds1[ds1_idx].obj[o].type;
      id    = glb_ds1[ds1_idx].obj[o].id;
      d     = glb_ds1[ds1_idx].obj[o].desc_idx;
      label = & glb_ds1[ds1_idx].obj[o].label;

      w = 16 * 8;     // 16 chars
      h =  2 * 8 + 2; // 2 char lines + 2 pixel lines for readibility

      if (d != -1)
      {
         wtmp = 8 * strlen(glb_ds1edit.obj_desc[d].desc);
         if (wtmp > w)
            w = wtmp;
      }
      label->rx    = 0;
      label->ry    = 0;
      label->w     = w;
      label->h     = h;
      label->flags = 0;
   }
}


// ==========================================================================
// draw the objects & the label windows of 1 ds1
//   if is_shadow is TRUE, only draw the ones which are moving (copy, move)
void editobj_draw_obj_lab(int ds1_idx, int is_shadow)
{
   OBJ_LABEL_S * label;
   int         d, dx, dy, o, cx, cy, w, h, p, loop, f1, f2;
   long        type, id, x, y;
   int         ox0, oy0, lx0, ly0;
   int         hm = glb_ds1[ds1_idx].height_mul;
   int         hd = glb_ds1[ds1_idx].height_div;
   int         x1, x2, x3, x4, y1, y2, y3;
   int         color1=0, color2=0, color3=0;
   int         o_idx;


   for (loop=0; loop<3; loop++)
   {
      // loop 0 : all objects (feet)
      // loop 1 : all lines
      // loop 2 : all label windows
      for (o_idx=0; o_idx < glb_ds1[ds1_idx].obj_num; o_idx++)
      {
         o     = glb_ds1[ds1_idx].drawing_order[o_idx];

         type  = glb_ds1[ds1_idx].obj[o].type;
         id    = glb_ds1[ds1_idx].obj[o].id;
         x     = glb_ds1[ds1_idx].obj[o].x;
         y     = glb_ds1[ds1_idx].obj[o].y;

         d     = glb_ds1[ds1_idx].obj[o].desc_idx;
         p     = glb_ds1[ds1_idx].obj[o].path_num;
         f1    = glb_ds1[ds1_idx].obj[o].flags;
         label = & glb_ds1[ds1_idx].obj[o].label;
         w     = label->w;
         h     = label->h;
         f2    = label->flags;

         if (is_shadow)
         {
            if ( ! IS_MOVING(f1 | f2))
               continue;
               
            color1 = 186; // background label
            color2 = 209; // sub-tile & line color
            color3 = 214; // label border color

            x = glb_ds1[ds1_idx].obj[o].old_x;
            y = glb_ds1[ds1_idx].obj[o].old_y;
         }
         else
         {
            x = glb_ds1[ds1_idx].obj[o].x;
            y = glb_ds1[ds1_idx].obj[o].y;
         }
         
         // objects sprite origin, in screen (upper-center corner)
         dx  = ((y-2) * -glb_ds1[ds1_idx].tile_w / 10) + ((x+3) * glb_ds1[ds1_idx].tile_w / 10);
         dy  = ((y-2) *  glb_ds1[ds1_idx].tile_h / 10) + ((x+3) * glb_ds1[ds1_idx].tile_h / 10);
         ox0 = dx - glb_ds1edit.win_preview.x0;
         oy0 = dy - glb_ds1edit.win_preview.y0 - 16;

         // labels origin, in screen (bottom-center border)
         if (is_shadow)
         {
            lx0 = ox0 + (label->old_rx * hm / hd);
            ly0 = oy0 + (label->old_ry * hm / hd);
         }
         else
         {
            lx0 = ox0 + (label->rx * hm / hd);
            ly0 = oy0 + (label->ry * hm / hd);
         }

         // color for NORMAL objects / labels
         if (is_shadow == FALSE)
         {
            color1 = 0;   // background label
            color2 = 255; // sub-tile & line color
            color3 = 255; // label border color
            if (IS_SELECTED(f1))
            {
               color1 = 118;
               color2 = 132;
               color3 = 132;
            }
            else if (IS_MOUSE_OVER(f1))
            {
               color2 = 129;
               if (IS_SELECTED(f2))
               {
                  color1 = 118;
                  color3 = 132;
               }
               else
                  color3 = 129;
            }
            else if (IS_SELECTED(f2))
            {
               color1 = 118;
               color3 = 132;
            }
            else if (IS_MOUSE_OVER(f2))
               color3 = 129;
         }
         
         switch(loop)
         {
            case 0 :
               // draw object sub-tile
               cx = x + 2;
               cy = y - 2;

               dx = (cy * -glb_ds1[ds1_idx].tile_w / 10) + (cx * glb_ds1[ds1_idx].tile_w / 10);
               dy = (cy *  glb_ds1[ds1_idx].tile_h / 10) + (cx * glb_ds1[ds1_idx].tile_h / 10);

               x1 = dx - glb_ds1edit.win_preview.x0;
               x2 = x1 + glb_ds1[ds1_idx].tile_w / 10 - 1;
               x3 = x1 + glb_ds1[ds1_idx].tile_w / 10;
               x4 = x1 + glb_ds1[ds1_idx].tile_w / 5 - 1;

               y1 = dy - glb_ds1edit.win_preview.y0;
               y2 = y1 + glb_ds1[ds1_idx].tile_h / 10 - 1;
               y3 = y1 + glb_ds1[ds1_idx].tile_h / 5 - 2;
   
               line(glb_ds1edit.screen_buff, x1, y2, x2, y1, color2);
               line(glb_ds1edit.screen_buff, x3, y1, x4, y2, color2);
               line(glb_ds1edit.screen_buff, x3, y3, x4, y2, color2);
               line(glb_ds1edit.screen_buff, x1, y2, x2, y3, color2);
               break;


            case 1 :
               // draw shadow lines
               line(glb_ds1edit.screen_buff, ox0+1, oy0+17, ox0+1, oy0+1, 0);
               line(glb_ds1edit.screen_buff, ox0+1, oy0+1,  lx0+1, ly0+1, 0);
               line(glb_ds1edit.screen_buff, lx0+1, ly0+1,  lx0+1, ly0-8, 0);
               
               // draw lines
               line(glb_ds1edit.screen_buff, ox0, oy0+16, ox0, oy0,   color2);
               line(glb_ds1edit.screen_buff, ox0, oy0,    lx0, ly0,   color2);
               line(glb_ds1edit.screen_buff, lx0, ly0,    lx0, ly0-9, color2);

               if (IS_SELECTED(f1))
               {
                  line(glb_ds1edit.screen_buff, ox0-1, oy0+16, ox0-1, oy0,   color2);
                  line(glb_ds1edit.screen_buff, ox0-1, oy0,    lx0-1, ly0,   color2);
                  line(glb_ds1edit.screen_buff, lx0-1, ly0,    lx0-1, ly0-9, color2);
                  rectfill(glb_ds1edit.screen_buff, ox0-2, oy0+14, ox0+1, oy0+16, color2);
               }
               else
                  rectfill(glb_ds1edit.screen_buff, ox0-1, oy0+14, ox0+1, oy0+16, color2);

               break;
            

            case 2 :
               // draw label
               x1 = lx0 - (w/2) - 2;
               x2 = x1 + w + 4;
               y1 = ly0 - 8 - h - 4;
               y2 = y1 + h + 2;

               if (is_shadow == FALSE)
               {
                  label->x0 = x1;
                  label->y0 = y1;
               }
         
               // draw ?
               if ((x1 >= glb_config.screen.width) ||
                   (y1 >= glb_config.screen.height) ||
                   (x2 < 0) || (y2 < 0))
                  break;
               
               rectfill(glb_ds1edit.screen_buff, x1, y1, x2, y2, color1);
               rect    (glb_ds1edit.screen_buff, x1, y1, x2, y2, color3);
      
               // desc
               x2 = x1 + 2 + (w/2);
               y2 = y1 + 2;
               if (d == -1) {
                  textprintf(glb_ds1edit.screen_buff, font, x2 - 8, y2, 255, "??");
               } else {
                  x2 -= (8 * strlen(glb_ds1edit.obj_desc[d].desc) / 2);
                  textprintf(glb_ds1edit.screen_buff, font, x2, y2, 255, "%s", glb_ds1edit.obj_desc[d].desc);
               }
                  
               // object number
               x2 = x1 + 2;
               y2 += 8 + 2;
               textprintf(glb_ds1edit.screen_buff, font, x2, y2, is_shadow ? 255 : 111, "#%i", o);

               // Type
               if (id <= -100)     x2 = lx0 - 3 * 8;
               else if (id <= -10) x2 = lx0 - 2 * 8 - 4;
               else if (id < 0)    x2 = lx0 - 8 - 4;
               else if (id < 10)   x2 = lx0 - 8 - 4;
               else if (id < 100)  x2 = lx0 - 2 * 8;
               else                x2 = lx0 - 2 * 8 - 4;
               textprintf(glb_ds1edit.screen_buff, font, x2, y2, is_shadow ? 255 : 11, "%ld", type);


               // Id
               x2 += 1*8;
               textprintf(glb_ds1edit.screen_buff, font, x2, y2, is_shadow ? 255 : 255, " %ld", id);

               // paths number
               if (p < 10)
                  x2 = x1 + w + 4 - 2 * 8;
               else
                  x2 = x1 + w + 4 - 3 * 8;
               if (p == 0) {
                  textprintf(glb_ds1edit.screen_buff, font, x2, y2, is_shadow ? 255 : 208, "P-");
               } else {
                  textprintf(glb_ds1edit.screen_buff, font, x2, y2, is_shadow ? 255 : 133, "P%i", p);
               }
               break;
         }
      }
   }
}


// ==========================================================================
// search the description index of 1 object of 1 ds1, given its Type & Id
void editobj_make_obj_desc(int ds1_idx, int obj_idx)
{
    int    *nb_type_per_act_ptr;
    int     act, type, id, i;

    act  = glb_ds1[ds1_idx].act;
    type = glb_ds1[ds1_idx].obj[obj_idx].type;
    id   = glb_ds1[ds1_idx].obj[obj_idx].id;

    // first try : search the exact act/type/id in data\obj.txt
    for(i=0; i < glb_ds1edit.obj_desc_num; i++){
        if( (glb_ds1edit.obj_desc[i].act  == act)  && (glb_ds1edit.obj_desc[i].type == type) && (glb_ds1edit.obj_desc[i].id   == id) ){
            // end
            glb_ds1[ds1_idx].obj[obj_idx].desc_idx = i;
            return;
        }
    }

    // not found in data\obj.txt
    // Œ“µ˜ ‘µƒπ˝≥Ã÷– œ¬√Êµƒ¥˙¬Î√ª”–±ª÷¥––

    // swap act/id according to object type
    if (type == 1){
        nb_type_per_act_ptr = & glb_config.nb_type1_per_act;
    }else if (type == 2){
        nb_type_per_act_ptr = & glb_config.nb_type2_per_act;
    }else{
        // shouldn't happen
        glb_ds1[ds1_idx].obj[obj_idx].desc_idx = -1;
        return;
    }

    while(id < 0){
        // object of precedent act
        act--;
        id += (* nb_type_per_act_ptr);
    }
    while(id >= (* nb_type_per_act_ptr)){
        // object of next act
        act++;
        id -= (* nb_type_per_act_ptr);
    }

    // search again with these new Act / Id
    for(i=0; i < glb_ds1edit.obj_desc_num; i++){
        if( (glb_ds1edit.obj_desc[i].act  == act)  && (glb_ds1edit.obj_desc[i].type == type) && (glb_ds1edit.obj_desc[i].id   == id) ){
            // end
            glb_ds1[ds1_idx].obj[obj_idx].desc_idx = i;
            return;
        }
    }

    // not found
    glb_ds1[ds1_idx].obj[obj_idx].desc_idx = -1;
}


// ==========================================================================
// given a description index of 1 object of 1 ds1, compute its right Id
void editobj_make_obj_new_id(int ds1_idx, int obj_idx)
{
   int act, type, id, d, * nb_type_per_act_ptr;


   d    = glb_ds1[ds1_idx].obj[obj_idx].desc_idx;
   act  = glb_ds1edit.obj_desc[d].act;
   type = glb_ds1edit.obj_desc[d].type;
   id   = glb_ds1edit.obj_desc[d].id;

   if (type == 1)
      nb_type_per_act_ptr = & glb_config.nb_type1_per_act;
   else if (type == 2)
      nb_type_per_act_ptr = & glb_config.nb_type2_per_act;
   else // shouldn't happen
   {
      // update the object type / id
      glb_ds1[ds1_idx].obj[obj_idx].type = type;
      glb_ds1[ds1_idx].obj[obj_idx].id   = id;
      return;
   }

   while (act < glb_ds1[ds1_idx].act)
   {
      // object of precedent act
      act++;
      id -= (* nb_type_per_act_ptr);
   }
   while (act > glb_ds1[ds1_idx].act)
   {
      // object of next act
      act--;
      id += (* nb_type_per_act_ptr);
   }

   // update the object type / id
   glb_ds1[ds1_idx].obj[obj_idx].type = type;
   glb_ds1[ds1_idx].obj[obj_idx].id   = id;
}


// ==========================================================================
// clear the 'selected' flag of all the objects & labels of 1 ds1
void editobj_clear_obj_lab_sel(int ds1_idx)
{
   int i;
   

   for (i=0; i < glb_ds1[ds1_idx].obj_num; i++)
   {
      DEL_SELECTED(glb_ds1[ds1_idx].obj[i].label.flags);
      DEL_SELECTED(glb_ds1[ds1_idx].obj[i].flags);
   }
}


// ==========================================================================
// clear the 'mouse_over' flag of all the objects & labels of 1 ds1
void editobj_clear_obj_lab_over(int ds1_idx)
{
   int i;
   

   for (i=0; i < glb_ds1[ds1_idx].obj_num; i++)
   {
      DEL_MOUSE_OVER(glb_ds1[ds1_idx].obj[i].label.flags);
      DEL_MOUSE_OVER(glb_ds1[ds1_idx].obj[i].flags);
   }
}


// ==========================================================================
// clear all the flags of all the objects & labels of 1 ds1
void editobj_clear_obj_lab_flags(int ds1_idx)
{
   int i;
   

   for (i=0; i < glb_ds1[ds1_idx].obj_num; i++)
      glb_ds1[ds1_idx].obj[i].flags = glb_ds1[ds1_idx].obj[i].label.flags = 0;
}


// ==========================================================================
// managment of the mouse focus. only 1 label OR 1 object can have
// the focus at a time ( & label have a higher priority than object feet)
// this function tells if the screen have to be redraw too
// it also handles the mouse_over flag of all objects & labels
// it set pointer datas to the object or label that have the focus
int editobj_over_obj_lab(int ds1_idx, int * ptr_t, int * ptr_o,
                         int cx, int cy, int mx, int my)
{
   OBJ_LABEL_S * label;
   int         loop, o, w, h, x, y, x0, y0, last_t=0, last_o = -1;
   int         redraw = FALSE, o_idx;


   for (loop=0; loop<2; loop++)
   {
      for (o_idx=0; o_idx < glb_ds1[ds1_idx].obj_num; o_idx++)
      {
         o = glb_ds1[ds1_idx].drawing_order[o_idx];
         switch(loop)
         {
            case 0:
               // check sub-tile
               x = glb_ds1[ds1_idx].obj[o].x;
               y = glb_ds1[ds1_idx].obj[o].y;
               if ((cx == x) && (cy == y))
               {
                  // mouse over this object
                  last_t = 2;
                  last_o = o;
               }
               else
               {
                  // mouse NOT over this object
                  if (IS_MOUSE_OVER(glb_ds1[ds1_idx].obj[o].flags))
                  {
                     // mouse WAS over this object, but not anymore
                     redraw = TRUE;
                  }
               }
               break;
               
            case 1:
               // check label
               label = & glb_ds1[ds1_idx].obj[o].label;
               w     = label->w;
               h     = label->h;
               x0    = label->x0;
               y0    = label->y0;;
               if ((mx >= x0) && (my >= y0) && (mx < x0+w+4) &&
                   (my < y0+h+4))
               {
                  // mouse over this label
                  last_t = 1;
                  last_o = o;
               }
               else
               {
                  // mouse NOT over this label
                  if (IS_MOUSE_OVER(glb_ds1[ds1_idx].obj[o].label.flags))
                  {
                     // mouse WAS over this label, but not anymore
                     redraw = TRUE;
                  }
               }
               break;
         }
      }
   }

   if (redraw == TRUE)
   {
      // mouse WAS over an object or label, not anymore
      editobj_clear_obj_lab_over(ds1_idx);
      if (last_o != -1)
      {
         if (last_t == 1) // label
            SET_MOUSE_OVER(glb_ds1[ds1_idx].obj[last_o].label.flags);
         else // object
            SET_MOUSE_OVER(glb_ds1[ds1_idx].obj[last_o].flags);
      }
   }

   if (last_o != -1)
   {
      // mouse is over an object or label
      if (last_t == 1)
      {
         // over a label
         if ( ! IS_MOUSE_OVER(glb_ds1[ds1_idx].obj[last_o].label.flags))
         {
            // new label
            editobj_clear_obj_lab_over(ds1_idx);
            SET_MOUSE_OVER(glb_ds1[ds1_idx].obj[last_o].label.flags);
            redraw = TRUE;
         }
      }
      else
      {
         // over an object
         if ( ! IS_MOUSE_OVER(glb_ds1[ds1_idx].obj[last_o].flags))
         {
            // new object
            editobj_clear_obj_lab_over(ds1_idx);
            SET_MOUSE_OVER(glb_ds1[ds1_idx].obj[last_o].flags);
            redraw = TRUE;
         }
      }
   }
         
   // end
   * ptr_t = last_t;
   * ptr_o = last_o;
   return redraw;
}


// ==========================================================================
// prepare the move of objects & labels
//    moving flags & starting position
void editobj_prepare_moving(int ds1_idx)
{
   OBJ_LABEL_S * label;
   OBJ_S       * ptr_obj;
   int         o;


   for (o=0; o < glb_ds1[ds1_idx].obj_num; o++)
   {
      ptr_obj = & glb_ds1[ds1_idx].obj[o];
      label   = & glb_ds1[ds1_idx].obj[o].label;
      if (IS_SELECTED(ptr_obj->flags | label->flags))
      {
         if (IS_SELECTED(ptr_obj->flags))
            SET_MOVING(ptr_obj->flags);

         if (IS_SELECTED(label->flags))
            SET_MOVING(label->flags);
            
         ptr_obj->old_x = ptr_obj->x;
         ptr_obj->old_y = ptr_obj->y;
         label->old_rx  = label->rx;
         label->old_ry  = label->ry;
      }
   }
}


// ==========================================================================
// handler of moving objects & labels
int editobj_moving_obj_lab(int ds1_idx, int dcx, int dcy, int dmx, int dmy)
{
   OBJ_LABEL_S * label;
   OBJ_S       * ptr_obj;
   static      int old_dcx, old_dcy, old_dmx, old_dmy, old_ds1_idx = -1;
   int         o, redraw = FALSE, save_old = FALSE;


   for (o=0; o < glb_ds1[ds1_idx].obj_num; o++)
   {
      ptr_obj = & glb_ds1[ds1_idx].obj[o];
      if (IS_MOVING(ptr_obj->flags))
      {
         if ((old_dcx != dcx) || (old_dcy != dcy) || (ds1_idx != old_ds1_idx))
         {
            ptr_obj->x = ptr_obj->old_x + dcx;
            ptr_obj->y = ptr_obj->old_y + dcy;

            if (ptr_obj->x < 0)
               ptr_obj->x = 0;
            if (ptr_obj->x >= glb_ds1[ds1_idx].width * 5)
               ptr_obj->x = glb_ds1[ds1_idx].width * 5 - 1;

            if (ptr_obj->y < 0)
               ptr_obj->y = 0;
            if (ptr_obj->y >= glb_ds1[ds1_idx].height * 5)
               ptr_obj->y = glb_ds1[ds1_idx].height * 5 - 1;

            save_old = TRUE;
         }
      }

      label = & glb_ds1[ds1_idx].obj[o].label;
      if (IS_MOVING(label->flags))
      {
         if ((old_dmx != dmx) || (old_dmy != dmy) || (ds1_idx != old_ds1_idx))
         {
            label->rx = label->old_rx + dmx;
            label->ry = label->old_ry + dmy;
            
            save_old = TRUE;
         }
      }
   }
   if ((save_old) || (ds1_idx != old_ds1_idx))
   {
      old_ds1_idx = ds1_idx;
      old_dcx     = dcx;
      old_dcy     = dcy;
      old_dmx     = dmx;
      old_dmy     = dmy;
      redraw      = TRUE;
   }
   return redraw;
}


// ==========================================================================
// end the move of objects & labels
void editobj_end_move_obj_lab(int ds1_idx)
{
   OBJ_LABEL_S * label;
   OBJ_S       * ptr_obj;
   int         o;


   for (o=0; o < glb_ds1[ds1_idx].obj_num; o++)
   {
      ptr_obj = & glb_ds1[ds1_idx].obj[o];
      DEL_MOVING(ptr_obj->flags);

      label = & ptr_obj->label;
      DEL_MOVING(label->flags);
   }
}


// ==========================================================================
// prepare 1 step undo : full backup of objects & labels datas
void editobj_prepare_undo(int ds1_idx)
{
   OBJ_S * ptr_s, * ptr_d;
   int   o;


   for (o=0; o < glb_ds1[ds1_idx].obj_num; o++)
   {
      ptr_s = & glb_ds1[ds1_idx].obj[o];
      ptr_d = & glb_ds1[ds1_idx].obj_undo[o];
      memcpy(ptr_d, ptr_s, sizeof (OBJ_S));
   }
   glb_ds1[ds1_idx].obj_num_undo = glb_ds1[ds1_idx].obj_num;
   glb_ds1[ds1_idx].can_undo_obj = TRUE;
}


// ==========================================================================
// use the backup to restore the previous state of objects & labels
void editobj_undo(int ds1_idx)
{
   OBJ_S * ptr_s, * ptr_d;
   int   o;


   // just in case
   if (glb_ds1[ds1_idx].can_undo_obj == FALSE)
      return;

   for (o=0; o < glb_ds1[ds1_idx].obj_num_undo; o++)
   {
      ptr_s = & glb_ds1[ds1_idx].obj_undo[o];
      ptr_d = & glb_ds1[ds1_idx].obj[o];
      memcpy(ptr_d, ptr_s, sizeof (OBJ_S));
   }
   glb_ds1[ds1_idx].obj_num = glb_ds1[ds1_idx].obj_num_undo;
}


// ==========================================================================
// delete objects (and their labels)
// reorganize the objects table (no hole between them)
void editobj_del_obj(int ds1_idx)
{
   OBJ_S * ptr_s, * ptr_d;
   int   s=0, d=0, n=0, max = glb_ds1[ds1_idx].obj_num, done = FALSE;


   while ( ! done)
   {
      ptr_d = & glb_ds1[ds1_idx].obj[d];
      if (IS_SELECTED(ptr_d->flags))
      {
         // search next non-selected
         while ((s < max) && IS_SELECTED(glb_ds1[ds1_idx].obj[s].flags))
            s++;
         // found one ?
         if (s < max)
         {
            // copy this one
            ptr_s = & glb_ds1[ds1_idx].obj[s];
            memcpy(ptr_d, ptr_s, sizeof (OBJ_S));
            SET_SELECTED(ptr_s->flags);
         }
         else
            done = TRUE;
      }
      if (done == FALSE)
      {
         n++;
         d++;
         s++;
         if (d >= max)
            done = TRUE;
      }
   }
   
   // delete completly all the unused objects datas
   for (s=n; s < max; s++)
      memset( & glb_ds1[ds1_idx].obj[s], 0, sizeof(OBJ_S));
      
   // end
   glb_ds1[ds1_idx].obj_num = n;
}


// ==========================================================================
// copy some objects
// create new objects at the end of the objects table, and flags handle
void editobj_copy_obj(int ds1_idx)
{
   OBJ_S * ptr_s, * ptr_d;
   int   o, d, nb=0, max = glb_ds1[ds1_idx].obj_num;
   long  incr;


   // count selected obj
   for (o=0; o < max; o++)
      if (IS_SELECTED(glb_ds1[ds1_idx].obj[o].flags))
         nb++;

   // just in case
   if (nb <= 0)
      return;
      
   // check if can make new objects
   if ((max + nb) >= glb_ds1[ds1_idx].current_obj_max)
   {
        incr = 1 + (max + nb) - glb_ds1[ds1_idx].current_obj_max;
        if (misc_increase_ds1_objects_max(ds1_idx, incr) != 0)
            return;
   }

   // make new objects, deselect old ones (new ones are already selected)
   d = max;
   for (o=0; o < max; o++)
   {
      if (IS_SELECTED(glb_ds1[ds1_idx].obj[o].flags))
      {
         ptr_s = & glb_ds1[ds1_idx].obj[o];
         ptr_d = & glb_ds1[ds1_idx].obj[d];
         memcpy(ptr_d, ptr_s, sizeof (OBJ_S));
         DEL_SELECTED(ptr_s->flags);
         SET_MOUSE_OVER(ptr_s->flags); // to still see the original objects
         ptr_d->frame_delta = rand()%256;;
         d++;
      }
   }
   glb_ds1[ds1_idx].obj_num = max + nb;
}


// ==========================================================================
/*
void editobj_search_copy_center(int ds1_idx, int * cx, int * cy)
{
   OBJ_S * ptr_o;
   int   x1=30000, y1=30000, x2 = -30000, y2 = -30000, x, y, o;

   for (o=0; o < glb_ds1[ds1_idx].obj_num; o++)
   {
      ptr_o = & glb_ds1[ds1_idx].obj[o];
      if (IS_SELECTED(ptr_o->flags))
      {
         x = ptr_o->x;
         y = ptr_o->y;
         if (x < x1) x1 = x;
         if (x > x2) x2 = x;
         if (y < y1) y1 = y;
         if (y > y2) y2 = y;
      }
   }
   * cx = x1 + ( (x2 - x1) / 2);
   * cy = y1 + ( (y2 - y1) / 2);
}


// ==========================================================================
int editobj_center_before_copy(int ds1_idx, int * cx0, int * cy0,
                                            int * mx,  int * my)
{
   int dx, dy, cx, cy, x0, y0, o, nb=0;

   // count selected obj
   for (o=0; o < glb_ds1[ds1_idx].obj_num; o++)
      if (IS_SELECTED(glb_ds1[ds1_idx].obj[o].flags))
         nb++;

   // just in case
   if (nb <= 0)
      return 0;
      
   editobj_search_copy_center(ds1_idx, & cx, & cy);

   dx = (cy * -glb_ds1[ds1_idx].tile_w / 10) + (cx * glb_ds1[ds1_idx].tile_w / 10);
   dy = (cy *  glb_ds1[ds1_idx].tile_h / 10) + (cx * glb_ds1[ds1_idx].tile_h / 10);
   x0 = dx - glb_ds1[ds1_idx].own_wpreview.w / 2;
   y0 = dy - glb_ds1[ds1_idx].own_wpreview.h / 2;

   glb_ds1edit.win_preview.x0   = x0;
   glb_ds1edit.win_preview.y0   = y0;
   glb_ds1[ds1_idx].own_wpreview.x0 = x0;
   glb_ds1[ds1_idx].own_wpreview.y0 = y0;

   * cx0 = cx;
   * cy0 = cy;
   * mx = mouse_x;
   * my = mouse_y;

   return nb;
}
*/


// ==========================================================================
// count selected objects
int editobj_count_sel_obj(int ds1_idx)
{
   int o, nb=0;


   for (o=0; o < glb_ds1[ds1_idx].obj_num; o++)
      if (IS_SELECTED(glb_ds1[ds1_idx].obj[o].flags))
         nb++;

   return nb;
}


// ==========================================================================
// add 1 object at the end of object table
//    set it to a default type & id, and prepare its label window
int editobj_insert_obj(int ds1_idx, int cx, int cy)
{
   OBJ_LABEL_S * label;
   OBJ_S       * ptr_o;
   int         d, id, type, obj, w, wtmp, h;
   long        incr;


   obj = glb_ds1[ds1_idx].obj_num;
   if (obj >= glb_ds1[ds1_idx].current_obj_max)
   {
        incr = 1 + obj - glb_ds1[ds1_idx].current_obj_max;
        if (misc_increase_ds1_objects_max(ds1_idx, incr) != 0)
            return 1;
   }

   glb_ds1[ds1_idx].obj_num++;
   ptr_o = & glb_ds1[ds1_idx].obj[obj];

   ptr_o->type     = 1;
   ptr_o->id       = 0;
   ptr_o->x        = cx;
   ptr_o->y        = cy;
   ptr_o->path_num = 0;
   ptr_o->flags    = 0;
   SET_SELECTED(ptr_o->flags);
   ptr_o->frame_delta = rand()%256;
   editobj_make_obj_desc(ds1_idx, obj);

   type  = ptr_o->type;
   id    = ptr_o->id;
   d     = ptr_o->desc_idx;
   label = & ptr_o->label;

   w = 16 * 8;     // 16 chars
   h =  2 * 8 + 2; // 2 char lines + 2 pixel lines for readibility

   if (d != -1)
   {
      wtmp = 8 * strlen(glb_ds1edit.obj_desc[d].desc);
      if (wtmp > w)
         w = wtmp;
   }
   label->rx    = 0;
   label->ry    = 0;
   label->w     = w;
   label->h     = h;
   label->flags = 0;

   return 0;
}


// ==========================================================================
// prepare the objects list window (variable width, buttons, etc)
void editobj_prepare_edit_obj_win(int ds1_idx, int obj_idx)
{
   WIN_EDT_OBJ_S * ptr_w = & glb_ds1[ds1_idx].win_edt_obj;
   OBJ_DESC_S    * ptr_d;
   EDT_BUT_S     * b;
   int           act, w, h, desc_len = 0, len, n, d, i, x0, y0, typ;
   int           myborder = 2;
   static struct{
      int  x1, y1, x2, y2, x, y; // relative to upper / left corner of the
                                 //    window, NOT the screen
      char name[10];
   } but_init[EB_MAX] = {
        {  0,  0,  62, 22,   8,  8, "  OK"},
        { 70,  0, 132, 22,  78,  8, "CANCEL"},
        {210,  0, 272, 22, 218,  8, "TYPE 1"},
        {280,  0, 342, 22, 288,  8, "TYPE 2"},

        {  0, 30,  62, 52,  12, 38, "ACT 1"},
        { 70, 30, 132, 52,  82, 38, "ACT 2"},
        {140, 30, 202, 52, 152, 38, "ACT 3"},
        {210, 30, 272, 52, 222, 38, "ACT 4"},
        {280, 30, 342, 52, 292, 38, "ACT 5"},
     };


   w   = glb_config.screen.width;
   h   = glb_config.screen.height;
   act = ptr_w->cur_act;
   typ = ptr_w->cur_type;

   // max char size of the desc of current act & current type
   ptr_w->desc_end = ptr_w->desc_start = -1;
   for (d=0; d < glb_ds1edit.obj_desc_num; d++)
   {
      ptr_d = & glb_ds1edit.obj_desc[d];
      if ((ptr_d->act == act) && (ptr_d->type == typ))
      {
         len = 1 + strlen(ptr_d->desc);
         if (len > desc_len)
            desc_len = len;
         if (ptr_w->desc_start == -1)
            ptr_w->desc_start = d;
         ptr_w->desc_end = d;
      }
   }
   n = strlen(" Description");
   if (n > desc_len)
      desc_len = n;
   ptr_w->desc_char = desc_len;
   ptr_w->desc_num  = ptr_w->desc_end - ptr_w->desc_start + 1;
   ptr_w->obj_idx   = obj_idx;

   // compute window size & position
   ptr_w->x0  = 5;
   ptr_w->y0  = 15;
   ptr_w->h   = glb_config.screen.height - ptr_w->y0 - 20;
   ptr_w->num = ((ptr_w->h - 69 - (3 * 10)) / 10) - myborder;
   if (ptr_w->num < 1)
      ptr_w->num = 1;
   ptr_w->h   = 69 + 10 * (3 + ptr_w->num + myborder) + 5;
   
   if (glb_ds1edit.obj_desc[ptr_w->desc_cur].act != ptr_w->cur_act)
      ptr_w->start = ptr_w->desc_start;
   else if (glb_ds1[ds1_idx].obj[obj_idx].desc_idx == -1)
   {
      ptr_w->start = ptr_w->desc_start;
   }
   else
   {
      ptr_w->start = ptr_w->desc_cur - (ptr_w->num / 2);
      if (ptr_w->start + ptr_w->num > ptr_w->desc_end)
         ptr_w->start = ptr_w->desc_end - ptr_w->num + 1;
      if (ptr_w->start < ptr_w->desc_start)
         ptr_w->start = ptr_w->desc_start;
   }

   ptr_w->w = 8 * (4 + 3 + desc_len + 5); // type + id + desc + blanks
   if (ptr_w->w < 358)
      ptr_w->w = 358;

   // buttons
   x0 = ptr_w->x0 + 8;
   y0 = ptr_w->y0 + 8;
   for (i=0; i<EB_MAX; i++)
   {
      b = & ptr_w->button[i];
      b->box.x1 = x0 + but_init[i].x1;
      b->box.y1 = y0 + but_init[i].y1;
      b->box.x2 = x0 + but_init[i].x2;
      b->box.y2 = y0 + but_init[i].y2;
      b->txt.x  = x0 + but_init[i].x;
      b->txt.y  = y0 + but_init[i].y;
      strcpy(b->name, but_init[i].name);
      b->flags  = 0;
   }

   // flags of buttons
   SET_ACTIVATED(ptr_w->button[EB_OK].flags);
   SET_ACTIVATED(ptr_w->button[EB_CANCEL].flags);
   SET_ACTIVATED(ptr_w->button[EB_TYPE1].flags);
   SET_ACTIVATED(ptr_w->button[EB_TYPE2].flags);

   if (typ == 1)
   {
      SET_SELECTED(ptr_w->button[EB_TYPE1].flags);

      SET_ACTIVATED(ptr_w->button[EB_ACT1].flags);
      SET_ACTIVATED(ptr_w->button[EB_ACT2].flags);
      SET_ACTIVATED(ptr_w->button[EB_ACT3].flags);
      SET_ACTIVATED(ptr_w->button[EB_ACT4].flags);
      SET_ACTIVATED(ptr_w->button[EB_ACT5].flags);
   }
   else
   {
      SET_SELECTED(ptr_w->button[EB_TYPE2].flags);
      if (glb_config.normal_type2 == TRUE)
      {
         // act 1 always possible
         SET_ACTIVATED(ptr_w->button[EB_ACT1].flags);

         // now, current act & previous ones only, not further
         if (glb_ds1[ds1_idx].act >= 2)
            SET_ACTIVATED(ptr_w->button[EB_ACT2].flags);

         if (glb_ds1[ds1_idx].act >= 3)
            SET_ACTIVATED(ptr_w->button[EB_ACT3].flags);

         if (glb_ds1[ds1_idx].act >= 4)
            SET_ACTIVATED(ptr_w->button[EB_ACT4].flags);

         if (glb_ds1[ds1_idx].act >= 5)
            SET_ACTIVATED(ptr_w->button[EB_ACT5].flags);
      }
      else
      {
         SET_ACTIVATED(ptr_w->button[EB_ACT1].flags);
         SET_ACTIVATED(ptr_w->button[EB_ACT2].flags);
         SET_ACTIVATED(ptr_w->button[EB_ACT3].flags);
         SET_ACTIVATED(ptr_w->button[EB_ACT4].flags);
         SET_ACTIVATED(ptr_w->button[EB_ACT5].flags);
      }
   }

   switch(act)
   {
      case 1 : SET_SELECTED(ptr_w->button[EB_ACT1].flags); break;
      case 2 : SET_SELECTED(ptr_w->button[EB_ACT2].flags); break;
      case 3 : SET_SELECTED(ptr_w->button[EB_ACT3].flags); break;
      case 4 : SET_SELECTED(ptr_w->button[EB_ACT4].flags); break;
      case 5 : SET_SELECTED(ptr_w->button[EB_ACT5].flags); break;
   }

   // end
   glb_ds1[ds1_idx].draw_edit_obj = TRUE;
}


// ==========================================================================
// draw the objects description list window
void editobj_draw_edit_obj(int ds1_idx)
{
   WIN_EDT_OBJ_S * ptr_w = & glb_ds1[ds1_idx].win_edt_obj;
   OBJ_DESC_S    * ptr_d=NULL;
   EDT_BUT_S     * b;
   int           x1, x2, y1, y2, x, y, d, line, bg_color, c, i, size;
   char          * minus_tmp, tmp[150];


   size = glb_ds1edit.obj_buff->col[misc_get_txt_column_num(RQ_OBJ, "Description")].size + 1;
   minus_tmp = (char *) malloc(size);
   if (minus_tmp == NULL) {
       FATAL_EXIT("editobj_draw_edit_obj() : can't allocate %i bytes", size);
   }

   x1 = ptr_w->x0;
   y1 = ptr_w->y0;
   x2 = x1 + ptr_w->w;
   y2 = y1 + ptr_w->h;
   rectfill(glb_ds1edit.screen_buff, x1, y1, x2, y2, 0);
   rect    (glb_ds1edit.screen_buff, x1, y1, x2, y2, 255);
   
   for (i=0; i < EB_MAX; i++)
   {
      b  = & ptr_w->button[i];
      x1 = b->box.x1;
      y1 = b->box.y1;
      x2 = b->box.x2;
      y2 = b->box.y2;
      x  = b->txt.x;
      y  = b->txt.y;
      if (IS_ACTIVATED(b->flags))
      {
         rect(glb_ds1edit.screen_buff, x1, y1, x2, y2, 129);
         if (IS_SELECTED(b->flags))
         {
            rectfill(glb_ds1edit.screen_buff, x1+2, y1+2, x2-2, y2-2, 116);
            textprintf(glb_ds1edit.screen_buff, font, x+1, y + 1, 0, b->name);
         }
         textprintf(glb_ds1edit.screen_buff, font, x, y, 132, b->name);
      } else {
         rect(glb_ds1edit.screen_buff, x1, y1, x2, y2, 186);
         if (IS_SELECTED(b->flags))
         {
            rectfill(glb_ds1edit.screen_buff, x1+2, y1+2, x2-2, y2-2, 209);
            textprintf(glb_ds1edit.screen_buff, font, x+1, y + 1, 0, b->name);
         }
         textprintf(glb_ds1edit.screen_buff, font, x, y, 214, b->name);
      }
   }

   x1 = ptr_w->x0 + (8 * 2);
   y1 = ptr_w->y0 + 69;
   textprintf(glb_ds1edit.screen_buff, font, x1, y1, 11, "Type");
   
   x1 += 8 * 5;
   textprintf(glb_ds1edit.screen_buff, font, x1, y1, 255, " Id");
   x1 += 8 * 4;
   textprintf(glb_ds1edit.screen_buff, font, x1, y1, 255, " Description");

   x1 = ptr_w->x0 + (8 * 2);
   y1 += 10;
   textprintf(glb_ds1edit.screen_buff, font, x1, y1, 210, "---- ---  -----------");

   strcpy(minus_tmp, "");
   for (c=0; c < ptr_w->desc_char - 11; c++)
      strcat(minus_tmp, "-");
   x1 += 20 * 8;
   textprintf(glb_ds1edit.screen_buff, font, x1, y1, 210, "%s", minus_tmp);

   // desc themselves
   for (line=0; line < ptr_w->num; line++)
   {
      x1  = ptr_w->x0 + (8 * 2);
      y1 += 10;
      d   = ptr_w->start + line;
      if ( (d >= 0) && (d < glb_ds1edit.obj_desc_num) &&
           (d >= ptr_w->desc_start) && (d <= ptr_w->desc_end)
         )
      {
         if (d == ptr_w->desc_cur)
            bg_color = 121;
         else if (d == ptr_w->cur)
            bg_color = 71;
         else if (line % 2)
            bg_color = 1;
         else
            bg_color = 0;
         if (bg_color)
            rectfill(glb_ds1edit.screen_buff, ptr_w->x0+8, y1-1, ptr_w->x0 + ptr_w->w - 8, y1+8, bg_color);

         ptr_d = & glb_ds1edit.obj_desc[d];

         textprintf(glb_ds1edit.screen_buff, font, x1, y1, 11, "%3i", ptr_d->type);
         x1 += 8 * 5;
         textprintf(glb_ds1edit.screen_buff, font, x1, y1, 255, "%3i", ptr_d->id);
         x1 += 8 * 4;
         textprintf(glb_ds1edit.screen_buff, font, x1, y1, 255, " %s", ptr_d->desc);
      }
   }
   x1 = ptr_w->x0 + (8 * 2);
   y1 += 25;
   textprintf(glb_ds1edit.screen_buff, font, x1, y1, 214, "(scroll down here)");

   free(minus_tmp);
}


// ==========================================================================
// handler of the objects list window
int editobj_edit_obj(int ds1_idx, int * edit_end, int mx, int my, int mb)
{
   WIN_EDT_OBJ_S * ptr_w = & glb_ds1[ds1_idx].win_edt_obj;
   int           redraw = FALSE, new_cur, end, w, wtmp;
   

   * edit_end = FALSE;
   
   // managment
   if ((mx >= ptr_w->button[EB_OK].box.x1) &&
       (mx <= ptr_w->button[EB_OK].box.x2) &&
       (my >= ptr_w->button[EB_OK].box.y1) &&
       (my <= ptr_w->button[EB_OK].box.y2)
      )
   {
      // over OK button
      if (mb & 1)
      {
         glb_ds1[ds1_idx].draw_edit_obj = FALSE;
         redraw = TRUE;
         * edit_end = TRUE;
         glb_ds1[ds1_idx].obj[ptr_w->obj_idx].type     = glb_ds1edit.obj_desc[ptr_w->desc_cur].type;
         glb_ds1[ds1_idx].obj[ptr_w->obj_idx].id       = glb_ds1edit.obj_desc[ptr_w->desc_cur].id;
         glb_ds1[ds1_idx].obj[ptr_w->obj_idx].desc_idx = ptr_w->desc_cur;
         editobj_make_obj_new_id(ds1_idx, ptr_w->obj_idx);
         w = 16 * 8; // 15 chars
         if (ptr_w->desc_cur != -1)
         {
            wtmp = 8 * strlen(glb_ds1edit.obj_desc[ptr_w->desc_cur].desc);
            if (wtmp > w)
               w = wtmp;
         }
         glb_ds1[ds1_idx].obj[ptr_w->obj_idx].label.w = w;
      }
   }
   else if (key[KEY_ENTER] || key[KEY_ENTER_PAD])
   {
      // simulate the click on the OK button
      while (key[KEY_ENTER] || key[KEY_ENTER_PAD])
      {}
      glb_ds1[ds1_idx].draw_edit_obj = FALSE;
      redraw = TRUE;
      * edit_end = TRUE;
      glb_ds1[ds1_idx].obj[ptr_w->obj_idx].type     = glb_ds1edit.obj_desc[ptr_w->desc_cur].type;
      glb_ds1[ds1_idx].obj[ptr_w->obj_idx].id       = glb_ds1edit.obj_desc[ptr_w->desc_cur].id;
      glb_ds1[ds1_idx].obj[ptr_w->obj_idx].desc_idx = ptr_w->desc_cur;
      editobj_make_obj_new_id(ds1_idx, ptr_w->obj_idx);
      w = 16 * 8; // 15 chars
      if (ptr_w->desc_cur != -1)
      {
         wtmp = 8 * strlen(glb_ds1edit.obj_desc[ptr_w->desc_cur].desc);
         if (wtmp > w)
            w = wtmp;
      }
      glb_ds1[ds1_idx].obj[ptr_w->obj_idx].label.w = w;
   }
   else if ((glb_config.winobj_scroll_keyb == FALSE) && key[KEY_UP])
   {
      // scroll the list, up
      ptr_w->start -= glb_config.scroll.obj_edit;
      if (ptr_w->start < ptr_w->desc_start)
         ptr_w->start = ptr_w->desc_start;
      ptr_w->cur = -1;
      redraw = TRUE;
   }
   else if ((glb_config.winobj_scroll_keyb == FALSE) && key[KEY_DOWN])
   {
      // scroll the list, down
      ptr_w->start += glb_config.scroll.obj_edit;
      if ( (ptr_w->start + ptr_w->num - 1) > ptr_w->desc_end)
         ptr_w->start = ptr_w->desc_end - ptr_w->num + 1;
      if (ptr_w->start < ptr_w->desc_start)
         ptr_w->start = ptr_w->desc_start;
      ptr_w->cur = -1;
      redraw = TRUE;
   }
   else if ((mx >= ptr_w->button[EB_CANCEL].box.x1) &&
            (mx <= ptr_w->button[EB_CANCEL].box.x2) &&
            (my >= ptr_w->button[EB_CANCEL].box.y1) &&
            (my <= ptr_w->button[EB_CANCEL].box.y2)
           )
   {
      // over CANCEL button
      if (mb & 1)
      {
         glb_ds1[ds1_idx].draw_edit_obj = FALSE;
         redraw = TRUE;
         * edit_end = TRUE;
      }
   }
   else if ((mx >= ptr_w->button[EB_TYPE1].box.x1) &&
            (mx <= ptr_w->button[EB_TYPE1].box.x2) &&
            (my >= ptr_w->button[EB_TYPE1].box.y1) &&
            (my <= ptr_w->button[EB_TYPE1].box.y2)
           )
   {
      // over TYPE1 button
      if (mb & 1)
      {
         while (mouse_b & 1)
         {
            // wait until the left mouse button is released
         }
         if (ptr_w->cur_type != 1)
            ptr_w->cur_act  = glb_ds1[ds1_idx].act;
         ptr_w->cur_type = 1;
         editobj_prepare_edit_obj_win(ds1_idx, ptr_w->obj_idx);
         redraw = TRUE;
      }
   }
   else if ((mx >= ptr_w->button[EB_TYPE2].box.x1) &&
            (mx <= ptr_w->button[EB_TYPE2].box.x2) &&
            (my >= ptr_w->button[EB_TYPE2].box.y1) &&
            (my <= ptr_w->button[EB_TYPE2].box.y2)
           )
   {
      // over TYPE2 button
      if (mb & 1)
      {
         while (mouse_b & 1)
         {
            // wait until the left mouse button is released
         }
         ptr_w->cur_type = 2;
         ptr_w->cur_act  = glb_ds1[ds1_idx].act;
         editobj_prepare_edit_obj_win(ds1_idx, ptr_w->obj_idx);
         redraw = TRUE;
      }
   }
   else if ((mx >= ptr_w->button[EB_ACT1].box.x1) &&
            (mx <= ptr_w->button[EB_ACT1].box.x2) &&
            (my >= ptr_w->button[EB_ACT1].box.y1) &&
            (my <= ptr_w->button[EB_ACT1].box.y2)
           )
   {
      // over ACT1 button
      if ((mb & 1) && (IS_ACTIVATED(ptr_w->button[EB_ACT1].flags)))
      {
         while (mouse_b & 1)
         {
            // wait until the left mouse button is released
         }
         ptr_w->cur_act = 1;
         editobj_prepare_edit_obj_win(ds1_idx, ptr_w->obj_idx);
         redraw = TRUE;
      }
   }
   else if ((mx >= ptr_w->button[EB_ACT2].box.x1) &&
            (mx <= ptr_w->button[EB_ACT2].box.x2) &&
            (my >= ptr_w->button[EB_ACT2].box.y1) &&
            (my <= ptr_w->button[EB_ACT2].box.y2)
           )
   {
      // over ACT2 button
      if ((mb & 1) && (IS_ACTIVATED(ptr_w->button[EB_ACT2].flags)))
      {
         while (mouse_b & 1)
         {
            // wait until the left mouse button is released
         }
         ptr_w->cur_act = 2;
         editobj_prepare_edit_obj_win(ds1_idx, ptr_w->obj_idx);
         redraw = TRUE;
      }
   }
   else if ((mx >= ptr_w->button[EB_ACT3].box.x1) &&
            (mx <= ptr_w->button[EB_ACT3].box.x2) &&
            (my >= ptr_w->button[EB_ACT3].box.y1) &&
            (my <= ptr_w->button[EB_ACT3].box.y2)
           )
   {
      // over ACT3 button
      if ((mb & 1) && (IS_ACTIVATED(ptr_w->button[EB_ACT3].flags)))
      {
         while (mouse_b & 1)
         {
            // wait until the left mouse button is released
         }
         ptr_w->cur_act = 3;
         editobj_prepare_edit_obj_win(ds1_idx, ptr_w->obj_idx);
         redraw = TRUE;
      }
   }
   else if ((mx >= ptr_w->button[EB_ACT4].box.x1) &&
            (mx <= ptr_w->button[EB_ACT4].box.x2) &&
            (my >= ptr_w->button[EB_ACT4].box.y1) &&
            (my <= ptr_w->button[EB_ACT4].box.y2)
           )
   {
      // over ACT4 button
      if ((mb & 1) && (IS_ACTIVATED(ptr_w->button[EB_ACT4].flags)))
      {
         while (mouse_b & 1)
         {
            // wait until the left mouse button is released
         }
         ptr_w->cur_act = 4;
         editobj_prepare_edit_obj_win(ds1_idx, ptr_w->obj_idx);
         redraw = TRUE;
      }
   }
   else if ((mx >= ptr_w->button[EB_ACT5].box.x1) &&
            (mx <= ptr_w->button[EB_ACT5].box.x2) &&
            (my >= ptr_w->button[EB_ACT5].box.y1) &&
            (my <= ptr_w->button[EB_ACT5].box.y2)
           )
   {
      // over ACT5 button
      if ((mb & 1) && (IS_ACTIVATED(ptr_w->button[EB_ACT5].flags)))
      {
         while (mouse_b & 1)
         {
            // wait until the left mouse button is released
         }
         ptr_w->cur_act = 5;
         editobj_prepare_edit_obj_win(ds1_idx, ptr_w->obj_idx);
         redraw = TRUE;
      }
   }
   else
   {
      new_cur  = (my - ptr_w->y0 - 69 - (2 * 10)) / 10;
      new_cur += ptr_w->start;
      if ( (mx >= ptr_w->x0) && (mx < (ptr_w->x0 + ptr_w->w)) &&
           (my >= ptr_w->x0) && (my < (ptr_w->y0 + ptr_w->h))
         )
      {
         // mouse in the window

         end = ptr_w->start + ptr_w->num - 1;
         if ((new_cur < ptr_w->start) && (ptr_w->start > ptr_w->desc_start))
         {
            // scroll the list, up
            ptr_w->start -= glb_config.scroll.obj_edit;
            if (ptr_w->start < ptr_w->desc_start)
               ptr_w->start = ptr_w->desc_start;
            ptr_w->cur = -1;
            redraw = TRUE;
         }
         else if ((new_cur > end) && (end < ptr_w->desc_end))
         {
            // scroll the list, down
            ptr_w->start += glb_config.scroll.obj_edit;
            if ( (ptr_w->start + ptr_w->num - 1) > ptr_w->desc_end)
               ptr_w->start = ptr_w->desc_end - ptr_w->num + 1;
            if (ptr_w->start < ptr_w->desc_start)
               ptr_w->start = ptr_w->desc_start;
            ptr_w->cur = -1;
            redraw = TRUE;
         }
         else
         {
            // mouse in the list

            if (new_cur != ptr_w->cur)
            {
               // NEW row pointed by mouse
               ptr_w->cur = new_cur;
               redraw = TRUE;
            }

            if (mb & 1)
            {
               if ( (new_cur != ptr_w->desc_cur)   &&
                    (new_cur >= ptr_w->desc_start) &&
                    (new_cur <= ptr_w->desc_end)
                  )
               {
                  // NEW selected row
                  ptr_w->desc_cur = new_cur;
                  redraw = TRUE;
               }
            }
         }
      }
      else
      {
         // mouse out of the window
         if (ptr_w->cur != -1)
         {
            ptr_w->cur = -1;
            redraw = TRUE;
         }
      }
   }

   return redraw;
}


// ==========================================================================
// make a NEW selection of all same object
// return TRUE if at least 1 object has been added
// (it assume not even 1 object is already selected)
void editobj_identical_obj_new(int ds1_idx, int o)
{
   int i;


   // for all objects of that ds1
   for (i=0; i < glb_ds1[ds1_idx].obj_num; i++)
   {
      // same object ?
      if (glb_ds1[ds1_idx].obj[i].desc_idx == glb_ds1[ds1_idx].obj[o].desc_idx)
      {
         // yep, select it
         SET_SELECTED(glb_ds1[ds1_idx].obj[i].flags);
      }
   }
}


// ==========================================================================
// add all same object to the selection
// return TRUE if at least 1 object has been added
int editobj_identical_obj_add(int ds1_idx, int o)
{
   int need_redraw = FALSE, i;
   

   // for all objects of that ds1
   for (i=0; i < glb_ds1[ds1_idx].obj_num; i++)
   {
      // same object ?
      if (glb_ds1[ds1_idx].obj[i].desc_idx == glb_ds1[ds1_idx].obj[o].desc_idx)
      {
         // yep, same object. already selected ?
         if ( ! IS_SELECTED(glb_ds1[ds1_idx].obj[i].flags))
         {
            // no, add it
            SET_SELECTED(glb_ds1[ds1_idx].obj[i].flags);
            need_redraw = TRUE;
         }
      }
   }
   return need_redraw;
}


// ==========================================================================
// delete all same object from the selection
// return TRUE if at least 1 object has been deleted from the selection
int editobj_identical_obj_del(int ds1_idx, int o)
{
   int need_redraw = FALSE, i;


   // for all objects of that ds1
   for (i=0; i < glb_ds1[ds1_idx].obj_num; i++)
   {
      // same object ?
      if (glb_ds1[ds1_idx].obj[i].desc_idx == glb_ds1[ds1_idx].obj[o].desc_idx)
      {
         // yep, same object. already selected ?
         if (IS_SELECTED(glb_ds1[ds1_idx].obj[i].flags))
         {
            // yes, remove it
            DEL_SELECTED(glb_ds1[ds1_idx].obj[i].flags);
            need_redraw = TRUE;
         }
      }
   }
   return need_redraw;
}


// ==========================================================================
// make a NEW selection of all same labels
// return TRUE if at least 1 label has been added
// (it assume not even 1 label is already selected)
void editobj_identical_lab_new(int ds1_idx, int o)
{
   int i;


   // for all objects of that ds1
   for (i=0; i < glb_ds1[ds1_idx].obj_num; i++)
   {
      // same object ?
      if (glb_ds1[ds1_idx].obj[i].desc_idx == glb_ds1[ds1_idx].obj[o].desc_idx)
      {
         // yep, select it
         SET_SELECTED(glb_ds1[ds1_idx].obj[i].label.flags);
      }
   }
}


// ==========================================================================
// add all same labels to the selection
// return TRUE if at least 1 lbel has been added
int editobj_identical_lab_add(int ds1_idx, int o)
{
   int need_redraw = FALSE, i;
   

   // for all objects of that ds1
   for (i=0; i < glb_ds1[ds1_idx].obj_num; i++)
   {
      // same object ?
      if (glb_ds1[ds1_idx].obj[i].desc_idx == glb_ds1[ds1_idx].obj[o].desc_idx)
      {
         // yep, same object. label already selected ?
         if ( ! IS_SELECTED(glb_ds1[ds1_idx].obj[i].label.flags))
         {
            // no, add it
            SET_SELECTED(glb_ds1[ds1_idx].obj[i].label.flags);
            need_redraw = TRUE;
         }
      }
   }
   return need_redraw;
}


// ==========================================================================
// delete all same labels from the selection
// return TRUE if at least 1 label has been deleted from the selection
int editobj_identical_lab_del(int ds1_idx, int o)
{
   int need_redraw = FALSE, i;


   // for all objects of that ds1
   for (i=0; i < glb_ds1[ds1_idx].obj_num; i++)
   {
      // same object ?
      if (glb_ds1[ds1_idx].obj[i].desc_idx == glb_ds1[ds1_idx].obj[o].desc_idx)
      {
         // yep, same object. label already selected ?
         if (IS_SELECTED(glb_ds1[ds1_idx].obj[i].label.flags))
         {
            // yes, remove it
            DEL_SELECTED(glb_ds1[ds1_idx].obj[i].label.flags);
            need_redraw = TRUE;
         }
      }
   }
   return need_redraw;
}


// ==========================================================================
// MAIN objects & labels edition handler
int editobj_handler(int ds1_idx, int cx, int cy, int mx, int my, int mb)
{
   static int  old_ds1_idx = -1, old_t, old_o, cur_type;
   static enum {OM_NONE, OM_NEW, OM_ADD, OM_DEL, OM_MOV, OM_EDT, OM_INS} old_mode;
   int         t=0, o=0, redraw = FALSE;
   static int  start_cx, start_cy, start_mx, start_my;
   int         dif_cx=0, dif_cy=0, dif_mx=0, dif_my=0;
   int         hm = glb_ds1[ds1_idx].height_mul;
   int         hd = glb_ds1[ds1_idx].height_div;
   int         edit_end=0;
   int         i;
   static struct // environment backup : this function is for several ds1
   {
      int old_t, old_o, cur_type;
      int old_mode;
      int t, o;
      int start_cx, start_cy, start_mx, start_my;
      int dif_cx, dif_cy, dif_mx, dif_my;
      int edit_end;
   } backup[DS1_MAX];


   // environement managment
   if (ds1_idx != old_ds1_idx)
   {
      // init the backup datas, the very first time
      if (old_ds1_idx == -1)
      {
         for (i=0; i<DS1_MAX; i++)
         {
            backup[i].old_t    = -1;
            backup[i].old_o    = -1;
            backup[i].cur_type = 0;
            backup[i].old_mode = OM_NONE;
         }
         t = o = dif_cx = dif_cy = dif_mx = dif_my = edit_end = -1;
      }
      
      // backup the current environment for the previous ds1
      if (old_ds1_idx != -1)
      {
         backup[old_ds1_idx].old_t    = old_t;
         backup[old_ds1_idx].old_o    = old_o;
         backup[old_ds1_idx].cur_type = cur_type;
         backup[old_ds1_idx].old_mode = old_mode;
         backup[old_ds1_idx].t        = t;
         backup[old_ds1_idx].o        = o;
         backup[old_ds1_idx].start_cx = start_cx;
         backup[old_ds1_idx].start_cy = start_cy;
         backup[old_ds1_idx].start_mx = start_mx;
         backup[old_ds1_idx].start_my = start_my;
         backup[old_ds1_idx].dif_cx   = dif_cx;
         backup[old_ds1_idx].dif_cy   = dif_cy;
         backup[old_ds1_idx].dif_mx   = dif_mx;
         backup[old_ds1_idx].dif_my   = dif_my;
         backup[old_ds1_idx].edit_end = edit_end;
      }

      // restore the previous environement of the current ds1
      old_t    = backup[ds1_idx].old_t;
      old_o    = backup[ds1_idx].old_o;
      cur_type = backup[ds1_idx].cur_type;
      old_mode = backup[ds1_idx].old_mode;
      t        = backup[ds1_idx].t;
      o        = backup[ds1_idx].o;
      start_cx = backup[ds1_idx].start_cx;
      start_cy = backup[ds1_idx].start_cy;
      start_mx = backup[ds1_idx].start_mx;
      start_my = backup[ds1_idx].start_my;
      dif_cx   = backup[ds1_idx].dif_cx;
      dif_cy   = backup[ds1_idx].dif_cy;
      dif_mx   = backup[ds1_idx].dif_mx;
      dif_my   = backup[ds1_idx].dif_my;
      edit_end = backup[ds1_idx].edit_end;
      
      // done
      old_ds1_idx = ds1_idx;
   }
   
   if (old_mode == OM_EDT)
   {
      // handler of objects Type-Id edition
      if (editobj_edit_obj(ds1_idx, & edit_end, mx, my, mb))
         redraw = TRUE;

      if (edit_end)
      {
         old_mode = OM_NONE;
         while (mouse_b & 1)
         {
            // wait until the left mouse button is released
         }
         anim_update_gfx(FALSE);
      }
   }
   else if (old_mode != OM_MOV)
   {
      // NOT moving obj or label
      
      if (editobj_over_obj_lab(ds1_idx, & t, & o, cx, cy, mx, my))
         redraw = TRUE;

      if (mb & 1)
      {
         // button 1 pressed (& not moving obj or label)

         if (key[KEY_ALT] || key[KEY_ALTGR])
         {
            if (o != -1)
            {
               // moving objects / labels
               start_cx = cx;
               start_cy = cy;
               start_mx = (mx + glb_ds1edit.win_preview.x0) * hd / hm;
               start_my = (my + glb_ds1edit.win_preview.y0) * hd / hm;

               if ((cur_type == 1) && (t == 1))
               {
                  if (IS_SELECTED(glb_ds1[ds1_idx].obj[o].label.flags))
                  {
                     editobj_prepare_undo(ds1_idx);
                     editobj_prepare_moving(ds1_idx);
                     old_mode = OM_MOV;
                     while (mouse_b & 1)
                     {
                        // wait until the left mouse button is released
                     }
                  }
               }
               else if ((cur_type == 2) && (t == 2))
               {
                  if (IS_SELECTED(glb_ds1[ds1_idx].obj[o].flags))
                  {
                     editobj_prepare_undo(ds1_idx);
                     editobj_prepare_moving(ds1_idx);
                     old_mode = OM_MOV;
                     while (mouse_b & 1)
                     {
                        // wait until the left mouse button is released
                     }
                  }
               }
            }
         }
         else if (key[KEY_LSHIFT] || key[KEY_RSHIFT])
         {
            // add to selection
            if ((cur_type == 0) || (t == cur_type))
            {
               cur_type = t;
               if (o != -1)
               {
                  if (t == 1)
                  {
                     // add all identical labels ?
                     if (key[KEY_I])
                     {
                        // add all same labels to the selection
                        if (editobj_identical_lab_add(ds1_idx, o))
                        {
                           // at least 1 label added
                           redraw = TRUE;
                           old_mode = OM_ADD;
                           old_o = o;
                           old_t = t;
                        }
                     }
                     else if ( ! IS_SELECTED(glb_ds1[ds1_idx].obj[o].label.flags))
                     {
                        SET_SELECTED(glb_ds1[ds1_idx].obj[o].label.flags);
                        redraw = TRUE;
                        old_mode = OM_ADD;
                        old_o = o;
                        old_t = t;
                     }
                  }
                  else
                  {
                     // add all identical objects ?
                     if (key[KEY_I])
                     {
                        // add all same object to the selection
                        if (editobj_identical_obj_add(ds1_idx, o))
                        {
                           // at least 1 object added
                           redraw = TRUE;
                           old_mode = OM_ADD;
                           old_o = o;
                           old_t = t;
                        }
                     }
                     else if ( ! IS_SELECTED(glb_ds1[ds1_idx].obj[o].flags))
                     {
                        SET_SELECTED(glb_ds1[ds1_idx].obj[o].flags);
                        redraw = TRUE;
                        old_mode = OM_ADD;
                        old_o = o;
                        old_t = t;
                     }
                  }
               }
            }
         }
         else if (key[KEY_LCONTROL] || key[KEY_RCONTROL])
         {
            // remove from selection
            if (o != -1)
            {
               if ((old_t == 1) && (t == 1))
               {
                  // delete all identical labels from the selection ?
                  if (key[KEY_I])
                  {
                     // delete all same labels from the selection
                     if (editobj_identical_lab_del(ds1_idx, o))
                     {
                        // at least 1 object deleted
                        redraw   = TRUE;
                        old_o    = o;
                        old_mode = OM_DEL;
                     }
                  }
                  else if (IS_SELECTED(glb_ds1[ds1_idx].obj[o].label.flags))
                  {
                     DEL_SELECTED(glb_ds1[ds1_idx].obj[o].label.flags);
                     redraw   = TRUE;
                     old_o    = o;
                     old_mode = OM_DEL;
                  }
               }
               else if ((old_t == 2) && (t == 2))
               {
                  // delete all identical objects from the selection ?
                  if (key[KEY_I])
                  {
                     // delete all same object from the selection
                     if (editobj_identical_obj_del(ds1_idx, o))
                     {
                        // at least 1 object deleted
                        redraw   = TRUE;
                        old_o    = o;
                        old_mode = OM_DEL;
                     }
                  }
                  else if (IS_SELECTED(glb_ds1[ds1_idx].obj[o].flags))
                  {
                     DEL_SELECTED(glb_ds1[ds1_idx].obj[o].flags);
                     redraw   = TRUE;
                     old_o    = o;
                     old_mode = OM_DEL;
                  }
               }
            }
         }
         else
         {
            // new selection

            if ((old_o != o) || (old_t != t) || (old_mode != OM_NEW))
            {
               old_t    = t;
               cur_type = t;
               old_o    = o;
               old_mode = OM_NEW;
               redraw   = TRUE;
               editobj_clear_obj_lab_sel(ds1_idx);
               if (o != -1)
               {
                  if (t == 1)
                  {
                     // select all identical labels to make a new selection ?
                     if (key[KEY_I])
                        editobj_identical_lab_new(ds1_idx, o);
                     else
                     {
                        // select just 1 object
                        SET_SELECTED(glb_ds1[ds1_idx].obj[o].label.flags);
                     }
                  }
                  else
                  {
                     // select all identical objects to make a new selection ?
                     if (key[KEY_I])
                     {
                        // yep
                        editobj_identical_obj_new(ds1_idx, o);
                     }
                     else
                     {
                        // select just 1 object
                        SET_SELECTED(glb_ds1[ds1_idx].obj[o].flags);
                     }
                  }
               }
               else
                  cur_type = 0;
            }
         }

         // update object index for path editing mode
         editpath_search_selected_obj(ds1_idx);
      }
      else if (mb & 2)
      {
         if (o != -1)
         {
            // button 2 pressed (& not moving obj or label)
            // ---> edit 1 object
            editobj_prepare_undo(ds1_idx);

            if (glb_ds1[ds1_idx].obj[o].desc_idx == -1)
            {
               glb_ds1[ds1_idx].win_edt_obj.start_act =
               glb_ds1[ds1_idx].win_edt_obj.cur_act   =
                  glb_ds1[ds1_idx].act;

               glb_ds1[ds1_idx].win_edt_obj.cur_type  = glb_ds1[ds1_idx].obj[o].type;
            }
            else
            {
               glb_ds1[ds1_idx].win_edt_obj.start_act =
               glb_ds1[ds1_idx].win_edt_obj.cur_act   =
                  glb_ds1edit.obj_desc[glb_ds1[ds1_idx].obj[o].desc_idx].act;

               glb_ds1[ds1_idx].win_edt_obj.cur_type =
                  glb_ds1edit.obj_desc[glb_ds1[ds1_idx].obj[o].desc_idx].type;

            }

            glb_ds1[ds1_idx].win_edt_obj.desc_cur = glb_ds1[ds1_idx].obj[o].desc_idx;
            
            editobj_prepare_edit_obj_win(ds1_idx, o);
            old_mode = OM_EDT;

            redraw = TRUE;
         }
      }
      else
      {
         // NO button 1 or 2 pressed (& not moving obj nor label)

         if (key[KEY_DEL] || key[KEY_DEL_PAD])
         {
            // delete objects
            while (key[KEY_DEL] || key[KEY_DEL_PAD])
            {
               // wait until both DEL keys are released
            }
            editobj_prepare_undo(ds1_idx);
            editobj_del_obj(ds1_idx);
            redraw = TRUE;
            anim_update_gfx(FALSE);
         }
         else if (key[KEY_U] && (key[KEY_LCONTROL] || key[KEY_RCONTROL]))
         {
            // undo last modification (movement / copy / delete / edit)
            if (glb_ds1[ds1_idx].can_undo_obj)
            {
               while (key[KEY_U])
               {
                  // wait until the 'U' key is released
               }
               editobj_undo(ds1_idx);
               redraw = TRUE;
            }
            anim_update_gfx(FALSE);
         }
         else if (key[KEY_C] && (key[KEY_LCONTROL] || key[KEY_RCONTROL]))
         {
            // copy objects (only if at least 1 obj (no label) is selected)
// TODO
//           if (editobj_center_before_copy(ds1_idx, & cx, & cy, & mx, & my))
//
            if (editobj_count_sel_obj(ds1_idx))
            {
               while (key[KEY_C])
               {
                  // wait until the 'C' key is released
               }
               editobj_prepare_undo(ds1_idx);
               editobj_copy_obj(ds1_idx);
               old_mode = OM_MOV;
               redraw   = TRUE;
               start_cx = cx;
               start_cy = cy;
               start_mx = (mx + glb_ds1edit.win_preview.x0) * hd / hm;
               start_my = (my + glb_ds1edit.win_preview.y0) * hd / hm;
               editobj_prepare_moving(ds1_idx);
            }
         }
         else if (key[KEY_INSERT])
         {
            // create a new object
            while (key[KEY_INSERT])
            {}
            editobj_prepare_undo(ds1_idx);
            editobj_clear_obj_lab_sel(ds1_idx);
            if (editobj_insert_obj(ds1_idx, cx, cy) == 0)
            {
               old_mode = OM_INS;
               redraw = TRUE;
               anim_update_gfx(FALSE);
            }
         }
      }
   }
   else
   {
      // MOVING, obj or label

      if ( ! mb & 1)
      {
         // still moving it
         dif_cx = cx - start_cx;
         dif_cy = cy - start_cy;

         dif_mx = ((mx + glb_ds1edit.win_preview.x0) * hd / hm) - start_mx;
         dif_my = ((my + glb_ds1edit.win_preview.y0) * hd / hm) - start_my;

         if (editobj_moving_obj_lab(ds1_idx, dif_cx, dif_cy, dif_mx, dif_my))
            redraw = TRUE;
      }
      else
      {
         // end the move
         editobj_end_move_obj_lab(ds1_idx);
         old_mode = OM_NONE;
         redraw   = TRUE;
         while (mouse_b & 1)
         {
            // wait until the left mouse button is released
         }
      }
   }

   if (redraw)
      editobj_set_drawing_order(ds1_idx);

   return redraw;
}
#include "structs.h"
#include "editpath.h"
#include "misc.h"


// ==============================================================================
int editpath_mouse_in(int ds1_idx, int mx, int my)
{
   PATH_EDIT_WIN_S * pwin = & glb_ds1[ds1_idx].path_edit_win;

   
   if ( (mx >= pwin->x0) && (mx <= pwin->x0 + pwin->w - 1) &&
        (my >= pwin->y0) && (my <= pwin->y0 + pwin->h - 1))
     return TRUE;
  else
     return FALSE;
}


// ==============================================================================
int editpath_mouse_cmdbut_in(int ds1_idx, int mx, int my)
{
   PATH_EDIT_WIN_S * pwin = & glb_ds1[ds1_idx].path_edit_win;

   
   if ( (mx >= pwin->but_x0) && (mx <= pwin->but_x0 + pwin->but_w - 1) &&
        (my >= pwin->but_y0) && (my <= pwin->but_y0 + pwin->but_h - 1))
     return TRUE;
  else
     return FALSE;
}


// ==============================================================================
void editpath_init(int ds1_idx)
{
   PATH_EDIT_WIN_S * pwin = & glb_ds1[ds1_idx].path_edit_win;
   int             i;


   pwin->but_x0 = 10;
   pwin->but_y0 = 2 * 10;
   pwin->but_w  = 49 * 8;
   pwin->but_h  = 80;

   pwin->x0 = 10;
   pwin->y0 = pwin->but_y0 + pwin->but_h + 10;
   pwin->w  = 23 * 8;
   pwin->h  = glb_config.screen.height - pwin->y0 - 20;

   pwin->c_black     = makecol(  0,   0,   0);
   pwin->c_white     = makecol(255, 255, 255);
   pwin->c_green     = makecol(  0, 255,   0);
   pwin->c_darkgreen = makecol(  0, 128,   0);
   pwin->c_yellow    = makecol(255, 255,   0);
   pwin->c_gray      = makecol(128, 128, 128);
   pwin->c_darkgray  = makecol( 64,  64,  64);

   // OK button
   pwin->button[PEB_OK].show           = FALSE;
   pwin->button[PEB_OK].text           = "OK";
   pwin->button[PEB_OK].text_x0        = 3 * 8 + 1;
   pwin->button[PEB_OK].x0             = 10;
   pwin->button[PEB_OK].y0             = 10;
   pwin->button[PEB_OK].w              = 8 * 8;
   pwin->button[PEB_OK].h              = 20;
   pwin->button[PEB_OK].col_on.fg      = pwin->c_black;
   pwin->button[PEB_OK].col_on.bg      = pwin->c_darkgreen;
   pwin->button[PEB_OK].col_on.border  = pwin->c_white;
   pwin->button[PEB_OK].col_off.fg     = pwin->c_green;
   pwin->button[PEB_OK].col_off.bg     = pwin->c_black;
   pwin->button[PEB_OK].col_off.border = pwin->c_green;

   // CANCEL button
   pwin->button[PEB_CANCEL].show           = FALSE;
   pwin->button[PEB_CANCEL].text           = "CANCEL";
   pwin->button[PEB_CANCEL].text_x0        = 1 * 8 + 1;
   pwin->button[PEB_CANCEL].x0             = 80;
   pwin->button[PEB_CANCEL].y0             = 10;
   pwin->button[PEB_CANCEL].w              = 8 * 8;
   pwin->button[PEB_CANCEL].h              = 20;
   pwin->button[PEB_CANCEL].col_on.fg      = pwin->c_black;
   pwin->button[PEB_CANCEL].col_on.bg      = pwin->c_darkgreen;
   pwin->button[PEB_CANCEL].col_on.border  = pwin->c_white;
   pwin->button[PEB_CANCEL].col_off.fg     = pwin->c_green;
   pwin->button[PEB_CANCEL].col_off.bg     = pwin->c_black;
   pwin->button[PEB_CANCEL].col_off.border = pwin->c_green;

   // ALLNEW button
   pwin->button[PEB_ALLNEW].show           = TRUE;
   pwin->button[PEB_ALLNEW].text           = "ALL NEW";
   pwin->button[PEB_ALLNEW].text_x0        = 1 * 8 + 1;
   pwin->button[PEB_ALLNEW].x0             = 10;
   pwin->button[PEB_ALLNEW].y0             = 50;
   pwin->button[PEB_ALLNEW].w              = 9 * 8;
   pwin->button[PEB_ALLNEW].h              = 20;
   pwin->button[PEB_ALLNEW].col_on.fg      = pwin->c_black;
   pwin->button[PEB_ALLNEW].col_on.bg      = pwin->c_darkgreen;
   pwin->button[PEB_ALLNEW].col_on.border  = pwin->c_white;
   pwin->button[PEB_ALLNEW].col_off.fg     = pwin->c_green;
   pwin->button[PEB_ALLNEW].col_off.bg     = pwin->c_black;
   pwin->button[PEB_ALLNEW].col_off.border = pwin->c_green;

   // STOP button
   pwin->button[PEB_STOP].show           = FALSE;
   pwin->button[PEB_STOP].text           = "STOP";
   pwin->button[PEB_STOP].text_x0        = 2 * 8 + 5;
   pwin->button[PEB_STOP].x0             = 10;
   pwin->button[PEB_STOP].y0             = 50;
   pwin->button[PEB_STOP].w              = 9 * 8;
   pwin->button[PEB_STOP].h              = 20;
   pwin->button[PEB_STOP].col_on.fg      = pwin->c_black;
   pwin->button[PEB_STOP].col_on.bg      = pwin->c_darkgreen;
   pwin->button[PEB_STOP].col_on.border  = pwin->c_white;
   pwin->button[PEB_STOP].col_off.fg     = pwin->c_green;
   pwin->button[PEB_STOP].col_off.bg     = pwin->c_black;
   pwin->button[PEB_STOP].col_off.border = pwin->c_green;

   // SETACTION button
   pwin->button[PEB_SETACTION].show           = TRUE;
   pwin->button[PEB_SETACTION].text           = "(Enter) SET ACTION";
   pwin->button[PEB_SETACTION].text_x0        = 1 * 8 + 1;
   pwin->button[PEB_SETACTION].x0             = 160;
   pwin->button[PEB_SETACTION].y0             = 50;
   pwin->button[PEB_SETACTION].w              = 20 * 8 + 1;
   pwin->button[PEB_SETACTION].h              = 20;
   pwin->button[PEB_SETACTION].col_on.fg      = pwin->c_black;
   pwin->button[PEB_SETACTION].col_on.bg      = pwin->c_darkgreen;
   pwin->button[PEB_SETACTION].col_on.border  = pwin->c_white;
   pwin->button[PEB_SETACTION].col_off.fg     = pwin->c_green;
   pwin->button[PEB_SETACTION].col_off.bg     = pwin->c_black;
   pwin->button[PEB_SETACTION].col_off.border = pwin->c_green;

   if (pwin->obj_idx == -1)
   {
      for (i=0; i < PEB_MAX; i++)
      {
         if (i != PEB_SETACTION)
            pwin->button[i].show = FALSE;
      }
   }

   pwin->curr_action = 1;
}


// ==============================================================================
void editpath_search_selected_obj(int ds1_idx)
{
   PATH_EDIT_WIN_S * pwin  = & glb_ds1[ds1_idx].path_edit_win;
   OBJ_S           * pobj  = NULL;
   int             o, nb=0, new_obj_idx=0, i;


   if (glb_ds1[ds1_idx].path_edit_win.obj_dirty != FALSE)
      return;

   for (o=0; o < glb_ds1[ds1_idx].obj_num; o++)
   {
      pobj = & glb_ds1[ds1_idx].obj[o];
      if (IS_SELECTED(pobj->flags) || IS_SELECTED(pobj->label.flags))
      {
         nb++;
         new_obj_idx = o;
      }
   }
   if (nb == 1)
   {
      if (pwin->obj_idx != new_obj_idx)
      {
         pwin->obj_idx = new_obj_idx;
         pobj          = & glb_ds1[ds1_idx].obj[new_obj_idx];
         for (i=0; i < WINDS1EDIT_PATH_MAX; i++)
         {
            pwin->path_copy[i].x      = pobj->path[i].x;
            pwin->path_copy[i].y      = pobj->path[i].y;
            pwin->path_copy[i].action = pobj->path[i].action;
         }
         pwin->path_copy_num = pobj->path_num;
      }

      // activate the ALLNEW button
      pwin->button[PEB_ALLNEW].show = TRUE;
   }
   else
   {
      pwin->obj_idx = -1;
      for (i=0; i < PEB_MAX; i++)
      {
         if (i != PEB_SETACTION)
            pwin->button[i].show = FALSE;
      }
   }
}


// ==============================================================================
void editpath_enter_action(int ds1_idx, long * paction)
{
   PATH_EDIT_WIN_S * pwin  = & glb_ds1[ds1_idx].path_edit_win;
   int             x1, y1, w, h, x2, y2,
                   tx1, ty1, tx2, ty2, tw, th,
                   done, add_x, nb_char;
   BITMAP          * bmp;
   long            lvalue = 0;
   char            svalue[30];


   // show_mouse(NULL);

   w  = 200;
   h  = 80;
   x1 = (glb_config.screen.width  - w) / 2;
   y1 = (glb_config.screen.height - h) / 2;
   x2 = x1 + w - 1;
   y2 = y1 + h - 1;

   tw  = 11 * 8 + 4;
   th  = 16;
   tx1 = x1 + (w  - tw) / 2;
   ty1 = y1 + 40;
   tx2 = tx1 + tw - 1;
   ty2 = ty1 + th - 1;

   //nb_char = strlen(ltoa(lvalue, svalue, 10));
   sprintf( svalue, "%ld",lvalue );
   nb_char = strlen(svalue);
   
   // copy background
   bmp = create_bitmap(w, h);
   blit(glb_ds1edit.screen_buff, bmp, x1, y1, 0, 0, w, h);

   // draw window
   rectfill(glb_ds1edit.screen_buff, x1, y1, x2, y2, pwin->c_black);
   rect(glb_ds1edit.screen_buff, x1, y1, x2, y2, pwin->c_white);

   // draw title
   rectfill(glb_ds1edit.screen_buff, x1, y1, x2, y1 + 18, pwin->c_green);
   textout(glb_ds1edit.screen_buff, font, "Type new ACTION value", x1 + 8, y1+6, pwin->c_black);
   rect(glb_ds1edit.screen_buff, x1, y1, x2, y1 + 18, pwin->c_white);

   // main loop
   done = FALSE;
   while ( ! done)
   {
      if (key[KEY_ENTER] || key[KEY_ENTER_PAD])
      {
         while (key[KEY_ENTER] || key[KEY_ENTER_PAD])
         {}
         done      = TRUE;
         * paction = lvalue;
      }
      else if (key[KEY_ESC])
      {
         while (key[KEY_ESC])
         {}
         done = TRUE;
      }
      else if (key[KEY_MINUS] || key[KEY_MINUS_PAD] || key[KEY_EQUALS])
      {
         while (key[KEY_MINUS] || key[KEY_MINUS_PAD] || key[KEY_EQUALS])
         {}
         lvalue = -lvalue;
      }
      else if ((lvalue >= -99999999) && (lvalue <= 99999999))
      {
         if (key[KEY_1] || key[KEY_1_PAD])
         {
            while (key[KEY_1] || key[KEY_1_PAD])
            {}
            lvalue *= 10;
            if (lvalue < 0)
               lvalue -= 1;
            else
               lvalue += 1;
         }
         else if (key[KEY_2] || key[KEY_2_PAD])
         {
            while (key[KEY_2] || key[KEY_2_PAD])
            {}
            lvalue *= 10;
            if (lvalue < 0)
               lvalue -= 2;
            else
               lvalue += 2;
         }
         else if (key[KEY_3] || key[KEY_3_PAD])
         {
            while (key[KEY_3] || key[KEY_3_PAD])
            {}
            lvalue *= 10;
            if (lvalue < 0)
               lvalue -= 3;
            else
               lvalue += 3;
         }
         else if (key[KEY_4] || key[KEY_4_PAD])
         {
            while (key[KEY_4] || key[KEY_4_PAD])
            {}
            lvalue *= 10;
            if (lvalue < 0)
               lvalue -= 4;
            else
               lvalue += 4;
         }
         else if (key[KEY_5] || key[KEY_5_PAD])
         {
            while (key[KEY_5] || key[KEY_5_PAD])
            {}
            lvalue *= 10;
            if (lvalue < 0)
               lvalue -= 5;
            else
               lvalue += 5;
         }
         else if (key[KEY_6] || key[KEY_6_PAD])
         {
            while (key[KEY_6] || key[KEY_6_PAD])
            {}
            lvalue *= 10;
            if (lvalue < 0)
               lvalue -= 6;
            else
               lvalue += 6;
         }
         else if (key[KEY_7] || key[KEY_7_PAD])
         {
            while (key[KEY_7] || key[KEY_7_PAD])
            {}
            lvalue *= 10;
            if (lvalue < 0)
               lvalue -= 7;
            else
               lvalue += 7;
         }
         else if (key[KEY_8] || key[KEY_8_PAD])
         {
            while (key[KEY_8] || key[KEY_8_PAD])
            {}
            lvalue *= 10;
            if (lvalue < 0)
               lvalue -= 8;
            else
               lvalue += 8;
         }
         else if (key[KEY_9] || key[KEY_9_PAD])
         {
            while (key[KEY_9] || key[KEY_9_PAD])
            {}
            lvalue *= 10;
            if (lvalue < 0)
               lvalue -= 9;
            else
               lvalue += 9;
         }
         else if (key[KEY_0] || key[KEY_0_PAD])
         {
            while (key[KEY_0] || key[KEY_0_PAD])
            {}
            lvalue *= 10;
            if (lvalue < 0)
               lvalue -= 0;
            else
               lvalue += 0;
         }
      }

      // draw user input field

      //nb_char = strlen(ltoa(lvalue, svalue, 10));
      sprintf( svalue, "%ld",lvalue );
      nb_char = strlen(svalue);

      add_x = 2 + (11 - nb_char) * 8;
      rectfill(glb_ds1edit.screen_buff, tx1, ty1, tx2, ty2, pwin->c_darkgray);
      textprintf(glb_ds1edit.screen_buff, font,
         tx1 + add_x,
         ty1 + 4,
         pwin->c_white,
         "%li",
         lvalue
      );

      // draw screen
      if ( ! done)
      {         
         vsync();
         blit(glb_ds1edit.screen_buff, screen, x1, y1, x1, y1, w, h);
      }
   }

   // restore backgpound
   vsync();
   blit(bmp, screen, 0, 0, x1, y1, w, h);

   // show_mouse(screen);
   destroy_bitmap(bmp);
}



// ==============================================================================
void editpath_draw(int ds1_idx, int mx, int my, int mb, long tx, long ty)
{
   PATH_EDIT_WIN_S * pwin  = & glb_ds1[ds1_idx].path_edit_win;
   PATH_EDIT_BUT_S * pbut  = NULL;
   OBJ_S           * pobj  = NULL;
   PATH_S          * ppath = NULL;
   int             x1, y1, x2, y2, i, done, y, xt;

   
   // first init
   if (pwin->w == 0)
      editpath_init(ds1_idx);

   // selected object
   if (pwin->obj_idx != -1)
      pobj = & glb_ds1[ds1_idx].obj[pwin->obj_idx];

   // process the current mode
   if (pwin->mode)
   {
      switch(pwin->mode)
      {
         case PEM_NONE :
            break;

         case PEM_ALLNEW :
            if (mb & 1)
            {
               if (editpath_mouse_cmdbut_in(ds1_idx, mx, my) == FALSE)
               {
                  if (editpath_mouse_in(ds1_idx, mx, my) == FALSE)
                  {
                     // wait until left mouse button is not pressed anymore
                     while (mouse_b & 1)
                     {}
                     mb = 0;

                     // add this sub-tile to the path list of the object
                     if (pobj->path_num < WINDS1EDIT_PATH_MAX)
                     {
                        i = pobj->path_num;
                        pobj->path[i].x      = tx;
                        pobj->path[i].y      = ty;
                        pobj->path[i].action = pwin->curr_action;
                        pobj->path[i].flags  = 0;
                        pobj->path_num++;
                     }
                  }
               }
            }
            break;
      }
   }

   // ---------------------------------
   // draw paths command buttons window
   // ---------------------------------
   x1 = pwin->but_x0;
   y1 = pwin->but_y0;
   x2 = x1 + pwin->but_w;
   y2 = y1 + pwin->but_h;
   rectfill(glb_ds1edit.screen_buff, x1, y1, x2, y2, pwin->c_black);
   if (editpath_mouse_cmdbut_in(ds1_idx, mx, my))
      rect(glb_ds1edit.screen_buff, x1, y1, x2, y2, pwin->c_yellow);
   else
      rect(glb_ds1edit.screen_buff, x1, y1, x2, y2, pwin->c_white);

   // process the command of the left click mouse
   if (mb & 1)
   {
      // wait until no mouse button is pressed anymore
      while (mouse_b & 1)
      {}
      mb = 0;

      // search which button to update
      done = FALSE;
      for (i=0; (i < PEB_MAX) && ! done; i++)
      {
         pbut = & pwin->button[i];

         if (pbut->show != TRUE)
            continue;

         x1 = pwin->but_x0 + pbut->x0;
         y1 = pwin->but_y0 + pbut->y0;
         x2 = x1 + pbut->w;
         y2 = y1 + pbut->h;

         if ((mx >= x1) && (mx <= x2) && (my >= y1) && (my <= y2))
         {
            switch (i)
            {
               case PEB_OK :
                  // keep all datas
                  // copy them into the backup
                  for (i=0; i < WINDS1EDIT_PATH_MAX; i++)
                  {
                     pwin->path_copy[i].x      = pobj->path[i].x;
                     pwin->path_copy[i].y      = pobj->path[i].y;
                     pwin->path_copy[i].action = pobj->path[i].action;
                  }
                  pwin->path_copy_num = pobj->path_num;

                  // update button activation
                  pwin->button[PEB_OK].show     = FALSE;
                  pwin->button[PEB_CANCEL].show = FALSE;
                  pwin->button[PEB_ALLNEW].show = TRUE;
                  pwin->button[PEB_STOP].show   = FALSE;

                  done = TRUE;
                  pwin->mode = PEM_NONE;
                  pwin->obj_dirty = FALSE;
                  break;

               case PEB_CANCEL :
                  // put back the original datas
                  for (i=0; i < WINDS1EDIT_PATH_MAX; i++)
                  {
                     pobj->path[i].x      = pwin->path_copy[i].x;
                     pobj->path[i].y      = pwin->path_copy[i].y;
                     pobj->path[i].action = pwin->path_copy[i].action;
                     pobj->path[i].flags  = 0;
                  }
                  pobj->path_num = pwin->path_copy_num;

                  // update button activation
                  pwin->button[PEB_OK].show     = FALSE;
                  pwin->button[PEB_CANCEL].show = FALSE;
                  pwin->button[PEB_ALLNEW].show = TRUE;
                  pwin->button[PEB_STOP].show   = FALSE;

                  done = TRUE;
                  pwin->mode = PEM_NONE;
                  pwin->obj_dirty = FALSE;
                  break;

               case PEB_ALLNEW :
                  // update button activation
                  pwin->button[PEB_OK].show     = TRUE;
                  pwin->button[PEB_CANCEL].show = TRUE;
                  pwin->button[PEB_ALLNEW].show = FALSE;
                  pwin->button[PEB_STOP].show   = TRUE;

                  done = TRUE;
                  pwin->mode = PEM_ALLNEW;
                  pwin->obj_dirty = TRUE;
                  pobj->path_num = 0;
                  break;

               case PEB_STOP :
                  // update button activation
                  pwin->button[PEB_OK].show     = TRUE;
                  pwin->button[PEB_CANCEL].show = TRUE;
                  pwin->button[PEB_ALLNEW].show = TRUE;
                  pwin->button[PEB_STOP].show   = FALSE;

                  done = TRUE;
                  pwin->mode = PEM_NONE;
                  break;

               case PEB_SETACTION :
                  editpath_enter_action(ds1_idx, & pwin->curr_action);
                  break;
            }
         }
      }
   }

   if (key[KEY_ENTER] || key[KEY_ENTER_PAD])
   {
      while (key[KEY_ENTER] || key[KEY_ENTER_PAD])
      {}
      editpath_enter_action(ds1_idx, & pwin->curr_action);
   }

   // draw action value
   textprintf(glb_ds1edit.screen_buff, font,
      pwin->x0 + 160,
      pwin->x0 + 27,
      pwin->c_gray,
      "Current Action : %li",
      pwin->curr_action
   );

   // draw buttons
   for (i=0; i < PEB_MAX; i++)
   {
      pbut = & pwin->button[i];

      if (pbut->show != TRUE)
         continue;

      x1 = pwin->but_x0 + pbut->x0;
      xt = x1 + pbut->text_x0;
      y1 = pwin->but_y0 + pbut->y0;
      x2 = x1 + pbut->w;
      y2 = y1 + pbut->h;

      if ((mx >= x1) && (mx <= x2) && (my >= y1) && (my <= y2))
      {
         rectfill(glb_ds1edit.screen_buff, x1, y1, x2, y2, pbut->col_on.bg);
         textout(glb_ds1edit.screen_buff, font, pbut->text, xt, y1+7, pbut->col_on.fg);
         rect(glb_ds1edit.screen_buff, x1, y1, x2, y2, pbut->col_on.border);
      }
      else
      {
         rectfill(glb_ds1edit.screen_buff, x1, y1, x2, y2, pbut->col_off.bg);
         textout(glb_ds1edit.screen_buff, font, pbut->text, xt, y1+7, pbut->col_off.fg);
         rect(glb_ds1edit.screen_buff, x1, y1, x2, y2, pbut->col_off.border);
      }
   }

   // ---------------------------------
   // draw paths window
   // ---------------------------------
   x1 = pwin->x0;
   y1 = pwin->y0;
   x2 = x1 + pwin->w;
   y2 = y1 + pwin->h;
   rectfill(glb_ds1edit.screen_buff, x1, y1, x2, y2, pwin->c_black);
   if (editpath_mouse_in(ds1_idx, mx, my))
      rect(glb_ds1edit.screen_buff, x1, y1, x2, y2, pwin->c_yellow);
   else
      rect(glb_ds1edit.screen_buff, x1, y1, x2, y2, pwin->c_white);

   // draw labels
   pwin->c_green = makecol(0, 255, 0);
   textout(glb_ds1edit.screen_buff, font,
      "Path    X    Y Action",
      x1 + 8, y1 + 10, pwin->c_green
   );
   textout(glb_ds1edit.screen_buff, font,
      "---- ---- ---- ------",
      x1 + 8, y1 + 20, pwin->c_green
   );

/*
textprintf(glb_ds1edit.screen_buff, font,
   pwin->x0 + 8, 400,
   pwin->c_white,
   "obj_idx   = %i",
   pwin->obj_idx
);
textprintf(glb_ds1edit.screen_buff, font,
   pwin->x0 + 8, 415,
   pwin->c_white,
   "obj_dirty = %i",
   pwin->obj_dirty
);
textprintf(glb_ds1edit.screen_buff, font,
   pwin->x0 + 8, 435,
   pwin->c_white,
   "OK.show     = %i",
   pwin->button[PEB_OK].show
);
textprintf(glb_ds1edit.screen_buff, font,
   pwin->x0 + 8, 445,
   pwin->c_white,
   "CANCEL.show = %i",
   pwin->button[PEB_CANCEL].show
);
textprintf(glb_ds1edit.screen_buff, font,
   pwin->x0 + 8, 455,
   pwin->c_white,
   "ALLNEW.show = %i",
   pwin->button[PEB_ALLNEW].show
);
textprintf(glb_ds1edit.screen_buff, font,
   pwin->x0 + 8, 465,
   pwin->c_white,
   "STOP.show   = %i",
   pwin->button[PEB_STOP].show
);
*/

   // if invalid object index, empty window
   if ((pwin->obj_idx < 0) || (pwin->obj_idx >= glb_ds1[ds1_idx].current_obj_max))
      return;

   // draw path datas
   done  = FALSE;
   i     = pwin->path_start_idx;
   y     = y1 + 35;
   ppath = & pobj->path[i];

   if (i >= pobj->path_num)
      done = TRUE;

   while ( ! done)
   {
      if (y + 10 < pwin->y0 + pwin->h)
      {
         // can be draw
         textprintf(glb_ds1edit.screen_buff, font,
            pwin->x0 + 8, y,
            pwin->c_white,
            "%4i %4li %4li %6li",
            i + 1,
            ppath->x,
            ppath->y,
            ppath->action
         );
         i++;
         if (i >= pobj->path_num)
            done = TRUE;
         y += 20;
         ppath++;
      }
      else
         done = TRUE;
   }
}
#include "structs.h"
#include "ds1misc.h"
#include "undo.h"
#include "edittile.h"


// ==========================================================================
// =                                                                        =
// =  COPY / PASTE MANAGMENT                                                =
// =                                                                        =
// ==========================================================================


// ==========================================================================
// search the middle of the selection (for centered paste purpose)
void edittile_middle_select(int ds1_idx, int * start_x, int * start_y)
{
   CELL_F_S * f_ptr;
   CELL_S_S * s_ptr;
   CELL_W_S * w_ptr;
   int      x, y, t, i;
   int      minx, miny, maxx, maxy;


   maxx = 0;
   maxy = 0;
   minx = glb_ds1[ds1_idx].width - 1;
   miny = glb_ds1[ds1_idx].height - 1;
   
   for (y=0; y < glb_ds1[ds1_idx].height; y++)
   {
      for (x=0; x < glb_ds1[ds1_idx].width; x++)
      {
         // floors
         t = (y * glb_ds1[ds1_idx].floor_line) + (x * glb_ds1[ds1_idx].floor_num);
         for (i=0; i<glb_ds1[ds1_idx].floor_num; i++)
         {
            f_ptr = glb_ds1[ds1_idx].floor_buff + t + i;
            if (IS_SELECTED(f_ptr->flags))
            {
               if (x < minx) minx = x;
               if (x > maxx) maxx = x;
               if (y < miny) miny = y;
               if (y > maxy) maxy = y;
            }
         }

         // shadows
         t = (y * glb_ds1[ds1_idx].shadow_line) + (x * glb_ds1[ds1_idx].shadow_num);
         for (i=0; i<glb_ds1[ds1_idx].shadow_num; i++)
         {
            s_ptr = glb_ds1[ds1_idx].shadow_buff + t + i;
            if (IS_SELECTED(s_ptr->flags))
            {
               if (x < minx) minx = x;
               if (x > maxx) maxx = x;
               if (y < miny) miny = y;
               if (y > maxy) maxy = y;
            }
         }

         // walls
         t = (y * glb_ds1[ds1_idx].wall_line) + (x * glb_ds1[ds1_idx].wall_num);
         for (i=0; i<glb_ds1[ds1_idx].wall_num; i++)
         {
            w_ptr = glb_ds1[ds1_idx].wall_buff + t + i;
            if (IS_SELECTED(w_ptr->flags))
            {
               if (x < minx) minx = x;
               if (x > maxx) maxx = x;
               if (y < miny) miny = y;
               if (y > maxy) maxy = y;
            }
         }
      }
   }

   if (minx < maxx)
      * start_x = minx + ((maxx - minx) / 2);
   else
      * start_x = maxx + ((minx - maxx) / 2);

   if (miny < maxy)
      * start_y = miny + ((maxy - miny) / 2);
   else
      * start_y = maxy + ((miny - maxy) / 2);
}


// ==========================================================================
// just a full copy of the current ds1 state into another buffer
// (no hard-to-make algorythm for minimizing the memory usage)
void edittile_paste_prepare(int ds1_idx)
{
   CELL_F_S * src_f_ptr = glb_ds1[ds1_idx].floor_buff,
            * dst_f_ptr = glb_ds1[ds1_idx].floor_buff2;
   CELL_S_S * src_s_ptr = glb_ds1[ds1_idx].shadow_buff,
            * dst_s_ptr = glb_ds1[ds1_idx].shadow_buff2;
   CELL_W_S * src_w_ptr = glb_ds1[ds1_idx].wall_buff,
            * dst_w_ptr = glb_ds1[ds1_idx].wall_buff2;
   long     i;


   // floors
   for (i=0; i < glb_ds1[ds1_idx].floor_len; i++)
   {
      dst_f_ptr->prop1  = src_f_ptr->prop1;
      dst_f_ptr->prop2  = src_f_ptr->prop2;
      dst_f_ptr->prop3  = src_f_ptr->prop3;
      dst_f_ptr->prop4  = src_f_ptr->prop4;
      dst_f_ptr->bt_idx = src_f_ptr->bt_idx;
      dst_f_ptr->flags  = src_f_ptr->flags;
      dst_f_ptr++;
      src_f_ptr++;
   }

   // shadows
   for (i=0; i < glb_ds1[ds1_idx].shadow_len; i++)
   {
      dst_s_ptr->prop1  = src_s_ptr->prop1;
      dst_s_ptr->prop2  = src_s_ptr->prop2;
      dst_s_ptr->prop3  = src_s_ptr->prop3;
      dst_s_ptr->prop4  = src_s_ptr->prop4;
      dst_s_ptr->bt_idx = src_s_ptr->bt_idx;
      dst_s_ptr->flags  = src_s_ptr->flags;
      dst_s_ptr++;
      src_s_ptr++;
   }

   // walls
   for (i=0; i < glb_ds1[ds1_idx].wall_len; i++)
   {
      dst_w_ptr->prop1       = src_w_ptr->prop1;
      dst_w_ptr->prop2       = src_w_ptr->prop2;
      dst_w_ptr->prop3       = src_w_ptr->prop3;
      dst_w_ptr->prop4       = src_w_ptr->prop4;
      dst_w_ptr->orientation = src_w_ptr->orientation;
      dst_w_ptr->bt_idx      = src_w_ptr->bt_idx;
      dst_w_ptr->flags       = src_w_ptr->flags;
      dst_w_ptr++;
      src_w_ptr++;
   }
}


// ==========================================================================
// put back the ds1 in its original state
void edittile_paste_undo(int ds1_idx)
{
   CELL_F_S * src_f_ptr = glb_ds1[ds1_idx].floor_buff2,
            * dst_f_ptr = glb_ds1[ds1_idx].floor_buff;
   CELL_S_S * src_s_ptr = glb_ds1[ds1_idx].shadow_buff2,
            * dst_s_ptr = glb_ds1[ds1_idx].shadow_buff;
   CELL_W_S * src_w_ptr = glb_ds1[ds1_idx].wall_buff2,
            * dst_w_ptr = glb_ds1[ds1_idx].wall_buff;
   long     i;


   // floors
   for (i=0; i < glb_ds1[ds1_idx].floor_len; i++)
   {
      dst_f_ptr->prop1  = src_f_ptr->prop1;
      dst_f_ptr->prop2  = src_f_ptr->prop2;
      dst_f_ptr->prop3  = src_f_ptr->prop3;
      dst_f_ptr->prop4  = src_f_ptr->prop4;
      dst_f_ptr->bt_idx = src_f_ptr->bt_idx;
      dst_f_ptr->flags  = src_f_ptr->flags;
      dst_f_ptr++;
      src_f_ptr++;
   }

   // shadows
   for (i=0; i < glb_ds1[ds1_idx].shadow_len; i++)
   {
      dst_s_ptr->prop1  = src_s_ptr->prop1;
      dst_s_ptr->prop2  = src_s_ptr->prop2;
      dst_s_ptr->prop3  = src_s_ptr->prop3;
      dst_s_ptr->prop4  = src_s_ptr->prop4;
      dst_s_ptr->bt_idx = src_s_ptr->bt_idx;
      dst_s_ptr->flags  = src_s_ptr->flags;
      dst_s_ptr++;
      src_s_ptr++;
   }

   // walls
   for (i=0; i < glb_ds1[ds1_idx].wall_len; i++)
   {
      dst_w_ptr->prop1       = src_w_ptr->prop1;
      dst_w_ptr->prop2       = src_w_ptr->prop2;
      dst_w_ptr->prop3       = src_w_ptr->prop3;
      dst_w_ptr->prop4       = src_w_ptr->prop4;
      dst_w_ptr->orientation = src_w_ptr->orientation;
      dst_w_ptr->bt_idx      = src_w_ptr->bt_idx;
      dst_w_ptr->flags       = src_w_ptr->flags;
      dst_w_ptr++;
      src_w_ptr++;
   }
}


// ==========================================================================
// paste the selection into the new area, showing where are conflicts
void edittile_paste_preview(int ds1_idx, int dx, int dy, PASTE_POS_S * p)
{
   CELL_F_S * src_f_ptr, * dst_f_ptr;
   CELL_S_S * src_s_ptr, * dst_s_ptr;
   CELL_W_S * src_w_ptr, * dst_w_ptr;
   int      x, y, ts, td, i, f;


   // if tiles are 'cut' instead of 'copy', then delete the source tiles
   if (p->is_cut == TRUE)
   {
      if (p->cut_saved == FALSE)
      {
         // with UNDO
         edittile_delete_selected_tiles(p->src_ds1_idx);
         p->cut_saved = TRUE;
      }
      else
      {
         // with NO UNDO
         edittile_delete_selected_tiles2(p->src_ds1_idx);
      }
   }

   // copy tiles
   for (y=0; y < glb_ds1[p->src_ds1_idx].height; y++)
   {
      if ( ((y+dy) < 0) || ((y+dy) >= glb_ds1[ds1_idx].height) )
         continue;
         
      for (x=0; x < glb_ds1[p->src_ds1_idx].width; x++)
      {
         if ( ((x+dx) < 0) || ((x+dx) >= glb_ds1[ds1_idx].width) )
            continue;

         // floors
         ts = (y * glb_ds1[p->src_ds1_idx].floor_line) +
              (x * glb_ds1[p->src_ds1_idx].floor_num);
         td = ((y+dy) * glb_ds1[ds1_idx].floor_line) +
              ((x+dx) * glb_ds1[ds1_idx].floor_num);
         for (i=0; (i<glb_ds1[ds1_idx].floor_num) &&
                   (i<glb_ds1[p->src_ds1_idx].floor_num); i++)
         {
            src_f_ptr = glb_ds1[p->src_ds1_idx].floor_buff2 + ts + i;
            dst_f_ptr = glb_ds1[ds1_idx].floor_buff + td + i;
            
            f = src_f_ptr->flags;
            if (IS_SELECTED(f) && (src_f_ptr->bt_idx != 0))
            {
               SET_COPY_INFO(f);
               if (dst_f_ptr->bt_idx != 0)
               {
                  if ( (dst_f_ptr->prop1 != src_f_ptr->prop1) ||
                       (dst_f_ptr->prop2 != src_f_ptr->prop2) ||
                       (dst_f_ptr->prop3 != src_f_ptr->prop3) ||
                       (dst_f_ptr->prop4 != src_f_ptr->prop4)
                     )
                  {
                     SET_COPY_STATE(f); // conflict
                  }
               }
               dst_f_ptr->prop1  = src_f_ptr->prop1;
               dst_f_ptr->prop2  = src_f_ptr->prop2;
               dst_f_ptr->prop3  = src_f_ptr->prop3;
               dst_f_ptr->prop4  = src_f_ptr->prop4;
               dst_f_ptr->flags  = f;
               fprop_2_block(ds1_idx, dst_f_ptr); // search dst->bt_idx
            }
         }

         // shadows
         ts = (y * glb_ds1[p->src_ds1_idx].shadow_line) +
              (x * glb_ds1[p->src_ds1_idx].shadow_num);
         td = ((y+dy) * glb_ds1[ds1_idx].shadow_line) +
              ((x+dx) * glb_ds1[ds1_idx].shadow_num);
         for (i=0; (i<glb_ds1[ds1_idx].shadow_num) &&
                   (i<glb_ds1[p->src_ds1_idx].shadow_num); i++)
         {
            src_s_ptr = glb_ds1[p->src_ds1_idx].shadow_buff2 + ts + i;
            dst_s_ptr = glb_ds1[ds1_idx].shadow_buff + td + i;
            
            f = src_s_ptr->flags;
            if (IS_SELECTED(f) && (src_s_ptr->bt_idx != 0))
            {
               SET_COPY_INFO(f);
               if (dst_s_ptr->bt_idx != 0)
               {
                  if ( (dst_s_ptr->prop1 != src_s_ptr->prop1) ||
                       (dst_s_ptr->prop2 != src_s_ptr->prop2) ||
                       (dst_s_ptr->prop3 != src_s_ptr->prop3) ||
                       (dst_s_ptr->prop4 != src_s_ptr->prop4)
                     )
                  {
                     SET_COPY_STATE(f); // conflict
                  }
               }
               dst_s_ptr->prop1  = src_s_ptr->prop1;
               dst_s_ptr->prop2  = src_s_ptr->prop2;
               dst_s_ptr->prop3  = src_s_ptr->prop3;
               dst_s_ptr->prop4  = src_s_ptr->prop4;
               dst_s_ptr->flags  = f;
               sprop_2_block(ds1_idx, dst_s_ptr); // search dst->bt_idx
            }
         }

         // walls
         ts = (y * glb_ds1[p->src_ds1_idx].wall_line) +
              (x * glb_ds1[p->src_ds1_idx].wall_num);
         td = ((y+dy) * glb_ds1[ds1_idx].wall_line) +
              ((x+dx) * glb_ds1[ds1_idx].wall_num);
         for (i=0; (i<glb_ds1[ds1_idx].wall_num) &&
                   (i<glb_ds1[p->src_ds1_idx].wall_num); i++)
         {
            src_w_ptr = glb_ds1[p->src_ds1_idx].wall_buff2 + ts + i;
            dst_w_ptr = glb_ds1[ds1_idx].wall_buff + td + i;
            
            f = src_w_ptr->flags;
            if (IS_SELECTED(f) && (src_w_ptr->bt_idx != 0) )
            {
               SET_COPY_INFO(f);
               if (dst_w_ptr->bt_idx != 0)
               {
                  if ( (dst_w_ptr->prop1 != src_w_ptr->prop1) ||
                       (dst_w_ptr->prop2 != src_w_ptr->prop2) ||
                       (dst_w_ptr->prop3 != src_w_ptr->prop3) ||
                       (dst_w_ptr->prop4 != src_w_ptr->prop4) ||
                       (dst_w_ptr->orientation != src_w_ptr->orientation)
                     )
                  {
                     SET_COPY_STATE(f); // conflict
                  }
               }
               dst_w_ptr->prop1       = src_w_ptr->prop1;
               dst_w_ptr->prop2       = src_w_ptr->prop2;
               dst_w_ptr->prop3       = src_w_ptr->prop3;
               dst_w_ptr->prop4       = src_w_ptr->prop4;
               dst_w_ptr->orientation = src_w_ptr->orientation;
               dst_w_ptr->flags       = f;
               wprop_2_block(ds1_idx, dst_w_ptr); // search dst->bt_idx
            }
         }
      }
   }
}


// ==========================================================================
// the new copied tiles become the new selection
void edittile_paste_final(int ds1_idx)
{
   CELL_F_S * f_ptr = glb_ds1[ds1_idx].floor_buff,  * f2;
   CELL_S_S * s_ptr = glb_ds1[ds1_idx].shadow_buff, * s2;
   CELL_W_S * w_ptr = glb_ds1[ds1_idx].wall_buff,   * w2;
   int      i, f, tf, ts, tw, x, y, make_undo;
   UNDO_S   * u = & glb_ds1[ds1_idx].undo;


   undo_new_tile_buffer(ds1_idx);
   for (y=0; y<glb_ds1[ds1_idx].height; y++)
   {
      for (x=0; x<glb_ds1[ds1_idx].width; x++)
      {
         tf    = (y * glb_ds1[ds1_idx].floor_line)  + (x * glb_ds1[ds1_idx].floor_num);
         ts    = (y * glb_ds1[ds1_idx].shadow_line) + (x * glb_ds1[ds1_idx].shadow_num);
         tw    = (y * glb_ds1[ds1_idx].wall_line)   + (x * glb_ds1[ds1_idx].wall_num);
         f_ptr = glb_ds1[ds1_idx].floor_buff   + tf;
         s_ptr = glb_ds1[ds1_idx].shadow_buff  + ts;
         w_ptr = glb_ds1[ds1_idx].wall_buff    + tw;
         f2    = glb_ds1[ds1_idx].floor_buff2  + tf;
         s2    = glb_ds1[ds1_idx].shadow_buff2 + ts;
         w2    = glb_ds1[ds1_idx].wall_buff2   + tw;

         // undo managment
         make_undo = FALSE;
         for (i=0; i<glb_ds1[ds1_idx].floor_num; i++)
         {
            if (f_ptr[i].prop1 != f2[i].prop1)
               u->dat_flg.f[i] |= DF_P1;

            if (f_ptr[i].prop2 != f2[i].prop2)
               u->dat_flg.f[i] |= DF_P2;

            if (f_ptr[i].prop3 != f2[i].prop3)
               u->dat_flg.f[i] |= DF_P3;

            if (f_ptr[i].prop4 != f2[i].prop4)
               u->dat_flg.f[i] |= DF_P4;
                  
            if (f_ptr[i].bt_idx != f2[i].bt_idx)
               u->dat_flg.f[i] |= DF_BT;

            f = f_ptr[i].flags;
            if (IS_COPY_INFO(f))
               SET_SELECTED(f);
            else
               DEL_SELECTED(f);
            f_ptr[i].flags = IS_SELECTED(f) | IS_HIDE(f);

            if (f_ptr[i].flags != f2[i].flags)
               u->dat_flg.f[i] |= DF_FL;
                  
            if (u->dat_flg.f[i])
               make_undo = TRUE;
         }
         for (i=0; i<glb_ds1[ds1_idx].shadow_num; i++)
         {
            if (s_ptr[i].prop1 != s2[i].prop1)
               u->dat_flg.s[i] |= DF_P1;

            if (s_ptr[i].prop2 != s2[i].prop2)
               u->dat_flg.s[i] |= DF_P2;

            if (s_ptr[i].prop3 != s2[i].prop3)
               u->dat_flg.s[i] |= DF_P3;

            if (s_ptr[i].prop4 != s2[i].prop4)
               u->dat_flg.s[i] |= DF_P4;
                  
            if (s_ptr[i].bt_idx != s2[i].bt_idx)
               u->dat_flg.s[i] |= DF_BT;

            f = s_ptr[i].flags;
            if (IS_COPY_INFO(f))
               SET_SELECTED(f);
            else
               DEL_SELECTED(f);
            s_ptr[i].flags = IS_SELECTED(f) | IS_HIDE(f);

            if (s_ptr[i].flags != s2[i].flags)
               u->dat_flg.s[i] |= DF_FL;
                  
            if (u->dat_flg.s[i])
               make_undo = TRUE;
         }
         for (i=0; i<glb_ds1[ds1_idx].wall_num; i++)
         {
            if (w_ptr[i].prop1 != w2[i].prop1)
               u->dat_flg.w[i] |= DF_P1;

            if (w_ptr[i].prop2 != w2[i].prop2)
               u->dat_flg.w[i] |= DF_P2;

            if (w_ptr[i].prop3 != w2[i].prop3)
               u->dat_flg.w[i] |= DF_P3;

            if (w_ptr[i].prop4 != w2[i].prop4)
               u->dat_flg.w[i] |= DF_P4;
                  
            if (w_ptr[i].orientation != w2[i].orientation)
               u->dat_flg.w[i] |= DF_OR;
                  
            if (w_ptr[i].bt_idx != w2[i].bt_idx)
               u->dat_flg.w[i] |= DF_BT;

            f = w_ptr[i].flags;
            if (IS_COPY_INFO(f))
               SET_SELECTED(f);
            else
               DEL_SELECTED(f);
            w_ptr[i].flags = IS_SELECTED(f) | IS_HIDE(f);

            if (w_ptr[i].flags != w2[i].flags)
               u->dat_flg.w[i] |= DF_FL;
                  
            if (u->dat_flg.w[i])
               make_undo = TRUE;
         }
         if (make_undo)
            undo_add_this_tile_to_buffer(ds1_idx, x, y, f2, w2, s2);
      }
   }
   
   undo_close_tile_buffer(ds1_idx);
}




// ==========================================================================
// =                                                                        =
// =  DELETE TILES MANAGMENT                                                =
// =                                                                        =
// ==========================================================================


// ==========================================================================
// delete the selected tiles of a ds1, WITH UNDO
void edittile_delete_selected_tiles(int ds1_idx)
{
   CELL_W_S * w_ptr;
   CELL_F_S * f_ptr;
   CELL_S_S * s_ptr;
   int      i, tf, ts, tw, x, y, make_undo;
   UNDO_S   * u = & glb_ds1[ds1_idx].undo;


   undo_new_tile_buffer(ds1_idx);
   for (y=0; y<glb_ds1[ds1_idx].height; y++)
   {
      for (x=0; x<glb_ds1[ds1_idx].width; x++)
      {
         tf    = (y * glb_ds1[ds1_idx].floor_line)  + (x * glb_ds1[ds1_idx].floor_num);
         ts    = (y * glb_ds1[ds1_idx].shadow_line) + (x * glb_ds1[ds1_idx].shadow_num);
         tw    = (y * glb_ds1[ds1_idx].wall_line)   + (x * glb_ds1[ds1_idx].wall_num);
         f_ptr = glb_ds1[ds1_idx].floor_buff  + tf;
         s_ptr = glb_ds1[ds1_idx].shadow_buff + ts;
         w_ptr = glb_ds1[ds1_idx].wall_buff   + tw;

         // undo managment
         make_undo = FALSE;
         for (i=0; i<glb_ds1[ds1_idx].floor_num; i++)
         {
            if (IS_SELECTED(f_ptr[i].flags))
            {
               if (f_ptr[i].prop1)
                  u->dat_flg.f[i] |= DF_P1;

               if (f_ptr[i].prop2)
                  u->dat_flg.f[i] |= DF_P2;

               if (f_ptr[i].prop3)
                  u->dat_flg.f[i] |= DF_P3;

               if (f_ptr[i].prop4)
                  u->dat_flg.f[i] |= DF_P4;
                  
               if (f_ptr[i].bt_idx != 0)
                  u->dat_flg.f[i] |= DF_BT;

               if (f_ptr[i].flags)
                  u->dat_flg.f[i] |= DF_FL;
                  
               if (u->dat_flg.f[i])
                  make_undo = TRUE;
            }
         }
         for (i=0; i<glb_ds1[ds1_idx].shadow_num; i++)
         {
            if (IS_SELECTED(s_ptr[i].flags))
            {
               if (s_ptr[i].prop1)
                  u->dat_flg.s[i] |= DF_P1;

               if (s_ptr[i].prop2)
                  u->dat_flg.s[i] |= DF_P2;

               if (s_ptr[i].prop3)
                  u->dat_flg.s[i] |= DF_P3;

               if (s_ptr[i].prop4)
                  u->dat_flg.s[i] |= DF_P4;
                  
               if (s_ptr[i].bt_idx != 0)
                  u->dat_flg.s[i] |= DF_BT;

               if (s_ptr[i].flags)
                  u->dat_flg.s[i] |= DF_FL;
                  
               if (u->dat_flg.s[i])
                  make_undo = TRUE;
            }
         }
         for (i=0; i<glb_ds1[ds1_idx].wall_num; i++)
         {
            if (IS_SELECTED(w_ptr[i].flags))
            {
               if (w_ptr[i].prop1)
                  u->dat_flg.w[i] |= DF_P1;

               if (w_ptr[i].prop2)
                  u->dat_flg.w[i] |= DF_P2;

               if (w_ptr[i].prop3)
                  u->dat_flg.w[i] |= DF_P3;

               if (w_ptr[i].prop4)
                  u->dat_flg.w[i] |= DF_P4;
                  
               if (w_ptr[i].orientation)
                  u->dat_flg.w[i] |= DF_OR;
                  
               if (w_ptr[i].bt_idx != 0)
                  u->dat_flg.w[i] |= DF_BT;

               if (w_ptr[i].flags)
                  u->dat_flg.w[i] |= DF_FL;
                  
               if (u->dat_flg.w[i])
                  make_undo = TRUE;
            }
         }
         if (make_undo)
            undo_add_to_tile_buffer(ds1_idx, x, y);
         
         // floors
         for (i=0; i<glb_ds1[ds1_idx].floor_num; i++)
         {
            if (IS_SELECTED(f_ptr[i].flags))
            {
               f_ptr[i].prop1  = 0;
               f_ptr[i].prop2  = 0;
               f_ptr[i].prop3  = 0;
               f_ptr[i].prop4  = 0;
               f_ptr[i].bt_idx = 0;
               f_ptr[i].flags  = 0;
            }
         }

         // shadows
         for (i=0; i<glb_ds1[ds1_idx].shadow_num; i++)
         {
            if (IS_SELECTED(s_ptr[i].flags))
            {
               s_ptr[i].prop1  = 0;
               s_ptr[i].prop2  = 0;
               s_ptr[i].prop3  = 0;
               s_ptr[i].prop4  = 0;
               s_ptr[i].bt_idx = 0;
               s_ptr[i].flags  = 0;
            }
         }

         // walls
         for (i=0; i<glb_ds1[ds1_idx].wall_num; i++)
         {
            if (IS_SELECTED(w_ptr[i].flags))
            {
               w_ptr[i].prop1       = 0;
               w_ptr[i].prop2       = 0;
               w_ptr[i].prop3       = 0;
               w_ptr[i].prop4       = 0;
               w_ptr[i].orientation = 0;
               w_ptr[i].bt_idx      = 0;
               w_ptr[i].flags       = 0;
            }
         }
      }
   }
   undo_close_tile_buffer(ds1_idx);
}


// ==========================================================================
// delete selected tiles of a ds1 with NO UNDO
// function used only by edittile_paste_preview()
void edittile_delete_selected_tiles2(int ds1_idx)
{
   CELL_W_S * w_ptr;
   CELL_F_S * f_ptr;
   CELL_S_S * s_ptr;
   int      i, tf, ts, tw, x, y;


   for (y=0; y<glb_ds1[ds1_idx].height; y++)
   {
      for (x=0; x<glb_ds1[ds1_idx].width; x++)
      {
         tf    = (y * glb_ds1[ds1_idx].floor_line)  + (x * glb_ds1[ds1_idx].floor_num);
         ts    = (y * glb_ds1[ds1_idx].shadow_line) + (x * glb_ds1[ds1_idx].shadow_num);
         tw    = (y * glb_ds1[ds1_idx].wall_line)   + (x * glb_ds1[ds1_idx].wall_num);
         f_ptr = glb_ds1[ds1_idx].floor_buff  + tf;
         s_ptr = glb_ds1[ds1_idx].shadow_buff + ts;
         w_ptr = glb_ds1[ds1_idx].wall_buff   + tw;

         // floors
         for (i=0; i<glb_ds1[ds1_idx].floor_num; i++)
         {
            if (IS_SELECTED(f_ptr[i].flags))
            {
               f_ptr[i].prop1  = 0;
               f_ptr[i].prop2  = 0;
               f_ptr[i].prop3  = 0;
               f_ptr[i].prop4  = 0;
               f_ptr[i].bt_idx = 0;
               f_ptr[i].flags  = 0;
            }
         }

         // shadows
         for (i=0; i<glb_ds1[ds1_idx].shadow_num; i++)
         {
            if (IS_SELECTED(s_ptr[i].flags))
            {
               s_ptr[i].prop1  = 0;
               s_ptr[i].prop2  = 0;
               s_ptr[i].prop3  = 0;
               s_ptr[i].prop4  = 0;
               s_ptr[i].bt_idx = 0;
               s_ptr[i].flags  = 0;
            }
         }

         // walls
         for (i=0; i<glb_ds1[ds1_idx].wall_num; i++)
         {
            if (IS_SELECTED(w_ptr[i].flags))
            {
               w_ptr[i].prop1       = 0;
               w_ptr[i].prop2       = 0;
               w_ptr[i].prop3       = 0;
               w_ptr[i].prop4       = 0;
               w_ptr[i].orientation = 0;
               w_ptr[i].bt_idx      = 0;
               w_ptr[i].flags       = 0;
            }
         }
      }
   }
}




// ==========================================================================
// =                                                                        =
// =  MODIFY SELECTION MANAGMENT                                            =
// =                                                                        =
// ==========================================================================


// ==========================================================================
// deselect this cell only for the visible layers
void edittile_deselect_one(int ds1_idx, int x, int y)
{
   CELL_F_S * f_ptr;
   CELL_S_S * s_ptr;
   CELL_W_S * w_ptr;
   UNDO_S   * u  = & glb_ds1[ds1_idx].undo;
   int      n, tf, ts, tw, make_undo = FALSE;

   
   tf    = (y * glb_ds1[ds1_idx].floor_line)  + (x * glb_ds1[ds1_idx].floor_num);
   ts    = (y * glb_ds1[ds1_idx].shadow_line) + (x * glb_ds1[ds1_idx].shadow_num);
   tw    = (y * glb_ds1[ds1_idx].wall_line)   + (x * glb_ds1[ds1_idx].wall_num);
   f_ptr = glb_ds1[ds1_idx].floor_buff  + tf;
   s_ptr = glb_ds1[ds1_idx].shadow_buff + ts;
   w_ptr = glb_ds1[ds1_idx].wall_buff   + tw;
   
   // undo managment
   for (n=0; n<glb_ds1[ds1_idx].floor_num; n++)
   {
      if (glb_ds1[ds1_idx].floor_layer_mask[n] != 0)
      {
         if (IS_SELECTED(f_ptr[n].flags))
         {
            u->dat_flg.f[n] |= DF_FL;
            make_undo = TRUE;
         }
      }
   }
   for (n=0; n<glb_ds1[ds1_idx].shadow_num; n++)
   {
      if (glb_ds1[ds1_idx].shadow_layer_mask[n] != 0)
      {
         if (IS_SELECTED(s_ptr[n].flags))
         {
            u->dat_flg.s[n] |= DF_FL;
            make_undo = TRUE;
         }
      }
   }
   for (n=0; n<glb_ds1[ds1_idx].wall_num; n++)
   {
      if (glb_ds1[ds1_idx].wall_layer_mask[n] != 0)
      {
         if (IS_SELECTED(w_ptr[n].flags))
         {
            u->dat_flg.w[n] |= DF_FL;
            make_undo = TRUE;
         }
      }
   }
   if (make_undo)
      undo_add_to_tile_buffer(ds1_idx, x, y);

   // floors
   for (n=0; n<glb_ds1[ds1_idx].floor_num; n++)
      if (glb_ds1[ds1_idx].floor_layer_mask[n] != 0)
         DEL_SELECTED(f_ptr[n].flags);

   // shadows
   for (n=0; n<glb_ds1[ds1_idx].shadow_num; n++)
      if (glb_ds1[ds1_idx].shadow_layer_mask[n] != 0)
         DEL_SELECTED(s_ptr[n].flags);

   // walls
   for (n=0; n<glb_ds1[ds1_idx].wall_num; n++)
      if (glb_ds1[ds1_idx].wall_layer_mask[n] != 0)
         DEL_SELECTED(w_ptr[n].flags);
}


// ==========================================================================
// deselect this cell for ALL layers, whatever they're visible or not
void edittile_deselect_one_completly(int ds1_idx, int x, int y)
{
   CELL_F_S * f_ptr;
   CELL_S_S * s_ptr;
   CELL_W_S * w_ptr;
   UNDO_S   * u  = & glb_ds1[ds1_idx].undo;
   int      n, tf, ts, tw, make_undo = FALSE;


   tf    = (y * glb_ds1[ds1_idx].floor_line)  + (x * glb_ds1[ds1_idx].floor_num);
   ts    = (y * glb_ds1[ds1_idx].shadow_line) + (x * glb_ds1[ds1_idx].shadow_num);
   tw    = (y * glb_ds1[ds1_idx].wall_line)   + (x * glb_ds1[ds1_idx].wall_num);
   f_ptr = glb_ds1[ds1_idx].floor_buff  + tf;
   s_ptr = glb_ds1[ds1_idx].shadow_buff + ts;
   w_ptr = glb_ds1[ds1_idx].wall_buff   + tw;
   
   // undo managment
   for (n=0; n<glb_ds1[ds1_idx].floor_num; n++)
   {
      if (IS_SELECTED(f_ptr[n].flags))
      {
         u->dat_flg.f[n] |= DF_FL;
         make_undo = TRUE;
      }
   }
   for (n=0; n<glb_ds1[ds1_idx].shadow_num; n++)
   {
      if (IS_SELECTED(s_ptr[n].flags))
      {
         u->dat_flg.s[n] |= DF_FL;
         make_undo = TRUE;
      }
   }
   for (n=0; n<glb_ds1[ds1_idx].wall_num; n++)
   {
      if (IS_SELECTED(w_ptr[n].flags))
      {
         u->dat_flg.w[n] |= DF_FL;
         make_undo = TRUE;
      }
   }
   if (make_undo)
      undo_add_to_tile_buffer(ds1_idx, x, y);

   // floors
   for (n=0; n<glb_ds1[ds1_idx].floor_num; n++)
      DEL_SELECTED(f_ptr[n].flags);

   // shadows
   for (n=0; n<glb_ds1[ds1_idx].shadow_num; n++)
      DEL_SELECTED(s_ptr[n].flags);

   // walls
   for (n=0; n<glb_ds1[ds1_idx].wall_num; n++)
      DEL_SELECTED(w_ptr[n].flags);
}


// ==========================================================================
// select only the visible layers of this cell (leave already selected)
void edittile_select_one(int ds1_idx, int x, int y)
{
   CELL_F_S * f_ptr;
   CELL_S_S * s_ptr;
   CELL_W_S * w_ptr;
   UNDO_S   * u  = & glb_ds1[ds1_idx].undo;
   int      n, tf, ts, tw, make_undo = FALSE;


   tf    = (y * glb_ds1[ds1_idx].floor_line)  + (x * glb_ds1[ds1_idx].floor_num);
   ts    = (y * glb_ds1[ds1_idx].shadow_line) + (x * glb_ds1[ds1_idx].shadow_num);
   tw    = (y * glb_ds1[ds1_idx].wall_line)   + (x * glb_ds1[ds1_idx].wall_num);
   f_ptr = glb_ds1[ds1_idx].floor_buff  + tf;
   s_ptr = glb_ds1[ds1_idx].shadow_buff + ts;
   w_ptr = glb_ds1[ds1_idx].wall_buff   + tw;
   
   // undo managment
   for (n=0; n<glb_ds1[ds1_idx].floor_num; n++)
   {
      if ((glb_ds1[ds1_idx].floor_layer_mask[n] != 0) && (f_ptr[n].prop1 != 0))
      {
         if ( ! IS_SELECTED(f_ptr[n].flags))
         {
            u->dat_flg.f[n] |= DF_FL;
            make_undo = TRUE;
         }
      }
   }
   for (n=0; n<glb_ds1[ds1_idx].shadow_num; n++)
   {
      if ((glb_ds1[ds1_idx].shadow_layer_mask[n] != 0) && (s_ptr[n].prop1 != 0))
      {
         if ( ! IS_SELECTED(s_ptr[n].flags))
         {
            u->dat_flg.s[n] |= DF_FL;
            make_undo = TRUE;
         }
      }
   }
   for (n=0; n<glb_ds1[ds1_idx].wall_num; n++)
   {
      if ((glb_ds1[ds1_idx].wall_layer_mask[n] != 0) && (w_ptr[n].prop1 != 0))
      {
         if ( ! IS_SELECTED(w_ptr[n].flags))
         {
            u->dat_flg.w[n] |= DF_FL;
            make_undo = TRUE;
         }
      }
   }
   if (make_undo)
      undo_add_to_tile_buffer(ds1_idx, x, y);

   // floors
   for (n=0; n<glb_ds1[ds1_idx].floor_num; n++)
      if ((glb_ds1[ds1_idx].floor_layer_mask[n] != 0) && (f_ptr[n].prop1 != 0))
         SET_SELECTED(f_ptr[n].flags);

   // shadows
   for (n=0; n<glb_ds1[ds1_idx].shadow_num; n++)
      if ((glb_ds1[ds1_idx].shadow_layer_mask[n] != 0) && (s_ptr[n].prop1 != 0))
         SET_SELECTED(s_ptr[n].flags);

   // walls
   for (n=0; n<glb_ds1[ds1_idx].wall_num; n++)
      if ((glb_ds1[ds1_idx].wall_layer_mask[n] != 0) && (w_ptr[n].prop1 != 0))
         SET_SELECTED(w_ptr[n].flags);
}


// ==========================================================================
// select only the visible layers of this cell (deselect already selected)
void edittile_select_new_one(int ds1_idx, int x, int y)
{
   CELL_F_S * f_ptr;
   CELL_S_S * s_ptr;
   CELL_W_S * w_ptr;
   UNDO_S   * u  = & glb_ds1[ds1_idx].undo;
   int      n, tf, ts, tw, make_undo = FALSE;


   tf    = (y * glb_ds1[ds1_idx].floor_line)  + (x * glb_ds1[ds1_idx].floor_num);
   ts    = (y * glb_ds1[ds1_idx].shadow_line) + (x * glb_ds1[ds1_idx].shadow_num);
   tw    = (y * glb_ds1[ds1_idx].wall_line)   + (x * glb_ds1[ds1_idx].wall_num);
   f_ptr = glb_ds1[ds1_idx].floor_buff  + tf;
   s_ptr = glb_ds1[ds1_idx].shadow_buff + ts;
   w_ptr = glb_ds1[ds1_idx].wall_buff   + tw;
   
   // undo managment
   for (n=0; n<glb_ds1[ds1_idx].floor_num; n++)
   {
      if ((glb_ds1[ds1_idx].floor_layer_mask[n] != 0) && (f_ptr[n].prop1 != 0))
      {
         // this floor is visible
         if ( ! IS_SELECTED(f_ptr[n].flags))
         {
            // save the non-selected state of this cell layer
            u->dat_flg.f[n] |= DF_FL;
            make_undo = TRUE;
         }
      }
      else
      {
         // this floor is not visible
         if ( IS_SELECTED(f_ptr[n].flags))
         {
            // save the selected state of this cell layer
            u->dat_flg.f[n] |= DF_FL;
            make_undo = TRUE;
         }
      }
   }
   for (n=0; n<glb_ds1[ds1_idx].shadow_num; n++)
   {
      if ((glb_ds1[ds1_idx].shadow_layer_mask[n] != 0) && (s_ptr[n].prop1 != 0))
      {
         if ( ! IS_SELECTED(s_ptr[n].flags))
         {
            u->dat_flg.s[n] |= DF_FL;
            make_undo = TRUE;
         }
      }
      else
      {
         if ( IS_SELECTED(s_ptr[n].flags))
         {
            u->dat_flg.s[n] |= DF_FL;
            make_undo = TRUE;
         }
      }
   }
   for (n=0; n<glb_ds1[ds1_idx].wall_num; n++)
   {
      if ((glb_ds1[ds1_idx].wall_layer_mask[n] != 0) && (w_ptr[n].prop1 != 0))
      {
         if ( ! IS_SELECTED(w_ptr[n].flags))
         {
            u->dat_flg.w[n] |= DF_FL;
            make_undo = TRUE;
         }
      }
      else
      {
         if ( IS_SELECTED(w_ptr[n].flags))
         {
            u->dat_flg.w[n] |= DF_FL;
            make_undo = TRUE;
         }
      }
   }
   if (make_undo)
      undo_add_to_tile_buffer(ds1_idx, x, y);

   // floors
   for (n=0; n<glb_ds1[ds1_idx].floor_num; n++)
      if ((glb_ds1[ds1_idx].floor_layer_mask[n] != 0) && (f_ptr[n].prop1 != 0))
         SET_SELECTED(f_ptr[n].flags);
      else
         DEL_SELECTED(f_ptr[n].flags);

   // shadows
   for (n=0; n<glb_ds1[ds1_idx].shadow_num; n++)
      if ((glb_ds1[ds1_idx].shadow_layer_mask[n] != 0) && (s_ptr[n].prop1 != 0))
         SET_SELECTED(s_ptr[n].flags);
      else
         DEL_SELECTED(s_ptr[n].flags);

   // walls
   for (n=0; n<glb_ds1[ds1_idx].wall_num; n++)
      if ((glb_ds1[ds1_idx].wall_layer_mask[n] != 0) && (w_ptr[n].prop1 != 0))
         SET_SELECTED(w_ptr[n].flags);
      else
         DEL_SELECTED(w_ptr[n].flags);
}


// ==========================================================================
// select a new "Identical tile" selection, search in ALL layers
void edittile_identical(int ds1_idx, IT_ENUM itype, int tx, int ty)
{
   CELL_F_S * f_ptr;
   CELL_S_S * s_ptr;
   CELL_W_S * w_ptr;
   UNDO_S   * u  = & glb_ds1[ds1_idx].undo;
   int      x, y, n, t, i, make_undo, is_same;
   int      fl_ref[FLOOR_MAX_LAYER],
            sh_ref[SHADOW_MAX_LAYER],
            wa_ref[WALL_MAX_LAYER];

   
   // prepare undo
   undo_new_tile_buffer(ds1_idx);
   
   // inits
   for (n=0; n < FLOOR_MAX_LAYER;  n++)  fl_ref[n] = 0;
   for (n=0; n < SHADOW_MAX_LAYER; n++)  sh_ref[n] = 0;
   for (n=0; n < WALL_MAX_LAYER;   n++)  wa_ref[n] = 0;

   // first, search the reference Identical visible tiles

   // floors
   y = 0;
   t = (ty * glb_ds1[ds1_idx].floor_line) + (tx * glb_ds1[ds1_idx].floor_num);
   for (i=0; i < glb_ds1[ds1_idx].floor_num; i++)
   {
      if (glb_ds1[ds1_idx].floor_layer_mask[i] != 0)
      {
         f_ptr = glb_ds1[ds1_idx].floor_buff + t + i;
         if (f_ptr->bt_idx >= 1)
         {
            fl_ref[y] = f_ptr->bt_idx;
            y++;
         }
      }
   }
   
   // shadows
   y = 0;
   t = (ty * glb_ds1[ds1_idx].shadow_line) + (tx * glb_ds1[ds1_idx].shadow_num);
   for (i=0; i < glb_ds1[ds1_idx].shadow_num; i++)
   {
      if (glb_ds1[ds1_idx].shadow_layer_mask[i] != 0)
      {
         s_ptr = glb_ds1[ds1_idx].shadow_buff + t + i;
         if (s_ptr->bt_idx >= 1)
         {
            sh_ref[y] = s_ptr->bt_idx;
            y++;
         }
      }
   }
   
   // walls
   y = 0;
   t = (ty * glb_ds1[ds1_idx].wall_line) + (tx * glb_ds1[ds1_idx].wall_num);
   for (i=0; i < glb_ds1[ds1_idx].wall_num; i++)
   {
      if (glb_ds1[ds1_idx].wall_layer_mask[i] != 0)
      {
         w_ptr = glb_ds1[ds1_idx].wall_buff + t + i;
         if (w_ptr->bt_idx >= 1)
         {
            wa_ref[y] = w_ptr->bt_idx;
            y++;
         }
      }
   }

   // now, for ALL tiles of this map (visible or not)
   for (y=0; y < glb_ds1[ds1_idx].height; y++)
   {
      for (x=0; x < glb_ds1[ds1_idx].width; x++)
      {
         // set undo to default "don't save this tile flags"
         make_undo = FALSE;

         // check all layers to see if same as any ref
         
         // floor layers
         t = (y * glb_ds1[ds1_idx].floor_line) + (x * glb_ds1[ds1_idx].floor_num);
         for (i=0; i < glb_ds1[ds1_idx].floor_num; i++)
         {
            f_ptr = glb_ds1[ds1_idx].floor_buff + t + i;
            u->dat_flg.f[i] = 0; // don't save floor[].flag
            
            // is same as one of the ref ?
            is_same = FALSE;
            for (n=0; n < glb_ds1[ds1_idx].floor_num; n++)
            {
               if (fl_ref[n])
               {
                  if (fl_ref[n] == f_ptr->bt_idx)
                  {
                     // same
                     is_same = TRUE;

                     if ((itype == IT_NEW) || (itype == IT_ADD))
                     {
                        // add it to the selection
                        
                        // already selected ?
                        if (IS_SELECTED(f_ptr->flags))
                        {
                           // nothing to do
                        }
                        else
                        {
                           // flag it for the undo
                           u->dat_flg.f[i] |= DF_FL;
                           make_undo = TRUE;

                           // select it
                           SET_SELECTED(f_ptr->flags);
                        }
                     }
                     else if (itype == IT_DEL)
                     {
                        // delete it from selection

                        // already NOT selected ?
                        if ( ! IS_SELECTED(f_ptr->flags))
                        {
                           // nothing to do
                        }
                        else
                        {
                           // flag it for the undo
                           u->dat_flg.f[i] |= DF_FL;
                           make_undo = TRUE;

                           // DEselect it
                           DEL_SELECTED(f_ptr->flags);
                        }
                     }
                  }
               }
            }
            if (is_same == FALSE)
            {
               // different
               
               if (itype == IT_NEW)
               {
                  // delete it from the selection
                        
                  // already NOT selected ?
                  if ( ! IS_SELECTED(f_ptr->flags))
                  {
                     // nothing to do
                  }
                  else
                  {
                     // flag it for the undo
                     u->dat_flg.f[i] |= DF_FL;
                     make_undo = TRUE;

                     // DEselect it
                     DEL_SELECTED(f_ptr->flags);
                  }
               }
            }
         }

         // shadow layers
         t = (y * glb_ds1[ds1_idx].shadow_line) + (x * glb_ds1[ds1_idx].shadow_num);
         for (i=0; i < glb_ds1[ds1_idx].shadow_num; i++)
         {
            s_ptr = glb_ds1[ds1_idx].shadow_buff + t + i;
            u->dat_flg.s[i] = 0; // don't save shadow[].flag
            
            // is same as one of the ref ?
            is_same = FALSE;
            for (n=0; n < glb_ds1[ds1_idx].shadow_num; n++)
            {
               if (sh_ref[n])
               {
                  if (sh_ref[n] == s_ptr->bt_idx)
                  {
                     // same
                     is_same = TRUE;

                     if ((itype == IT_NEW) || (itype == IT_ADD))
                     {
                        // add it to the selection
                        
                        // already selected ?
                        if (IS_SELECTED(s_ptr->flags))
                        {
                           // nothing to do
                        }
                        else
                        {
                           // flag it for the undo
                           u->dat_flg.s[i] |= DF_FL;
                           make_undo = TRUE;

                           // select it
                           SET_SELECTED(s_ptr->flags);
                        }
                     }
                     else if (itype == IT_DEL)
                     {
                        // delete it from selection

                        // already NOT selected ?
                        if ( ! IS_SELECTED(s_ptr->flags))
                        {
                           // nothing to do
                        }
                        else
                        {
                           // flag it for the undo
                           u->dat_flg.s[i] |= DF_FL;
                           make_undo = TRUE;

                           // DEselect it
                           DEL_SELECTED(s_ptr->flags);
                        }
                     }
                  }
               }
            }
            if (is_same == FALSE)
            {
               // different
               
               if (itype == IT_NEW)
               {
                  // delete it from the selection
                        
                  // already NOT selected ?
                  if ( ! IS_SELECTED(s_ptr->flags))
                  {
                     // nothing to do
                  }
                  else
                  {
                     // flag it for the undo
                     u->dat_flg.s[i] |= DF_FL;
                     make_undo = TRUE;

                     // DEselect it
                     DEL_SELECTED(s_ptr->flags);
                  }
               }
            }
         }
         
         // wall layers
         t = (y * glb_ds1[ds1_idx].wall_line) + (x * glb_ds1[ds1_idx].wall_num);
         for (i=0; i < glb_ds1[ds1_idx].wall_num; i++)
         {
            w_ptr = glb_ds1[ds1_idx].wall_buff + t + i;
            u->dat_flg.w[i] = 0; // don't save wall[].flag
            
            // is same as one of the ref ?
            is_same = FALSE;
            for (n=0; n < glb_ds1[ds1_idx].wall_num; n++)
            {
               if (wa_ref[n])
               {
                  if (wa_ref[n] == w_ptr->bt_idx)
                  {
                     // same
                     is_same = TRUE;

                     if ((itype == IT_NEW) || (itype == IT_ADD))
                     {
                        // add it to the selection
                        
                        // already selected ?
                        if (IS_SELECTED(w_ptr->flags))
                        {
                           // nothing to do
                        }
                        else
                        {
                           // flag it for the undo
                           u->dat_flg.w[i] |= DF_FL;
                           make_undo = TRUE;

                           // select it
                           SET_SELECTED(w_ptr->flags);
                        }
                     }
                     else if (itype == IT_DEL)
                     {
                        // delete it from selection

                        // already NOT selected ?
                        if ( ! IS_SELECTED(w_ptr->flags))
                        {
                           // nothing to do
                        }
                        else
                        {
                           // flag it for the undo
                           u->dat_flg.w[i] |= DF_FL;
                           make_undo = TRUE;

                           // DEselect it
                           DEL_SELECTED(w_ptr->flags);
                        }
                     }
                  }
               }
            }
            if (is_same == FALSE)
            {
               // different
               
               if (itype == IT_NEW)
               {
                  // delete it from the selection
                        
                  // already NOT selected ?
                  if ( ! IS_SELECTED(w_ptr->flags))
                  {
                     // nothing to do
                  }
                  else
                  {
                     // flag it for the undo
                     u->dat_flg.w[i] |= DF_FL;
                     make_undo = TRUE;

                     // DEselect it
                     DEL_SELECTED(w_ptr->flags);
                  }
               }
            }
         }
         
         // save this tile for undo ?
         if (make_undo)
            undo_add_to_tile_buffer(ds1_idx, x, y);
      }
   }

   // end
   undo_close_tile_buffer(ds1_idx);
}




// ==========================================================================
// =                                                                        =
// =  HIDE / SHOW (UN-HIDE) MANAGMENT                                       =
// =                                                                        =
// ==========================================================================


// ==========================================================================
// clear the Hide flag of all cells of all layers
void edittile_unhide_all(int ds1_idx)
{
   CELL_F_S * f_ptr = glb_ds1[ds1_idx].floor_buff;
   CELL_S_S * s_ptr = glb_ds1[ds1_idx].shadow_buff;
   CELL_W_S * w_ptr = glb_ds1[ds1_idx].wall_buff;
   int      i;


   // floors
   for (i=0; i<glb_ds1[ds1_idx].floor_len; i++)
   {
      DEL_HIDE(f_ptr->flags);
      f_ptr++;
   }

   // shadows
   for (i=0; i<glb_ds1[ds1_idx].shadow_len; i++)
   {
      DEL_HIDE(s_ptr->flags);
      s_ptr++;
   }

   // walls
   for (i=0; i<glb_ds1[ds1_idx].wall_len; i++)
   {
      DEL_HIDE(w_ptr->flags);
      w_ptr++;
   }
}


// ==========================================================================
// hide only the visible layers of 1 cell
void edittile_hide_add_one(int ds1_idx, int x, int y)
{
   CELL_F_S * f_ptr;
   CELL_S_S * s_ptr;
   CELL_W_S * w_ptr;
   int      n, tf, ts, tw;


   tf    = (y * glb_ds1[ds1_idx].floor_line)  + (x * glb_ds1[ds1_idx].floor_num);
   ts    = (y * glb_ds1[ds1_idx].shadow_line) + (x * glb_ds1[ds1_idx].shadow_num);
   tw    = (y * glb_ds1[ds1_idx].wall_line)   + (x * glb_ds1[ds1_idx].wall_num);
   f_ptr = glb_ds1[ds1_idx].floor_buff  + tf;
   s_ptr = glb_ds1[ds1_idx].shadow_buff + ts;
   w_ptr = glb_ds1[ds1_idx].wall_buff   + tw;
   
   // floors
   for (n=0; n<glb_ds1[ds1_idx].floor_num; n++)
   {
      if (glb_ds1[ds1_idx].floor_layer_mask[n] != 0)
         SET_HIDE(f_ptr->flags);
      f_ptr++;
   }

   // shadows
   for (n=0; n<glb_ds1[ds1_idx].shadow_num; n++)
   {
      if (glb_ds1[ds1_idx].shadow_layer_mask[n] != 0)
         SET_HIDE(s_ptr->flags);
      s_ptr++;
   }

   // walls
   for (n=0; n<glb_ds1[ds1_idx].wall_num; n++)
   {
      if (glb_ds1[ds1_idx].wall_layer_mask[n] != 0)
         SET_HIDE(w_ptr->flags);
      w_ptr++;
   }
}




// ==========================================================================
// =                                                                        =
// =  TEMP SELECTION MANAGMENT                                              =
// =                                                                        =
// =  user is making a selection with the mouse, it's a temp one because    =
// =  the mouse button is still hold, and this is the key pressed at the    =
// =  end that will tell what to do with it, either add it to the current   =
// =  selection / delete it / hide it ...                                   =
// =                                                                        =
// =  theses functions are using the above ones to do their job             =
// =                                                                        =
// ==========================================================================


// ==========================================================================
// clear the TmpSelection flag of all cells
void edittile_delete_all_tmpsel(int ds1_idx)
{
   CELL_F_S * f_ptr = glb_ds1[ds1_idx].floor_buff;
   CELL_S_S * s_ptr = glb_ds1[ds1_idx].shadow_buff;
   CELL_W_S * w_ptr = glb_ds1[ds1_idx].wall_buff;
   int      i;


   // floors
   for (i=0; i<glb_ds1[ds1_idx].floor_len; i++)
   {
      DEL_TMP_SELECT(f_ptr->flags);
      f_ptr++;
   }

   // shadows
   for (i=0; i<glb_ds1[ds1_idx].shadow_len; i++)
   {
      DEL_TMP_SELECT(s_ptr->flags);
      s_ptr++;
   }

   // walls
   for (i=0; i<glb_ds1[ds1_idx].wall_len; i++)
   {
      DEL_TMP_SELECT(w_ptr->flags);
      w_ptr++;
   }
}


// ==========================================================================
// set the TmpSelection flag of 1 cell, only for the visible layers
void edittile_add_tmpsel_one(int ds1_idx, int x, int y)
{
   CELL_F_S * f_ptr;
   CELL_S_S * s_ptr;
   CELL_W_S * w_ptr;
   int      n, tf, ts, tw;
   

   tf    = (y * glb_ds1[ds1_idx].floor_line)  + (x * glb_ds1[ds1_idx].floor_num);
   ts    = (y * glb_ds1[ds1_idx].shadow_line) + (x * glb_ds1[ds1_idx].shadow_num);
   tw    = (y * glb_ds1[ds1_idx].wall_line)   + (x * glb_ds1[ds1_idx].wall_num);
   f_ptr = glb_ds1[ds1_idx].floor_buff  + tf;
   s_ptr = glb_ds1[ds1_idx].shadow_buff + ts;
   w_ptr = glb_ds1[ds1_idx].wall_buff   + tw;
   
   // floors
   for (n=0; n<glb_ds1[ds1_idx].floor_num; n++)
   {
      if (glb_ds1[ds1_idx].floor_layer_mask[n] != 0)
         SET_TMP_SELECT(f_ptr->flags);
      f_ptr++;
   }

   // shadows
   for (n=0; n<glb_ds1[ds1_idx].shadow_num; n++)
   {
      if (glb_ds1[ds1_idx].shadow_layer_mask[n] != 0)
         SET_TMP_SELECT(s_ptr->flags);
      s_ptr++;
   }

   // walls
   for (n=0; n<glb_ds1[ds1_idx].wall_num; n++)
   {
      if (glb_ds1[ds1_idx].wall_layer_mask[n] != 0)
         SET_TMP_SELECT(w_ptr->flags);
      w_ptr++;
   }
}


// ==========================================================================
// make the current temp selection
void edittile_set_tmpsel(int ds1_idx, TMP_SEL_S * s)
{
   int x, y, x1, y1, x2, y2;


   x1 = s->x1;
   x2 = s->x2;
   if (s->x2 < s->x1)
   {
      x1 = s->x2;
      x2 = s->x1;
   }
   y1 = s->y1;
   y2 = s->y2;
   if (s->y2 < s->y1)
   {
      y1 = s->y2;
      y2 = s->y1;
   }

   for (y = y1; y <= y2; y++)
      for (x = x1; x <= x2; x++)
         edittile_add_tmpsel_one(ds1_idx, x, y);
}


// ==========================================================================
// change the Temp selection to be a New selected selection
void edittile_change_to_new_permanent_sel(int ds1_idx, TMP_SEL_S * s)
{
   int x, y, x1, y1, x2, y2;


   x1 = s->x1;
   x2 = s->x2;
   if (s->x2 < s->x1)
   {
      x1 = s->x2;
      x2 = s->x1;
   }
   y1 = s->y1;
   y2 = s->y2;
   if (s->y2 < s->y1)
   {
      y1 = s->y2;
      y2 = s->y1;
   }

   undo_new_tile_buffer(ds1_idx);
   for (y=0; y < glb_ds1[ds1_idx].height; y++)
   {
      for (x=0; x < glb_ds1[ds1_idx].width; x++)
      {
         if ((x >= x1) && (x <= x2) && (y >= y1) && (y <= y2))
            edittile_select_new_one(ds1_idx, x, y);
         else
            edittile_deselect_one_completly(ds1_idx, x, y);
      }
   }
   undo_close_tile_buffer(ds1_idx);
}


// ==========================================================================
// change the Temp selection to be an addition of the current selected tiles
void edittile_change_to_add_permanent_sel(int ds1_idx, TMP_SEL_S * s)
{
   int x, y, x1, y1, x2, y2;


   x1 = s->x1;
   x2 = s->x2;
   if (s->x2 < s->x1)
   {
      x1 = s->x2;
      x2 = s->x1;
   }
   y1 = s->y1;
   y2 = s->y2;
   if (s->y2 < s->y1)
   {
      y1 = s->y2;
      y2 = s->y1;
   }

   undo_new_tile_buffer(ds1_idx);
   for (y=0; y < glb_ds1[ds1_idx].height; y++)
      for (x=0; x < glb_ds1[ds1_idx].width; x++)
         if ((x >= x1) && (x <= x2) && (y >= y1) && (y <= y2))
            edittile_select_one(ds1_idx, x, y);
   undo_close_tile_buffer(ds1_idx);
}


// ==========================================================================
// hide all tiles of the Temp selection
void edittile_change_to_hide_sel(int ds1_idx, TMP_SEL_S * s)
{
   int x, y, x1, y1, x2, y2;


   x1 = s->x1;
   x2 = s->x2;
   if (s->x2 < s->x1)
   {
      x1 = s->x2;
      x2 = s->x1;
   }
   y1 = s->y1;
   y2 = s->y2;
   if (s->y2 < s->y1)
   {
      y1 = s->y2;
      y2 = s->y1;
   }

   for (y = y1; y <= y2; y++)
      for (x = x1; x <= x2; x++)
         edittile_hide_add_one(ds1_idx, x, y);
}


// ==========================================================================
// deselect the tiles of the Temp selection
void edittile_change_to_del_sel(int ds1_idx, TMP_SEL_S * s)
{
   int x, y, x1, y1, x2, y2;


   x1 = s->x1;
   x2 = s->x2;
   if (s->x2 < s->x1)
   {
      x1 = s->x2;
      x2 = s->x1;
   }
   y1 = s->y1;
   y2 = s->y2;
   if (s->y2 < s->y1)
   {
      y1 = s->y2;
      y2 = s->y1;
   }

   undo_new_tile_buffer(ds1_idx);
   for (y = y1; y <= y2; y++)
      for (x = x1; x <= x2; x++)
         edittile_deselect_one(ds1_idx, x, y);
   undo_close_tile_buffer(ds1_idx);
}
#include <stdio.h>
#include <stdlib.h>
#include "structs.h"
#include "error.h"
#include "structs.h"
#include "gfx_custom.h"


// ==========================================================================
// draw a sprite at the zoom 1:div
// dst & sprite MUST be 8bpp color depth both
// dst & sprite MUST be linear bitmaps both (not plannar)
// if color_map point to NULL, regular sprite, else transparent one
void stretch_trans_sprite_8bpp(BITMAP * dst, BITMAP * sprite, int x0, int y0, int div)
{
   int dx1, dy1, dx2, dy2, sx1, sy1, dw, dh, sw, sh;


   // ridiculous cases
   if ((bitmap_color_depth(dst) != 8) || (bitmap_color_depth(sprite) != 8))
      return;
   if (( ! is_linear_bitmap(dst)) || ( ! is_linear_bitmap(sprite)))
      return;

   // clip

   dw = dst->w;
   dh = dst->h;
   if ((x0 >= dw) || (y0 >= dh))
      return;

   sw = sprite->w;
   sh = sprite->h;

   // start
   if (x0 < 0)
   {
      dx1 = 0;
      sx1 = (-x0) * div;
      if (sx1 >= sw)
         return;
   }
   else
   {
      dx1 = x0;
      sx1 = 0;
   }

   if (y0 < 0)
   {
      dy1 = 0;
      sy1 = (-y0) * div;
      if (sy1 >= sh)
         return;
   }
   else
   {
      dy1 = y0;
      sy1 = 0;
   }

   // end
   sw /= div;
   sh /= div;

   dx2 = dx1 + sw - 1 - (sx1 / div);
   if (dx2 >= dw)
      dx2 = dw - 1;

   dy2 = dy1 + sh - 1 - (sy1 / div);
   if (dy2 >= dh)
      dy2 = dh - 1;

   if ((dx2 < 0) || (dy2 < 0))
      return;

   // draw
   {
      int dx, dy, sx, sy;

      dx = dx1;
      dy = dy1;
      sx = sx1;
      sy = sy1;
      if (color_map == NULL)
      {
         // regular sprite
         for(;;)
         {
            if (sprite->line[sy][sx])
               dst->line[dy][dx] = sprite->line[sy][sx];
            dx++;
            if (dx > dx2)
            {
               dx = dx1;
               sx = sx1;
               dy++;
               if (dy > dy2)
                  return;
               else
                  sy += div;
            }
            else
               sx += div;
         }
      }
      else
      {
         // transparent sprite
         for(;;)
         {
            if (sprite->line[sy][sx])
            {
               dst->line[dy][dx] = color_map->data
                                       [ dst->line[dy][dx]    ]
                                       [ sprite->line[sy][sx] ];
            }
            dx++;
            if (dx > dx2)
            {
               dx = dx1;
               sx = sx1;
               dy++;
               if (dy > dy2)
                  return;
               else
                  sy += div;
            }
            else
               sx += div;
         }
      }
   }
}


// ==========================================================================
// draw the shadow projection of a sprite at the zoom 1:div
// dst & sprite MUST be 8bpp color depth both
// dst & sprite MUST be linear bitmaps both (not plannar)
// cmap must point on an array of 256 bytes
// offx and offy are the coordinates of the pivot point of the sprite
void stretch_trans_shadow_8bpp(BITMAP * dst, BITMAP * sprite, int x0, int y0, int div,
                               UBYTE * cmap, int offy)
{
   int dx1, dy1, dx2, dy2, sx1, sy1, sw, sh;


   // ridiculous cases
   if ((bitmap_color_depth(dst) != 8) || (bitmap_color_depth(sprite) != 8))
      return;
   if (( ! is_linear_bitmap(dst)) || ( ! is_linear_bitmap(sprite)))
      return;

   sx1 = 0;
   sy1 = 0;
   sw  = sprite->w / div;
   sh  = sprite->h / (div * 2);

   dy1 = y0 + ((offy - y0) / 2);
   dx1 = x0 - ((offy - y0) / 2);

   dx2 = dx1 + sw - 1;
   dy2 = dy1 + sh - 1;

   // draw
   {
      int dx, dy, sx, sy;

      dx = dx1;
      dy = dy1;
      sx = sx1;
      sy = sy1;
      for(;;)
      {
         if ((dx >= 0) && (dy >= 0) && (dx < dst->w) && (dy < dst->h))
         {
            if (sprite->line[sy][sx])
               dst->line[dy][dx] = cmap[ dst->line[dy][dx] ];
         }
         dx++;
         if (dx > dx2)
         {
            dx1++;
            dx2++;
            dx = dx1;
            sx = sx1;
            dy++;
            if (dy > dy2)
               return;
            else
               sy += div * 2;
         }
         else
            sx += div;
      }
   }
}
#include <stdio.h>
#include "types.h"
#include "error.h"
#include "inicreat.h"


// ==========================================================================
// create a new ds1edit.ini
void ini_create(char * ininame)
{
   FILE * out;
   char tmp[80];

   printf("can't open %s, creating it\n", ininame);
   out = fopen(ininame, "wt");
   if (out == NULL) {
       FATAL_EXIT("can not create %s", ininame);
   }
   fputs(
      "; Paths to the mpqs. When the editor need to read a file from a mpq\n"
      "; it scan first in mod_dir. If not found, in patch_d2. If not found,\n"
      "; in d2exp. If again not found, in d2data (just like the game)\n"
      "; =================================================================\n"
      "d2char   = c:\\program files\\diablo II\\d2char.mpq\n"
      "d2data   = c:\\program files\\diablo II\\d2data.mpq\n"
      "d2exp    = c:\\program files\\diablo II\\d2exp.mpq\n"
      "patch_d2 = c:\\program files\\diablo II\\patch_d2.mpq\n"
      "mod_dir  =\n"
      "\n"
      "; if you don't have a mpq, put a blank, like :\n"
      "; d2exp =\n"
      "\n"
      "; mod_dir is an optional Mod Directory, like :\n"
      "; mod_dir = c:\\program files\\diablo II\\mods\\my_mod\n"
      "\n"
      "\n"
      "; screen configuration\n"
      "; screen_depth can be either 8, 15, 16, 24 or 32 bits per pixel\n"
      ";    (if your video card support it)\n"
      "; if full_screen is not set to YES, it'll be a windowed screen\n"
      ";    (will always fail under MS-DOS)\n"
      "; =============================================================\n"
      "full_screen   = YES\n"
      "screen_width  = 800\n"
      "screen_height = 600\n"
      "screen_depth  = 8\n"
      "\n"
      "\n"
      "; Try to use this refresh rate, if possible. Not all drivers are able to\n"
      "; control this at all, and even when they can, not all rates will be\n"
      "; possible on all hardware, so the actual settings may differ from what\n"
      "; you requested. Some non-exhaustive values : 60, 70, 72, 75, 85, 100, 120\n"
      "; ========================================================================\n"
      "refresh_rate = 60\n"
      "\n"
      "\n"
      "; speed of scrolls, in pixels\n"
      "; ===========================\n"
      "keyb_scroll_x  = 40\n"
      "keyb_scroll_y  = 20\n"
      "mouse_scroll_x = 20\n"
      "mouse_scroll_y = 10\n"
      "edit_scroll_x  = 20\n"
      "edit_scroll_y  = 20\n"
      "\n"
      "\n"
      "; speed of scroll in the Object Editing window, in rows\n"
      "; =====================================================\n"
      "obj_edit_scroll = 2\n"
      "\n"
      "\n"
      "; speed of mouse, larger values slow the mouse, defaut 2\n"
      "; (don't seem to work under Windows XP)\n"
      "; ======================================================\n"
      "mouse_speed_x = 2\n"
      "mouse_speed_y = 2\n"
      "\n"
      "\n"
      "\n"
      "; misc options\n"
      "; ============\n"
      "\n"
      "\n"
      "; default gamma correction\n"
      "; valid value : 0.60, 0.62, [...] 0.98, 1.00, 1.10, 1.20, [...], 3.00\n"
      "; -------------------------------------------------------------------\n"
      "gamma_correction = 1.30\n"
      "\n"
      "\n"
      "; does the editor allow you to use Type 2 objects of higher act ?\n"
      "; if this line is NOT set to YES, the editor will allow it\n"
      "; ---------------------------------------------------------------\n"
      "only_normal_type2 = YES\n"
      "\n"
      "\n"
      "; does the editor always modified the ds1 to have 2 floors layers and\n"
      "; 4 walls layers ?\n"
      "; if this line is NOT set to YES, the editor won't make any change\n"
      "; -------------------------------------------------------------------\n"
      "always_max_layers = YES\n"
      "\n"
      "\n"
      "; resize the sprites when zooming\n"
      "; -------------------------------\n"
      "stretch_sprite = YES\n"
      "\n"
      "\n"
      "; when editing an object, posibility to scroll the main tile editing window\n"
      "; with the arrow keys\n"
      "; -------------------------------------------------------------------------\n"
      "winobj_can_scroll_keyb = YES\n"
      "\n"
      "\n"
      "; when editing an object, posibility to scroll the main tile editing window\n"
      "; with the mouse on the border of the screen\n"
      "; -------------------------------------------------------------------------\n"
      "winobj_can_scroll_mouse = NO\n"
      "\n"
      "\n"
      "; after a Centering (with the 'C' key), wich zoom ?\n"
      "; possible values : NO_CHANGE, 1:1, 1:2, 1:4, 1:8, 1:16\n"
      "; -----------------------------------------------------\n"
      "center_zoom = 1:1\n"
      "\n"
      "\n"
      "; What are the sizes of object tables in DLL for type 1 and 2 ?\n"
      "; normal values are :\n"
      ";    *  60 entries per act for type 1 objects\n"
      ";    * 150 entries per act for type 2 objects\n"
      "; You shouldn't change these values unless you have a modified DLL\n"
      "; ----------------------------------------------------------------\n"
      "nb_type1_per_act = 60\n"
      "nb_type2_per_act = 150\n"
      "\n"
      "\n"
      "; minimize file size of saved ds1 ?\n"
      "; ---------------------------------\n"
      "ds1_saved_minimize = YES\n"
      "\n"
      "\n"
      "; reduce scrolling speed when zooming out ?\n"
      "; -----------------------------------------\n"
      "lower_speed_zoom_out = NO\n"
      "\n"
      "\n"
      "; enable the workspace feature ?\n"
      "; ------------------------------\n"
      "workspace_enable = YES\n"
      , out
   );

   fclose(out);
   printf("new ds1edit.ini was created\n");
   fprintf(stderr, "new ds1edit.ini was created\n");
}
#include "structs.h"
#include "error.h"
#include <string.h>
#include "iniread.h"


// ==========================================================================
void ini_read(char * ininame)
{
   int          i;
   int          val;
   int          n;
   int          len;
   int          is_ok = TRUE;

   char         tmp[256];
   char        *buf;
   char       **tmpptr;

   const char  *str;

   typedef enum {T_NULL, T_MPQ, T_MOD, T_STR, T_INT, T_GAM, T_YES, T_ZOOM} TYPE_E;

   static struct {
      char      name[30];
      TYPE_E    type;
      void     *data_ptr;
      void     *def;
   }datas[] = {
      { ( "d2char"                  ),   T_MPQ,   &( glb_config.mpq_file[3]          ),   (void*)( ""     )   },
      { ( "d2data"                  ),   T_MPQ,   &( glb_config.mpq_file[2]          ),   (void*)( ""     )   },
      { ( "d2exp"                   ),   T_MPQ,   &( glb_config.mpq_file[1]          ),   (void*)( ""     )   },
      { ( "patch_d2"                ),   T_MPQ,   &( glb_config.mpq_file[0]          ),   (void*)( ""     )   },
      { ( "mod_dir"                 ),   T_MOD,   &( glb_config.mod_dir[0]           ),   (void*)( ""     )   },
      { ( "full_screen"             ),   T_YES,   &( glb_config.fullscreen           ),   (void*)( "YES"  )   },
      { ( "screen_width"            ),   T_INT,   &( glb_config.screen.width         ),   (void*)( 800    )   },
      { ( "screen_height"           ),   T_INT,   &( glb_config.screen.height        ),   (void*)( 600    )   },
      { ( "screen_depth"            ),   T_INT,   &( glb_config.screen.depth         ),   (void*)( 8      )   },
      { ( "refresh_rate"            ),   T_INT,   &( glb_config.screen.refresh       ),   (void*)( 60     )   },
      { ( "keyb_scroll_x"           ),   T_INT,   &( glb_config.scroll.keyb.x        ),   (void*)( 40     )   },
      { ( "keyb_scroll_y"           ),   T_INT,   &( glb_config.scroll.keyb.y        ),   (void*)( 20     )   },
      { ( "mouse_scroll_x"          ),   T_INT,   &( glb_config.scroll.mouse.x       ),   (void*)( 20     )   },
      { ( "mouse_scroll_y"          ),   T_INT,   &( glb_config.scroll.mouse.y       ),   (void*)( 10     )   },
      { ( "edit_scroll_x"           ),   T_INT,   &( glb_config.scroll.edit.x        ),   (void*)( 20     )   },
      { ( "edit_scroll_y"           ),   T_INT,   &( glb_config.scroll.edit.y        ),   (void*)( 20     )   },
      { ( "obj_edit_scroll"         ),   T_INT,   &( glb_config.scroll.obj_edit      ),   (void*)( 2      )   },
      { ( "mouse_speed_x"           ),   T_INT,   &( glb_config.mouse_speed.x        ),   (void*)( 2      )   },
      { ( "mouse_speed_y"           ),   T_INT,   &( glb_config.mouse_speed.y        ),   (void*)( 2      )   },
      { ( "gamma_correction"        ),   T_GAM,   &( glb_config.gamma                ),   (void*)( "1.30" )   },
      { ( "only_normal_type2"       ),   T_YES,   &( glb_config.normal_type2         ),   (void*)( "YES"  )   },
      { ( "always_max_layers"       ),   T_YES,   &( glb_config.always_max_layers    ),   (void*)( "YES"  )   },
      { ( "stretch_sprite"          ),   T_YES,   &( glb_config.stretch_sprites      ),   (void*)( "YES"  )   },
      { ( "winobj_can_scroll_keyb"  ),   T_YES,   &( glb_config.winobj_scroll_keyb   ),   (void*)( "YES"  )   },
      { ( "winobj_can_scroll_mouse" ),   T_YES,   &( glb_config.winobj_scroll_mouse  ),   (void*)( "NO"   )   },
      { ( "center_zoom"             ),   T_ZOOM,  &( glb_config.center_zoom          ),   (void*)( "1:1"  )   },
      { ( "nb_type1_per_act"        ),   T_INT,   &( glb_config.nb_type1_per_act     ),   (void*)( 60     )   },
      { ( "nb_type2_per_act"        ),   T_INT,   &( glb_config.nb_type2_per_act     ),   (void*)( 150    )   },
      { ( "ds1_saved_minimize"      ),   T_YES,   &( glb_config.minimize_ds1         ),   (void*)( "YES"  )   },
      { ( "lower_speed_zoom_out"    ),   T_YES,   &( glb_config.lower_speed_zoom_out ),   (void*)( "NO"   )   },
      { ( "workspace_enable"        ),   T_YES,   &( glb_config.workspace_enable     ),   (void*)( "YES"  )   },
      { ( ""                        ),   T_NULL,  NULL,                                   NULL              }
   };


   DEBUG_MESSAGE("ini_read():in\n");
   DEBUG_MESSAGE("ini_read(), load ds1edit.ini\n");
   
   set_config_file(ininame);
   i = 0;

   while (datas[i].type != T_NULL) {
      str = get_config_string(NULL, datas[i].name, (const char *) datas[i].def);
      if (str == NULL) {
          WARNING_MESSAGE("line not found : <%s>\n", datas[i].name);
         is_ok = FALSE;
      }
      switch (datas[i].type) {

         case T_STR :
            if (strlen(str)){
               datas[i].data_ptr = (char *) str;
            }
            break;

         case T_INT :
            val = get_config_int(NULL, datas[i].name, (int) datas[i].def);
            * ((int *) datas[i].data_ptr) = val;
            break;

         // gamma correction
         case T_GAM :
            n=0;
            while ( (n < GC_MAX) && (strcmp(str, glb_gamma_str[n].str) != 0) ){
               n++;
            }
            if (n < GC_MAX){
               glb_config.gamma = glb_gamma_str[n].val;
            }
            break;

         // mpq file
         case T_MPQ :
            len = strlen(str);
            if (len) {
               buf = (char *) malloc(sizeof(char) * (len+1));
               if (buf == NULL){
                   FATAL_EXIT("read_ini(), malloc() error on Mpq name");
               }else{
                  strcpy(buf, str);
                  tmpptr = datas[i].data_ptr;
                  * tmpptr = buf;
               }
            }
            break;

         // mod directory
         case T_MOD :
            len = strlen(str);
            if (len) {
               buf = (char *) malloc(sizeof(char) * (len+1));
               if(buf == NULL){
                   FATAL_EXIT("read_ini(), malloc() error on Mod name");
               }else{
                  strcpy(buf, str);
                  if ((buf[strlen(buf)-1] == '\\') || (buf[strlen(buf)-1] == '/')){
                     buf[strlen(buf)-1] = 0;
                  }
                  tmpptr = datas[i].data_ptr;
                  * tmpptr = buf;
               }
            }
            break;

         // read a YES/NO string, but store it as TRUE/FALSE
         case T_YES :
            if (strlen(str)){
               if (stricmp(str, "YES") == 0){
                  *((int *) datas[i].data_ptr) = TRUE;
               }else{
                  *((int *) datas[i].data_ptr) = FALSE;
               }
            }
            break;

         // zoom string
         case T_ZOOM :
            if (strlen(str)){
               // default value
               * ((int *) datas[i].data_ptr) = -1;

               // read value
               if (stricmp(str, "1:1") == 0){
                  * ((int *) datas[i].data_ptr) = ZM_11;
               }else if (stricmp(str, "1:2") == 0){
                  * ((int *) datas[i].data_ptr) = ZM_12;
               }else if (stricmp(str, "1:4") == 0){
                  * ((int *) datas[i].data_ptr) = ZM_14;
               }else if (stricmp(str, "1:8") == 0){
                  * ((int *) datas[i].data_ptr) = ZM_18;
               }else if (stricmp(str, "1:16") == 0){
                  * ((int *) datas[i].data_ptr) = ZM_116;
               }
            }
            datas[i].data_ptr = (char *) str;
            break;

      }
      i++;
   }
   if(is_ok != TRUE){
       FATAL_EXIT("%s is not valid.\ndelete it, and relaunch this prog to create a new good one,\nthen edit it to make changes where necessary, then relaunch this prog", ininame);
   }
}
#include "structs.h"
#include "wpreview.h"
#include "editobj.h"
#include "misc.h"
#include "ds1save.h"
#include "msg_save.h"
#include "edittile.h"
#include "undo.h"
#include "animdata.h"
#include "anim.h"
#include "txtread.h"
#include "wbits.h"
#include "wedit.h"
#include "msg_quit.h"
#include "interfac.h"

struct timeval  _my_delay;
int             _my_count = 1;

void _my_set_d(){
    _my_delay.tv_sec  = 0;
    _my_delay.tv_usec = 40*1000;
}

void my_set_fps(){

    _my_count++;
    _my_set_d();

    ds1edit_counter_tick();
    if( _my_count == 26 ){
        ds1edit_counter_fps();
        _my_count = 1;
    }
    //select( 0, NULL, NULL, NULL, &_my_delay );

}


// ==========================================================================
// MAIN loop
void interfac_user_handler(int start_ds1_idx)
{
    int  ds1_idx, done, cx, cy, n, i, dx, dy, old_ds1_idx=0;
    int  old_mouse_x = mouse_x, old_mouse_y=mouse_y, old_mouse_b=0;
    int  cur_mouse_z = 0, old_mouse_z = 0;
    int  old_cell_x = -1, old_cell_y = -1;
    int  old_identical_x = -1, old_identical_y = -1;
    int  ticks_elapsed, ret;
    int  can_swich_mode, key_func_code[7] = {KEY_F1, KEY_F2, KEY_F5, KEY_F6, KEY_F7, KEY_F8, KEY_F11};
    TMP_SEL_S   tmp_sel;
    PASTE_POS_S paste_pos;
    char        tmp[150];
    MODE_E      old_mode = 0;
    IT_ENUM     itype = IT_NULL;
    int         group_changed, old_group, found;
    BITMAP      * old_screen_buff = NULL;


    // init
    tmp_sel.x1            = tmp_sel.x2     = tmp_sel.y1 = tmp_sel.y2 = 0;
    tmp_sel.old_x2        = tmp_sel.old_y2 = 0;
    tmp_sel.type          = TMP_NULL;
    tmp_sel.start         = FALSE;
    paste_pos.old_ds1_idx = 0;
    paste_pos.old_x       = 0;
    paste_pos.old_y       = 0;
    paste_pos.src_ds1_idx = 0;
    paste_pos.start_x     = 0;
    paste_pos.start_y     = 0;
    paste_pos.start       = FALSE;
    paste_pos.is_cut      = FALSE;
    paste_pos.cut_saved   = FALSE;
    ds1_idx               = start_ds1_idx;
    done                  = FALSE;

    // typedef enum MODE_E
    // {
    //     MOD_T, // Edit Tiles
    //     MOD_O, // Edit Objects
    //     MOD_P, // Edit Paths
    //     MOD_L, // Preview with Lights
    //     MOD_MAX
    // } MODE_E;


    // main loop
    while (! done) {

        my_set_fps();

        can_swich_mode = TRUE;
        if (glb_ds1edit.mode == MOD_P) {
            // edit path
            if (glb_ds1[ds1_idx].path_edit_win.mode != PEM_NONE) {
                can_swich_mode = FALSE;
            } else if (glb_ds1[ds1_idx].path_edit_win.obj_dirty == TRUE) {
                can_swich_mode = FALSE;
            }
        }

        old_mouse_x = mouse_x;
        old_mouse_y = mouse_y;
        old_mouse_b = mouse_b;

        cur_mouse_z = mouse_z;

        // keep the current mouse coordinates for the entire loop process

        // which tile (or sub-tile) is RIGHT NOW under the mouse ?
        mouse_to_tile(ds1_idx, &cx, &cy);
        if (glb_ds1edit.mode == MOD_T) {
            if (cx < 0) {
                cx = 0;
            } else if (cx >= glb_ds1[ds1_idx].width) {
                cx = glb_ds1[ds1_idx].width - 1;
            }
            if (cy < 0) {
                cy = 0;
            } else if (cy >= glb_ds1[ds1_idx].height) {
                cy = glb_ds1[ds1_idx].height - 1;
            }
        } else {
            cx -= 2;
            cy += 2;
            if (cx < 0) {
                cx = 0;
            } else if (cx >= glb_ds1[ds1_idx].width * 5 - 1) {
                cx = glb_ds1[ds1_idx].width * 5 - 1;
            }
            if (cy < 0) {
                cy = 0;
            } else if (cy >= glb_ds1[ds1_idx].height * 5 - 1) {
                cy = glb_ds1[ds1_idx].height * 5 - 1;
            }
        }

        // For debug
        // glb_ds1edit.mode = MOD_O;
        // Ëøô‰∏™ÊòØ‰∏∫‰∫ÜËÆ©ÈÇ£‰∏™Ê°ÜÊ°ÜÂÖ®ÈÉ®Âá∫Êù•ËÄåÂ∑≤
        // ÊòæÁ§∫ÊØè‰∏Ä‰∏™Áâ©‰ΩìÊòØ‰∏™Á•ûÈ©¨

        if (glb_ds1edit.mode == MOD_O) {
            editobj_handler( ds1_idx, cx, cy, old_mouse_x, old_mouse_y, old_mouse_b );
        }

        if ((cx != old_cell_x) || (cy != old_cell_y)) {
            old_cell_x      = cx;
            old_cell_y      = cy;
            old_identical_x = -1;
            old_identical_y = -1;
        }

        // check if need to redraw the screen because of floor animation
        ticks_elapsed = glb_ds1edit.ticks_elapsed;
        if ( ticks_elapsed && (glb_ds1[ds1_idx].animations_layer_mask == 1)) {
            // animated floor rate = 10 fps
            // therefore it's at 2/5 of 25 fps
            // but internal unit is in 5th
            glb_ds1[ds1_idx].cur_anim_floor_frame += ticks_elapsed * 2;
        } else {
            glb_ds1edit.ticks_elapsed = 0;
        }

        // redraw the whole screen
        wpreview_draw_tiles(ds1_idx);
        glb_ds1edit.fps++;

        // scroll UP / DOWN / LEFT / RIGHT

        // if the Object Editing Window is display
        // Ê≤°ÂèëÁé∞‰ªÄ‰πàÊïàÊûú, ÂÄíÊòØesc‰∏çËÉΩÁî®‰∫Ü
        // glb_ds1[ds1_idx].draw_edit_obj = TRUE;

        if (glb_ds1[ds1_idx].draw_edit_obj == TRUE) {
            // ËøôÈáåÊ≤°ÊúâÊâßË°åÂìà
            if (glb_config.winobj_scroll_keyb == TRUE) {
                // can scroll by keyboard
                if (key[KEY_UP]) {
                    glb_ds1edit.win_preview.y0 -= glb_ds1[ds1_idx].cur_scroll.keyb.y;
                }
                if (key[KEY_DOWN]) {
                    glb_ds1edit.win_preview.y0 += glb_ds1[ds1_idx].cur_scroll.keyb.y;
                }
                if (key[KEY_LEFT]) {
                    glb_ds1edit.win_preview.x0 -= glb_ds1[ds1_idx].cur_scroll.keyb.x;
                }
                if (key[KEY_RIGHT]) {
                    glb_ds1edit.win_preview.x0 += glb_ds1[ds1_idx].cur_scroll.keyb.x;
                }
            }

            if (glb_config.winobj_scroll_mouse == TRUE) {
                // can scroll by mouse
                if (old_mouse_y == 0) {
                    glb_ds1edit.win_preview.y0 -= glb_ds1[ds1_idx].cur_scroll.mouse.y;
                }
                if (old_mouse_y == glb_config.screen.height - 1) {
                    glb_ds1edit.win_preview.y0 += glb_ds1[ds1_idx].cur_scroll.mouse.y;
                }
                if (old_mouse_x == 0) {
                    glb_ds1edit.win_preview.x0 -= glb_ds1[ds1_idx].cur_scroll.mouse.x;
                }
                if (old_mouse_x == glb_config.screen.width  - 1) {
                    glb_ds1edit.win_preview.x0 += glb_ds1[ds1_idx].cur_scroll.mouse.x;
                }
            }
        } else {
			// ÊâßË°åÁöÑÊòØËøôÈáå
            if (key[KEY_UP]) {
                glb_ds1edit.win_preview.y0 -= glb_ds1[ds1_idx].cur_scroll.keyb.y;
            } else if (old_mouse_y == 0) {
                glb_ds1edit.win_preview.y0 -= glb_ds1[ds1_idx].cur_scroll.mouse.y;
            }

            if (key[KEY_DOWN]) {
                glb_ds1edit.win_preview.y0 += glb_ds1[ds1_idx].cur_scroll.keyb.y;
            } else if (old_mouse_y == glb_config.screen.height - 1) {
                glb_ds1edit.win_preview.y0 += glb_ds1[ds1_idx].cur_scroll.mouse.y;
            }

            if (key[KEY_LEFT]) {
                glb_ds1edit.win_preview.x0 -= glb_ds1[ds1_idx].cur_scroll.keyb.x;
            } else if (old_mouse_x == 0) {
                glb_ds1edit.win_preview.x0 -= glb_ds1[ds1_idx].cur_scroll.mouse.x;
            }

            if (key[KEY_RIGHT]) {
                glb_ds1edit.win_preview.x0 += glb_ds1[ds1_idx].cur_scroll.keyb.x;
            } else if (old_mouse_x == glb_config.screen.width  - 1) {
                glb_ds1edit.win_preview.x0 += glb_ds1[ds1_idx].cur_scroll.mouse.x;
            }
        }

        // zoom
        if ( (key[KEY_MINUS_PAD] || key[KEY_MINUS] || (cur_mouse_z < old_mouse_z) ) && glb_ds1[ds1_idx].cur_zoom < ZM_116 ) {
            if (key[KEY_MINUS_PAD] || key[KEY_MINUS]) {
                while(key[KEY_MINUS_PAD] || key[KEY_MINUS]) {
                    // wait until the MINUS key is released
                }
            }
            glb_ds1[ds1_idx].own_wpreview.x0 = glb_ds1edit.win_preview.x0;
            glb_ds1[ds1_idx].own_wpreview.y0 = glb_ds1edit.win_preview.y0;
            glb_ds1[ds1_idx].own_wpreview.w  = glb_ds1edit.win_preview.w;
            glb_ds1[ds1_idx].own_wpreview.h  = glb_ds1edit.win_preview.h;
            change_zoom(ds1_idx, glb_ds1[ds1_idx].cur_zoom + 1);
            glb_ds1edit.win_preview.x0 = glb_ds1[ds1_idx].own_wpreview.x0;
            glb_ds1edit.win_preview.y0 = glb_ds1[ds1_idx].own_wpreview.y0;
        }

        if ( (key[KEY_PLUS_PAD] || key[KEY_EQUALS] || (cur_mouse_z > old_mouse_z) ) && glb_ds1[ds1_idx].cur_zoom > ZM_11 ) {
            if (key[KEY_PLUS_PAD] || key[KEY_EQUALS]) {
                while(key[KEY_PLUS_PAD] || key[KEY_EQUALS]) {
                    // wait until the '+' and '=' key are released
                }
            }
            glb_ds1[ds1_idx].own_wpreview.x0 = glb_ds1edit.win_preview.x0;
            glb_ds1[ds1_idx].own_wpreview.y0 = glb_ds1edit.win_preview.y0;
            glb_ds1[ds1_idx].own_wpreview.w  = glb_ds1edit.win_preview.w;
            glb_ds1[ds1_idx].own_wpreview.h  = glb_ds1edit.win_preview.h;
            change_zoom(ds1_idx, glb_ds1[ds1_idx].cur_zoom - 1);
            glb_ds1edit.win_preview.x0 = glb_ds1[ds1_idx].own_wpreview.x0;
            glb_ds1edit.win_preview.y0 = glb_ds1[ds1_idx].own_wpreview.y0;
        }

        if (old_mouse_z != cur_mouse_z) {
            old_mouse_z = cur_mouse_z;
            if (mouse_b & 4) {
                if (glb_ds1edit.mode == MOD_T) {
                    // Center to mouse in TILE mode
                    cx++;
                    dx = (cy * -glb_ds1[ds1_idx].tile_w / 2) + (cx * glb_ds1[ds1_idx].tile_w / 2);
                    dy = (cy *  glb_ds1[ds1_idx].tile_h / 2) + (cx * glb_ds1[ds1_idx].tile_h / 2);
                    cx--;
                    glb_ds1[ds1_idx].own_wpreview.x0 = glb_ds1edit.win_preview.x0 = dx - glb_ds1edit.win_preview.w / 2;
                    glb_ds1[ds1_idx].own_wpreview.y0 = glb_ds1edit.win_preview.y0 = dy - glb_ds1edit.win_preview.h / 2;
                    glb_ds1[ds1_idx].own_wpreview.w  = glb_ds1edit.win_preview.w;
                    glb_ds1[ds1_idx].own_wpreview.h  = glb_ds1edit.win_preview.h;
                    glb_ds1edit.win_preview.x0       = glb_ds1[ds1_idx].own_wpreview.x0;
                    glb_ds1edit.win_preview.y0       = glb_ds1[ds1_idx].own_wpreview.y0;
                    position_mouse(glb_ds1edit.win_preview.w / 2, glb_ds1edit.win_preview.h / 2);
                } else {
                    // Center to mouse in OBJECT / PATH mode
                    cx /= 5;
                    cy /= 5;
                    cx++;
                    dx = (cy * -glb_ds1[ds1_idx].tile_w / 2) + (cx * glb_ds1[ds1_idx].tile_w / 2);
                    dy = (cy *  glb_ds1[ds1_idx].tile_h / 2) + (cx * glb_ds1[ds1_idx].tile_h / 2);
                    cx--;
                    cx *= 5;
                    cy *= 5;
                    glb_ds1[ds1_idx].own_wpreview.x0 = glb_ds1edit.win_preview.x0 = dx - glb_ds1edit.win_preview.w / 2;
                    glb_ds1[ds1_idx].own_wpreview.y0 = glb_ds1edit.win_preview.y0 = dy - glb_ds1edit.win_preview.h / 2;
                    glb_ds1[ds1_idx].own_wpreview.w  = glb_ds1edit.win_preview.w;
                    glb_ds1[ds1_idx].own_wpreview.h  = glb_ds1edit.win_preview.h;
                    glb_ds1edit.win_preview.x0   = glb_ds1[ds1_idx].own_wpreview.x0;
                    glb_ds1edit.win_preview.y0   = glb_ds1[ds1_idx].own_wpreview.y0;
                    position_mouse(glb_ds1edit.win_preview.w / 2, glb_ds1edit.win_preview.h / 2);
                }
            }
        }

        // layers toggle
        if (key[KEY_LSHIFT] || key[KEY_RSHIFT]) {
            // if shift pressed, just 1 layer will be active
            for (n=0; n<7; n++) {
                if (key[key_func_code[n]]) {
                    for (i=0; i<FLOOR_MAX_LAYER; i++) {
                        glb_ds1[ds1_idx].floor_layer_mask[i] = 0;
                    }

                    if (key[KEY_F11]) {
                        for (i=0; i<SHADOW_MAX_LAYER; i++) {
                            glb_ds1[ds1_idx].shadow_layer_mask[i] = 3;
                        }
                    } else {
                        for (i=0; i<SHADOW_MAX_LAYER; i++) {
                            glb_ds1[ds1_idx].shadow_layer_mask[i] = 0;
                        }
                    }

                    for (i=0; i<WALL_MAX_LAYER; i++) {
                        glb_ds1[ds1_idx].wall_layer_mask[i] = 0;
                    }

                    break;
                }
            }
        }
        if (key[KEY_LCONTROL] || key[KEY_RCONTROL]) {
            // if control pressed, just 1 layer will be inactive
            for (n=0; n<7; n++) {
                if (key[key_func_code[n]]) {
                    for (i=0; i<FLOOR_MAX_LAYER; i++) {
                        glb_ds1[ds1_idx].floor_layer_mask[i] = 1;
                    }

                    for (i=0; i<SHADOW_MAX_LAYER; i++) {
                        glb_ds1[ds1_idx].shadow_layer_mask[i] = 3;
                    }

                    for (i=0; i<WALL_MAX_LAYER; i++) {
                        glb_ds1[ds1_idx].wall_layer_mask[i] = 1;
                    }

                    break;
                }
            }
        }
        if (key[KEY_F1]) {
            while(key[KEY_F1]) {
                // wait until the 'F' key is released
            }
            glb_ds1[ds1_idx].floor_layer_mask[0] = 1 - glb_ds1[ds1_idx].floor_layer_mask[0];
        }
        if (key[KEY_F2]) {
            while(key[KEY_F2]) {
                // wait until the 'F2' key is released
            }
            glb_ds1[ds1_idx].floor_layer_mask[1] = 1 - glb_ds1[ds1_idx].floor_layer_mask[1];
        }
        if (key[KEY_F5]) {
            while(key[KEY_F5]) {
                // wait until the 'F5' key is released
            }
            glb_ds1[ds1_idx].wall_layer_mask[0] = 1 - glb_ds1[ds1_idx].wall_layer_mask[0];
        }
        if (key[KEY_F6]) {
            while(key[KEY_F6]) {
                // wait until the 'F6' key is released
            }
            glb_ds1[ds1_idx].wall_layer_mask[1] = 1 - glb_ds1[ds1_idx].wall_layer_mask[1];
        }
        if (key[KEY_F7]) {
            while(key[KEY_F7]) {
                // wait until the 'F7' key is released
            }
            glb_ds1[ds1_idx].wall_layer_mask[2] = 1 - glb_ds1[ds1_idx].wall_layer_mask[2];
        }
        if (key[KEY_F8]) {
            while(key[KEY_F8]) {
                // wait until the 'F8' key is released
            }
            glb_ds1[ds1_idx].wall_layer_mask[3] = 1 - glb_ds1[ds1_idx].wall_layer_mask[3];
        }

        // special tiles layer
        if (key[KEY_F9]) {
            while(key[KEY_F9]) {
                // wait until the 'F9' key is released
            }
            glb_ds1[ds1_idx].special_layer_mask = 1 - glb_ds1[ds1_idx].special_layer_mask;
        }

        // animation layer
        if (key[KEY_F3]) {
            while(key[KEY_F3]) {
                // wait until the 'F3' key is released
            }
            glb_ds1[ds1_idx].animations_layer_mask++;
            if (glb_ds1[ds1_idx].animations_layer_mask == 3) {
                glb_ds1[ds1_idx].animations_layer_mask = 0;
            }
        }

        // objects layer
        if (key[KEY_F4] && (glb_ds1edit.mode != MOD_O)) {
            while(key[KEY_F4]) {
                // wait until the 'F4' key is released
            }
            glb_ds1[ds1_idx].objects_layer_mask++;
            if (glb_ds1[ds1_idx].objects_layer_mask >= OL_MAX) {
                glb_ds1[ds1_idx].objects_layer_mask = OL_NONE;
            }
        }

        // paths layer
        if (key[KEY_F10] && (glb_ds1edit.mode != MOD_P)) {
            while(key[KEY_F10]) {
                // wait until the 'F10' key is released
            }
            glb_ds1[ds1_idx].paths_layer_mask = 1 - glb_ds1[ds1_idx].paths_layer_mask;
        }

        // shadow mode
        if (key[KEY_F11]) {
            while(key[KEY_F11]) {
                // wait until the 'F11' key is released
            }
            if (key[KEY_LSHIFT] || key[KEY_RSHIFT]) {
                glb_ds1[ds1_idx].shadow_layer_mask[0]--;
                if (glb_ds1[ds1_idx].shadow_layer_mask[0] < 0) {
                    glb_ds1[ds1_idx].shadow_layer_mask[0] = 3;
                }
            } else {
                glb_ds1[ds1_idx].shadow_layer_mask[0]++;
                if (glb_ds1[ds1_idx].shadow_layer_mask[0] >= 4) {
                    glb_ds1[ds1_idx].shadow_layer_mask[0] = 0;
                }
            }
        }

        // walkable infos
        if (key[KEY_SPACE]) {
            while(key[KEY_SPACE]) {
                // wait until the SPACE key is released
            }
            glb_ds1[ds1_idx].walkable_layer_mask++;
            if (glb_ds1[ds1_idx].walkable_layer_mask >= 3) {
                glb_ds1[ds1_idx].walkable_layer_mask = 0;
            }
        }

        if (key[KEY_T]) {
            while(key[KEY_T]) {
                // wait until the 'T' key is released
            }
            glb_ds1[ds1_idx].subtile_help_display = 1 - glb_ds1[ds1_idx].subtile_help_display;
        }

        // gamma correction
        if (key[KEY_F12]) {
            if (key[KEY_LSHIFT] || key[KEY_RSHIFT]) {
                if (glb_ds1edit.cur_gamma > GC_060) {
                    rest(80);
                    glb_ds1edit.cur_gamma--;
                    misc_update_pal_with_gamma();
                    set_palette(glb_ds1edit.vga_pal[glb_ds1[ds1_idx].act - 1]);
                }
            } else {
                if (glb_ds1edit.cur_gamma < GC_300) {
                    rest(80);
                    glb_ds1edit.cur_gamma++;
                    misc_update_pal_with_gamma();
                    set_palette(glb_ds1edit.vga_pal[glb_ds1[ds1_idx].act - 1]);
                }
            }
        }

        // Home (center the map)
        if (key[KEY_HOME]) {
            while (key[KEY_HOME]) {
                // wait until the HOME key is released
            }
            cx = glb_ds1[ds1_idx].width/2 + 1;
            cy = glb_ds1[ds1_idx].height/2;
            dx = (cy * -glb_ds1[ds1_idx].tile_w / 2) + (cx * glb_ds1[ds1_idx].tile_w / 2);
            dy = (cy *  glb_ds1[ds1_idx].tile_h / 2) + (cx * glb_ds1[ds1_idx].tile_h / 2);
            glb_ds1[ds1_idx].own_wpreview.x0 = glb_ds1edit.win_preview.x0 = dx - glb_ds1edit.win_preview.w / 2;
            glb_ds1[ds1_idx].own_wpreview.y0 = glb_ds1edit.win_preview.y0 = dy - glb_ds1edit.win_preview.h / 2;
        }

        // Backspace (show all layers)
        if (key[KEY_BACKSPACE]) {
            while (key[KEY_BACKSPACE]) {
                // wait until the BACKSPACE key is released
            }
            for (i=0; i<FLOOR_MAX_LAYER; i++) {
                glb_ds1[ds1_idx].floor_layer_mask[i]  = 1;
            }
            for (i=0; i<WALL_MAX_LAYER; i++) {
                glb_ds1[ds1_idx].wall_layer_mask[i]   = 1;
            }
            for (i=0; i<SHADOW_MAX_LAYER; i++) {
                glb_ds1[ds1_idx].shadow_layer_mask[i] = 3;
            }
        }

        // P ('P'rintscreen = screenshot)
        if (key[KEY_P]) {
            if ((key[KEY_LSHIFT] || key[KEY_RSHIFT])) {
                // BIG screenshot (complete map)
                old_screen_buff = glb_ds1edit.screen_buff;
                if (wpreview_draw_tiles_big_screenshot(ds1_idx) == 0) {
                    // big screenshot is ready
                    sprintf(tmp, "screenshot-%05i.bmp", glb_ds1edit.screenshot_num);
                    while (file_exists(tmp, -1, NULL)) {
                        glb_ds1edit.screenshot_num++;
                        sprintf(tmp, "screenshot-%05i.bmp", glb_ds1edit.screenshot_num);
                    }

                    // handle palette
                    if (glb_ds1edit.cmd_line.force_pal_num == -1) {
                        // use .ds1 act value for palette
                        save_bmp(tmp, glb_ds1edit.screen_buff, glb_ds1edit.vga_pal[glb_ds1[ds1_idx].act - 1]);
                    } else {
                        // use force_pal value for palette
                        save_bmp(tmp, glb_ds1edit.screen_buff, glb_ds1edit.vga_pal[glb_ds1edit.cmd_line.force_pal_num - 1]);
                    }

                    // free temp bitmap
                    destroy_bitmap(glb_ds1edit.screen_buff);
                }

                while ((key[KEY_LSHIFT] || key[KEY_RSHIFT])) {
                    // wait until Shift key is relased
                }
                glb_ds1edit.screen_buff = old_screen_buff;
            } else {
                // normal screenshot (visible screen only)
                sprintf(tmp, "screenshot-%05i.pcx", glb_ds1edit.screenshot_num);
                while (file_exists(tmp, -1, NULL)) {
                    glb_ds1edit.screenshot_num++;
                    sprintf(tmp, "screenshot-%05i.pcx", glb_ds1edit.screenshot_num);
                }

                // draw the mouse cursor onto the buffer
                draw_sprite( glb_ds1edit.screen_buff, glb_ds1edit.mouse_cursor[glb_ds1edit.mode], old_mouse_x - 1, old_mouse_y - 1 );

                // handle palette
                if (glb_ds1edit.cmd_line.force_pal_num == -1) {
                    // use .ds1 act value for palette
                    save_pcx(tmp, glb_ds1edit.screen_buff, glb_ds1edit.vga_pal[glb_ds1[ds1_idx].act - 1]);
                    misc_pcx_put_d2_palette(tmp, glb_ds1[ds1_idx].act - 1);
                } else {
                    // use force_pal value for palette
                    save_pcx(tmp, glb_ds1edit.screen_buff, glb_ds1edit.vga_pal[glb_ds1edit.cmd_line.force_pal_num - 1]);
                    misc_pcx_put_d2_palette(tmp, glb_ds1edit.cmd_line.force_pal_num - 1);
                }
            }

            while (key[KEY_P]) {
                // wait until P is released
            }

            // the buffer was saved
            glb_ds1edit.screenshot_num++;
        }

        // S
        if (key[KEY_S]) {
            if (key[KEY_LCONTROL] || key[KEY_RCONTROL]) {
                // CTRL + S : save the ds1, in the current state, incremental save
                ds1_save(ds1_idx, FALSE);
                while (key[KEY_S]) {
                    // wait until the S key is not pressed anymore
                }
                ret = msg_save_main();
                switch (ret) {
                    case -1 :
                        // error
                        done = TRUE;
                        break;

                    case 0 :
                        // ok
                        break;
                }
            } else if (glb_ds1edit.mode == MOD_T) {
                // (Show all precedently hiden tiles)
                while (key[KEY_S]) {
                    // wait until the 'S' key is released
                }
                edittile_unhide_all(ds1_idx);
            }
        }

        // 'C' : either Copy or Center
        if (key[KEY_C]) {
            if (glb_ds1edit.mode == MOD_T) {
                // TILE mode
                if (key[KEY_LCONTROL] || key[KEY_RCONTROL]) {
                    // CTRL + C : copy selected layers (copy / paste)
                    if (paste_pos.start == FALSE) {
                        for (i=0; i<DS1_MAX; i++) {
                            if (strlen(glb_ds1[i].name)) {
                                edittile_paste_prepare(i);
                            }
                        }
                        paste_pos.src_ds1_idx = ds1_idx;
                        paste_pos.old_ds1_idx = ds1_idx;
                        paste_pos.start       = TRUE;
                        paste_pos.is_cut      = FALSE; // just a 'COPY'
                        paste_pos.cut_saved   = FALSE;
                        paste_pos.old_x       = cx;
                        paste_pos.old_y       = cy;
                        edittile_middle_select( ds1_idx, & paste_pos.start_x, & paste_pos.start_y);
                        edittile_paste_preview(ds1_idx, cx - paste_pos.start_x, cy - paste_pos.start_y, & paste_pos);

                        while (key[KEY_C]) {
                            // wait until the 'C' key is released
                        }
                    }
                } else {
                    // Center to mouse in TILE mode
                    while (key[KEY_C]) {
                        // wait until 'C' is released
                    }
                    cx++;
                    dx = (cy * -glb_ds1[ds1_idx].tile_w / 2) + (cx * glb_ds1[ds1_idx].tile_w / 2);
                    dy = (cy *  glb_ds1[ds1_idx].tile_h / 2) + (cx * glb_ds1[ds1_idx].tile_h / 2);
                    cx--;
                    glb_ds1[ds1_idx].own_wpreview.x0 = glb_ds1edit.win_preview.x0 = dx - glb_ds1edit.win_preview.w / 2;
                    glb_ds1[ds1_idx].own_wpreview.y0 = glb_ds1edit.win_preview.y0 = dy - glb_ds1edit.win_preview.h / 2;
                    glb_ds1[ds1_idx].own_wpreview.w  = glb_ds1edit.win_preview.w;
                    glb_ds1[ds1_idx].own_wpreview.h  = glb_ds1edit.win_preview.h;
                    if (glb_config.center_zoom != -1) {
                        change_zoom(ds1_idx, glb_config.center_zoom);
                    }
                    glb_ds1edit.win_preview.x0   = glb_ds1[ds1_idx].own_wpreview.x0;
                    glb_ds1edit.win_preview.y0   = glb_ds1[ds1_idx].own_wpreview.y0;
                    position_mouse(glb_ds1edit.win_preview.w / 2, glb_ds1edit.win_preview.h / 2);
                }
            } else {
                if ( ! key[KEY_LCONTROL] && ! key[KEY_RCONTROL]) {
                    // Center to mouse in OBJECT / PATH mode
                    while (key[KEY_C]) {
                        // wait until the 'C' key is released
                    }
                    cx /= 5;
                    cy /= 5;
                    cx++;
                    dx = (cy * -glb_ds1[ds1_idx].tile_w / 2) + (cx * glb_ds1[ds1_idx].tile_w / 2);
                    dy = (cy *  glb_ds1[ds1_idx].tile_h / 2) + (cx * glb_ds1[ds1_idx].tile_h / 2);
                    cx--;
                    cx *= 5;
                    cy *= 5;
                    glb_ds1[ds1_idx].own_wpreview.x0 = glb_ds1edit.win_preview.x0 = dx - glb_ds1edit.win_preview.w / 2;
                    glb_ds1[ds1_idx].own_wpreview.y0 = glb_ds1edit.win_preview.y0 = dy - glb_ds1edit.win_preview.h / 2;
                    glb_ds1[ds1_idx].own_wpreview.w  = glb_ds1edit.win_preview.w;
                    glb_ds1[ds1_idx].own_wpreview.h  = glb_ds1edit.win_preview.h;
                    if (glb_config.center_zoom != -1) {
                        change_zoom(ds1_idx, glb_config.center_zoom);
                    }
                    glb_ds1edit.win_preview.x0   = glb_ds1[ds1_idx].own_wpreview.x0;
                    glb_ds1edit.win_preview.y0   = glb_ds1[ds1_idx].own_wpreview.y0;
                    position_mouse(glb_ds1edit.win_preview.w / 2, glb_ds1edit.win_preview.h / 2);
                }
            }
        }

        // CTRL + X : Copy selected tiles, WITH CUT (crop / paste)
        if (key[KEY_X] && (key[KEY_LCONTROL] || key[KEY_RCONTROL])) {
            if (glb_ds1edit.mode == MOD_T) {
                // TILE mode
                if (paste_pos.start == FALSE) {
                    for (i=0; i<DS1_MAX; i++) {
                        if (strlen(glb_ds1[i].name)) {
                            edittile_paste_prepare(i);
                        }
                    }
                    paste_pos.src_ds1_idx = ds1_idx;
                    paste_pos.old_ds1_idx = ds1_idx;
                    paste_pos.start       = TRUE;
                    paste_pos.is_cut      = TRUE; // copy with 'CUT'
                    paste_pos.cut_saved   = FALSE;
                    paste_pos.old_x       = cx;
                    paste_pos.old_y       = cy;
                    edittile_middle_select( ds1_idx, & paste_pos.start_x, & paste_pos.start_y);
                    edittile_paste_preview(ds1_idx, cx - paste_pos.start_x, cy - paste_pos.start_y, & paste_pos);
                    while (key[KEY_X]) {
                        // wait until the X key is released
                    }
                }
            }
        }

        // DEL key (regular or keypad) : delete all selected layers of all tiles
        if (key[KEY_DEL] || key[KEY_DEL_PAD]) {
            if (glb_ds1edit.mode == MOD_T) {
                if (paste_pos.start == FALSE) {
                    edittile_delete_selected_tiles(ds1_idx);
                    while (key[KEY_DEL] || key[KEY_DEL_PAD]) {
                        // wait until both DEL keys are released
                    }
                }
            }
        }

        // CTRL + U : undo tiles modification
        if (key[KEY_U] && (key[KEY_LCONTROL] || key[KEY_RCONTROL])) {
            if (glb_ds1edit.mode == MOD_T) {
                if (paste_pos.start == FALSE) {
                    undo_apply_tile_buffer(ds1_idx);
                    while (key[KEY_U]) {
                        // wait until the 'U' key is released
                    }
                }
            }
        }

        // G : toggle tile grid
        if (key[KEY_G]) {

            if (key[KEY_LSHIFT] || key[KEY_RSHIFT]) {
                glb_ds1edit.display_tile_grid --;
            } else {
                glb_ds1edit.display_tile_grid ++;
            }

            if (glb_ds1edit.display_tile_grid < TG_OFF) {
                glb_ds1edit.display_tile_grid = TG_MAX - 1;
            }
            if (glb_ds1edit.display_tile_grid >= TG_MAX) {
                glb_ds1edit.display_tile_grid = TG_OFF;
            }
            while(key[KEY_G]) {
                // wait
            }
        }

        // changing current ds1
        group_changed = FALSE;
        old_group     = glb_ds1edit.ds1_group_idx;
        if (can_swich_mode)
        {
            if (key[KEY_LCONTROL] || key[KEY_RCONTROL])
            {
                if (key[KEY_1])
                {
                    while (key[KEY_1] || key[KEY_LCONTROL] || key[KEY_RCONTROL])
                    {
                        // wait
                    }
                    glb_ds1edit.ds1_group_idx = 0;
                    group_changed = TRUE;
                } else if (key[KEY_2]) {
                    while (key[KEY_2] || key[KEY_LCONTROL] || key[KEY_RCONTROL]) {
                        // wait
                    }
                    glb_ds1edit.ds1_group_idx = 1;
                    group_changed = TRUE;
                } else if (key[KEY_3]) {
                    while (key[KEY_3] || key[KEY_LCONTROL] || key[KEY_RCONTROL]) {
                        // wait
                    }
                    glb_ds1edit.ds1_group_idx = 2;
                    group_changed = TRUE;
                } else if (key[KEY_4]) {
                    while (key[KEY_4] || key[KEY_LCONTROL] || key[KEY_RCONTROL]) {
                        // wait
                    }
                    glb_ds1edit.ds1_group_idx = 3;
                    group_changed = TRUE;
                } else if (key[KEY_5]) {
                    while (key[KEY_5] || key[KEY_LCONTROL] || key[KEY_RCONTROL])
                    {
                        // wait
                    }
                    glb_ds1edit.ds1_group_idx = 4;
                    group_changed = TRUE;
                } else if (key[KEY_6]) {
                    while (key[KEY_6] || key[KEY_LCONTROL] || key[KEY_RCONTROL]) {
                        // wait
                    }
                    glb_ds1edit.ds1_group_idx = 5;
                    group_changed = TRUE;
                } else if (key[KEY_7]) {
                    while (key[KEY_7] || key[KEY_LCONTROL] || key[KEY_RCONTROL]) {
                        // wait
                    }
                    glb_ds1edit.ds1_group_idx = 6;
                    group_changed = TRUE;
                } else if (key[KEY_8]) {
                    while (key[KEY_8] || key[KEY_LCONTROL] || key[KEY_RCONTROL]) {
                        // wait
                    }
                    glb_ds1edit.ds1_group_idx = 7;
                    group_changed = TRUE;
                } else if (key[KEY_9]) {
                    while (key[KEY_9] || key[KEY_LCONTROL] || key[KEY_RCONTROL]) {
                        // wait
                    }
                    glb_ds1edit.ds1_group_idx = 8;
                    group_changed = TRUE;
                } else if (key[KEY_0]) {
                    while (key[KEY_0] || key[KEY_LCONTROL] || key[KEY_RCONTROL]) {
                        // wait
                    }
                    glb_ds1edit.ds1_group_idx = 9;
                    group_changed = TRUE;
                }
            }

            if (group_changed == TRUE) {
                // try to swap to 1st ds1 of this group set
                found = FALSE;
                for (i=0; i < 10; i++) {
                    if (strlen(glb_ds1[glb_ds1edit.ds1_group_idx * 10 + i].name)) {
                        // there's a ds1 open here
                        old_ds1_idx = ds1_idx;
                        ds1_idx     = glb_ds1edit.ds1_group_idx * 10 + i;
                        found       = TRUE;
                        break;
                    }
                }
                if (found == FALSE) {
                    // don't change to this group
                    glb_ds1edit.ds1_group_idx = old_group;
                    group_changed = FALSE;
                }
            }

            // swap to a different ds1 ?
            if (key[KEY_1] && strlen(glb_ds1[glb_ds1edit.ds1_group_idx * 10].name)) {
                old_ds1_idx = ds1_idx;
                ds1_idx     = glb_ds1edit.ds1_group_idx * 10;
                while (key[KEY_1]) {
                    // wait
                }
            }
            if (key[KEY_2] && strlen(glb_ds1[glb_ds1edit.ds1_group_idx * 10 + 1].name)) {
                old_ds1_idx = ds1_idx;
                ds1_idx     = glb_ds1edit.ds1_group_idx * 10 + 1;
                while (key[KEY_2]) {
                    // wait
                }
            }
            if (key[KEY_3] && strlen(glb_ds1[glb_ds1edit.ds1_group_idx * 10 + 2].name)) {
                old_ds1_idx = ds1_idx;
                ds1_idx     = glb_ds1edit.ds1_group_idx * 10 + 2;
                while (key[KEY_3]) {
                    // wait
                }
            }
            if (key[KEY_4] && strlen(glb_ds1[glb_ds1edit.ds1_group_idx * 10 + 3].name)) {
                old_ds1_idx = ds1_idx;
                ds1_idx     = glb_ds1edit.ds1_group_idx * 10 + 3;
                while (key[KEY_4]) {
                    // wait
                }
            }
            if (key[KEY_5] && strlen(glb_ds1[glb_ds1edit.ds1_group_idx * 10 + 4].name)) {
                old_ds1_idx = ds1_idx;
                ds1_idx     = glb_ds1edit.ds1_group_idx * 10 + 4;
                while (key[KEY_5]) {
                    // wait
                }
            }
            if (key[KEY_6] && strlen(glb_ds1[glb_ds1edit.ds1_group_idx * 10 + 5].name)) {
                old_ds1_idx = ds1_idx;
                ds1_idx     = glb_ds1edit.ds1_group_idx * 10 + 5;
                while (key[KEY_6]) {
                    // wait
                }
            }
            if (key[KEY_7] && strlen(glb_ds1[glb_ds1edit.ds1_group_idx * 10 + 6].name)) {
                old_ds1_idx = ds1_idx;
                ds1_idx     = glb_ds1edit.ds1_group_idx * 10 + 6;
                while (key[KEY_7]) {
                    // wait
                }
            }
            if (key[KEY_8] && strlen(glb_ds1[glb_ds1edit.ds1_group_idx * 10 + 7].name)) {
                old_ds1_idx = ds1_idx;
                ds1_idx     = glb_ds1edit.ds1_group_idx * 10 + 7;
                while (key[KEY_8]) {
                    // wait
                }
            }
            if (key[KEY_9] && strlen(glb_ds1[glb_ds1edit.ds1_group_idx * 10 + 8].name)) {
                old_ds1_idx = ds1_idx;
                ds1_idx     = glb_ds1edit.ds1_group_idx * 10 + 8;
                while (key[KEY_9]) {
                    // wait
                }
            }
            if (key[KEY_0] && strlen(glb_ds1[glb_ds1edit.ds1_group_idx * 10 + 9].name)) {
                old_ds1_idx = ds1_idx;
                ds1_idx     = glb_ds1edit.ds1_group_idx * 10 + 9;
                while (key[KEY_0]) {
                    // wait
                }
            }
        }

        if (old_ds1_idx != ds1_idx) {
            // save current win preview state for the old ds1
            glb_ds1[old_ds1_idx].own_wpreview.x0 = glb_ds1edit.win_preview.x0;
            glb_ds1[old_ds1_idx].own_wpreview.y0 = glb_ds1edit.win_preview.y0;
            glb_ds1[old_ds1_idx].own_wpreview.w  = glb_ds1edit.win_preview.w;
            glb_ds1[old_ds1_idx].own_wpreview.h  = glb_ds1edit.win_preview.h;

            // put back old win preview state for the new ds1
            glb_ds1edit.win_preview.x0 = glb_ds1[ds1_idx].own_wpreview.x0;
            glb_ds1edit.win_preview.y0 = glb_ds1[ds1_idx].own_wpreview.y0;
            glb_ds1edit.win_preview.w  = glb_ds1[ds1_idx].own_wpreview.w;
            glb_ds1edit.win_preview.h  = glb_ds1[ds1_idx].own_wpreview.h;

            // ending swap
            old_ds1_idx = ds1_idx;
        }

        // toggle 2nd row
        if (key[KEY_TILDE]) {
            while (key[KEY_TILDE]) {
                // wait until TILDE is not pressed
            }
            if (glb_ds1edit.show_2nd_row == FALSE) {
                glb_ds1edit.show_2nd_row = TRUE;
            } else {
                glb_ds1edit.show_2nd_row = FALSE;
            }
        }

        // TAB : change edit mode
        if (key[KEY_TAB]) {
            while (key[KEY_TAB]) {
                // wait until TAB is not pressed
            }
            if (glb_ds1edit.mode == MOD_L) {
                glb_ds1edit.mode = old_mode;
            } else {
                if (can_swich_mode) {
                    if ((key[KEY_LSHIFT]) || (key[KEY_RSHIFT])) {
                        glb_ds1edit.mode--;
                    } else {
                        glb_ds1edit.mode++;
                    }
                }
            }
            if (glb_ds1edit.mode < MOD_T) {
                glb_ds1edit.mode = MOD_P;
            }
            if ((glb_ds1edit.mode >= MOD_MAX) || (glb_ds1edit.mode == MOD_L)) {
                glb_ds1edit.mode = MOD_T;
            }
            // show_mouse(NULL);
            //         misc_set_mouse_cursor(glb_ds1edit.mouse_cursor[glb_ds1edit.mode]);
            // show_mouse(screen);
            old_cell_x = -1;
            old_cell_y = -1;
        }

        // N : Toggle Night mode
        if (key[KEY_N]) {
            while (key[KEY_N]) {
                // wait until the 'N' key is released
            }
            if (glb_ds1edit.mode == MOD_L) {
                glb_ds1edit.night_mode++;
                if (glb_ds1edit.night_mode >= 2) {
                    glb_ds1edit.night_mode = 0;
                    glb_ds1edit.mode = old_mode;
                }
            } else {
                old_mode = glb_ds1edit.mode;
                glb_ds1edit.mode = MOD_L;
            }

            old_cell_x = -1;
            old_cell_y = -1;
        }

        // R : Refresh obj.txt
        if (key[KEY_R]) {
            while (key[KEY_R]) {
                // wait until the 'R' key is released
            }

            // refresh animdata.d2
            animdata_load();

            // destroy all animations
            anim_exit();

            // destroy memory obj.txt and objects.txt
            glb_ds1edit.obj_buff     = txt_destroy(glb_ds1edit.obj_buff);
            glb_ds1edit.objects_buff = txt_destroy(glb_ds1edit.obj_buff);

            // read the current obj.txt and objects.txt
            read_objects_txt(); // objects.txt first !
            read_obj_txt();

            // load new animations
            anim_update_gfx(FALSE);

            // reset the ticks counter
            glb_ds1edit.ticks_elapsed = 0;
        }

        // left mouse button
        if (old_mouse_b & 1) {
            // mouse button 1 is pressed
            if (glb_ds1edit.mode == MOD_T) {
                if (paste_pos.start == TRUE) {
                    // end a paste
                    edittile_paste_final(ds1_idx);
                    paste_pos.start = FALSE;
                    while (mouse_b & 1) {
                        // NOT old_mouse_b else infinite loop
                        // wait until the left mouse button is released
                    }
                } else if (tmp_sel.start == FALSE) {
                    if ( (key[KEY_I]) && (cx != old_identical_x) && (cy != old_identical_y)) {
                        // for all the tiles Identical to the visible ones

                        if (key[KEY_LSHIFT] || key[KEY_RSHIFT]) {
                            // add to selection
                            itype = IT_ADD;
                        } else if (key[KEY_LCONTROL] || key[KEY_RCONTROL]) {
                            // delete from previous selection
                            itype = IT_DEL;
                        } else {
                            // new selection (delete previous one)
                            itype = IT_NEW;
                        }
                        edittile_identical(ds1_idx, itype, cx, cy);
                        old_identical_x = cx;
                        old_identical_y = cy;
                    } else if ( ! key[KEY_I]) {
                        // starting a temp selection
                        old_identical_x = -1;
                        old_identical_y = -1;

                        tmp_sel.start = TRUE;
                        tmp_sel.x1 = tmp_sel.x2 = tmp_sel.old_x2 = cx;
                        tmp_sel.y1 = tmp_sel.y2 = tmp_sel.old_y2 = cy;
                        edittile_delete_all_tmpsel(ds1_idx);
                        edittile_set_tmpsel(ds1_idx, & tmp_sel);
                    }
                } else {
                    if ((tmp_sel.old_x2 != cx) || (tmp_sel.old_y2 != cy)) {
                        // update the temp selection
                        tmp_sel.x2 = tmp_sel.old_x2 = cx;
                        tmp_sel.y2 = tmp_sel.old_y2 = cy;
                        edittile_delete_all_tmpsel(ds1_idx);
                        edittile_set_tmpsel(ds1_idx, & tmp_sel);
                    }
                }
            }
        } else {
            // mouse button 1 is not pressed
            if (glb_ds1edit.mode == MOD_T) {
                if (tmp_sel.start == TRUE) {
                    // end of tmp sel, process it
                    if (key[KEY_H]) {
                        tmp_sel.type = TMP_HIDE;
                    } else if (key[KEY_LSHIFT] || key[KEY_RSHIFT]) {
                        tmp_sel.type = TMP_ADD;
                    } else if (key[KEY_LCONTROL] || key[KEY_RCONTROL]) {
                        tmp_sel.type = TMP_DEL;
                    } else {
                        tmp_sel.type = TMP_NEW;
                    }
                    switch (tmp_sel.type) {
                        case TMP_NEW :
                            edittile_delete_all_tmpsel(ds1_idx);
                            edittile_change_to_new_permanent_sel(ds1_idx, & tmp_sel);
                            tmp_sel.start = FALSE;
                            tmp_sel.type = TMP_NULL;
                            tmp_sel.x1 = tmp_sel.x2 = tmp_sel.y1 = tmp_sel.y2 = 0;
                            tmp_sel.old_x2 = tmp_sel.old_y2 = 0;
                            break;

                        case TMP_ADD :
                            edittile_delete_all_tmpsel(ds1_idx);
                            edittile_change_to_add_permanent_sel(ds1_idx, & tmp_sel);
                            tmp_sel.start = FALSE;
                            tmp_sel.type = TMP_NULL;
                            tmp_sel.x1 = tmp_sel.x2 = tmp_sel.y1 = tmp_sel.y2 = 0;
                            tmp_sel.old_x2 = tmp_sel.old_y2 = 0;
                            break;

                        case TMP_HIDE :
                            edittile_delete_all_tmpsel(ds1_idx);
                            edittile_change_to_hide_sel(ds1_idx, & tmp_sel);
                            tmp_sel.start = FALSE;
                            tmp_sel.type = TMP_NULL;
                            tmp_sel.x1 = tmp_sel.x2 = tmp_sel.y1 = tmp_sel.y2 = 0;
                            tmp_sel.old_x2 = tmp_sel.old_y2 = 0;
                            break;

                        case TMP_DEL :
                            edittile_delete_all_tmpsel(ds1_idx);
                            edittile_change_to_del_sel(ds1_idx, & tmp_sel);
                            tmp_sel.start = FALSE;
                            tmp_sel.type = TMP_NULL;
                            tmp_sel.x1 = tmp_sel.x2 = tmp_sel.y1 = tmp_sel.y2 = 0;
                            tmp_sel.old_x2 = tmp_sel.old_y2 = 0;
                            break;
                    }
                } else if (paste_pos.start == TRUE) {
                    if ((paste_pos.old_x != cx) || (paste_pos.old_y != cy) || (paste_pos.old_ds1_idx != ds1_idx)) {
                        edittile_paste_undo(paste_pos.old_ds1_idx);
                        edittile_paste_preview(ds1_idx, cx - paste_pos.start_x, cy - paste_pos.start_y, & paste_pos);
                        paste_pos.old_x = cx;
                        paste_pos.old_y = cy;
                        paste_pos.old_ds1_idx = ds1_idx;
                    }
                }
            }
        }

        // right mouse button
        // ÈáçÁÇπÊù•‰∫ÜÂì¶
        // Ëøô‰∏™ÊòØÈÇ£‰∏™Â∞èÊñπÂùó, ÊèèËø∞ÈáåÈù¢ÁöÑ01Â∫èÂàóÁöÑ
        // ÈùûÂ∏∏nice


        //goto  _WEDIT_TEST;
        if (old_mouse_b & 2) {
            if (glb_ds1edit.mode == MOD_T) {
                while (mouse_b & 2) {
                    // NOT old_mouse_b else infinite loop
                    // wait until the right mouse button is released
                }
                if ( (key[KEY_LCONTROL] || key[KEY_RCONTROL]) && (key[KEY_LSHIFT]   || key[KEY_RSHIFT]) ) {
                    // advanced tile editing window (bits)
                    wbits_main(ds1_idx, cx, cy);
                    position_mouse(old_mouse_x, old_mouse_y);
                } else {
_WEDIT_TEST:
                    wedit_test(ds1_idx, cx, cy);
                    set_color_depth(8); // back to a 8bpp color depth for duture BITMAP creation
                    position_mouse(old_mouse_x, old_mouse_y);
                }
            }
        }

        // quit
        if (key[KEY_ESC] && (glb_ds1[ds1_idx].draw_edit_obj == FALSE)) {
            while (key[KEY_ESC]) {
                // wait until ESC is not pressed anymore
            }
            ret = msg_quit_main();
            switch (ret) {
                case -1 :
                    // error
                    ds1_save(ds1_idx, TRUE); // save a .TMP map
                    done = TRUE;
                    break;

                case 0 :
                    // save ALL & quit
                    for (i=0; i < DS1_MAX; i++) {
                        if (strlen(glb_ds1[ds1_idx].name)) {
                            ds1_save(i, FALSE);
                        }
                    }
                    done = TRUE;
                    break;

                case 1 :
                    // quit
                    ds1_save(ds1_idx, TRUE); // save a .TMP map
                    done = TRUE;
                    break;

                case 2  :
                default :
                    // cancel
                    break;
            }
        }
    }
}
#include "structs.h"
#include "error.h"
#include "mpqview.h"
#include "dt1misc.h"
#include "ds1misc.h"
#include "anim.h"
#include "wedit.h"
#include "undo.h"
#include "txtread.h"
#include "misc.h"
#include "inicreat.h"
#include "iniread.h"
#include "animdata.h"
#include "interfac.h"


// typedef struct WRKSPC_DATAS_S{
//    char * id;
// } WRKSPC_DATAS_S;

// workspace datas saved in .ds1
WRKSPC_DATAS_S glb_wrkspc_datas[WRKSPC_MAX] = {
    {("DS1EDIT_WRKSPC_TILE_X")},
    {("DS1EDIT_WRKSPC_TILE_Y")},
    {("DS1EDIT_WRKSPC_ZOOM")},
    {("DS1EDIT_VERSION")},
    {("DS1EDIT_SAVE_COUNT")}
};

// gamma correction string table
GAMMA_S glb_gamma_str[GC_MAX] = {
    {"0.60", GC_060}, {"0.62", GC_062}, {"0.64", GC_064},
    {"0.66", GC_066}, {"0.68", GC_068}, {"0.70", GC_070},
    {"0.72", GC_072}, {"0.74", GC_074}, {"0.76", GC_076},
    {"0.78", GC_078}, {"0.80", GC_080}, {"0.82", GC_082},
    {"0.84", GC_084}, {"0.86", GC_086}, {"0.88", GC_088},
    {"0.90", GC_090}, {"0.92", GC_092}, {"0.94", GC_094},
    {"0.96", GC_096}, {"0.98", GC_098}, {"1.00", GC_100},
    {"1.10", GC_110}, {"1.20", GC_120}, {"1.30", GC_130},
    {"1.40", GC_140}, {"1.50", GC_150}, {"1.60", GC_160},
    {"1.70", GC_170}, {"1.80", GC_180}, {"1.90", GC_190},
    {"2.00", GC_200}, {"2.10", GC_210}, {"2.20", GC_220},
    {"2.30", GC_230}, {"2.40", GC_240}, {"2.50", GC_250},
    {"2.60", GC_260}, {"2.70", GC_270}, {"2.80", GC_280},
    {"2.90", GC_290}, {"3.00", GC_300}
};

char * txt_def_lvltype_req[] = {
    ("Id"),      ("Act"),
    ("File 1"),  ("File 2"),  ("File 3"),  ("File 4"),  ("File 5"),
    ("File 6"),  ("File 7"),  ("File 8"),  ("File 9"),  ("File 10"),
    ("File 11"), ("File 12"), ("File 13"), ("File 14"), ("File 15"),
    ("File 16"), ("File 17"), ("File 18"), ("File 19"), ("File 20"),
    ("File 21"), ("File 22"), ("File 23"), ("File 24"), ("File 25"),
    ("File 26"), ("File 27"), ("File 28"), ("File 29"), ("File 30"),
    ("File 31"), ("File 32"),
    NULL // DO NOT REMOVE !
};

char * txt_def_lvlprest_req[] = {
    ("Def"),   ("Dt1Mask"),
    ("File1"), ("File2"), ("File3"), ("File4"), ("File5"), ("File6"),
    NULL // DO NOT REMOVE !
};

char * txt_def_obj_req[] = {
    // number
    ("Act"),
    ("Type"),
    ("Id"),
    ("Direction"),
    ("Index"),
    ("Objects.txt_ID"),
    ("Monstats.txt_ID"),

    // text
    ("Base"),
    ("Token"),
    ("Mode"),
    ("Class"),
    ("HD"), ("TR"), ("LG"), ("RA"), ("LA"), ("RH"), ("LH"), ("SH"),
    ("S1"), ("S2"), ("S3"), ("S4"), ("S5"), ("S6"), ("S7"), ("S8"),
    ("Colormap"),
    ("Description"),

    NULL // DO NOT REMOVE !
};

char * txt_def_objects_req[] = {
    // number
    ("Id"),
    ("SizeX"),
    ("SizeY"),
    ("FrameCnt0"),
    ("FrameCnt1"),
    ("FrameCnt2"),
    ("FrameCnt3"),
    ("FrameCnt4"),
    ("FrameCnt5"),
    ("FrameCnt6"),
    ("FrameCnt7"),
    ("FrameDelta0"),
    ("FrameDelta1"),
    ("FrameDelta2"),
    ("FrameDelta3"),
    ("FrameDelta4"),
    ("FrameDelta5"),
    ("FrameDelta6"),
    ("FrameDelta7"),
    ("CycleAnim0"),
    ("CycleAnim1"),
    ("CycleAnim2"),
    ("CycleAnim3"),
    ("CycleAnim4"),
    ("CycleAnim5"),
    ("CycleAnim6"),
    ("CycleAnim7"),
    ("Lit0"),
    ("Lit1"),
    ("Lit2"),
    ("Lit3"),
    ("Lit4"),
    ("Lit5"),
    ("Lit6"),
    ("Lit7"),
    ("BlocksLight0"),
    ("BlocksLight1"),
    ("BlocksLight2"),
    ("BlocksLight3"),
    ("BlocksLight4"),
    ("BlocksLight5"),
    ("BlocksLight6"),
    ("BlocksLight7"),
    ("Start0"),
    ("Start1"),
    ("Start2"),
    ("Start3"),
    ("Start4"),
    ("Start5"),
    ("Start6"),
    ("Start7"),
    ("BlocksVis"),
    ("Trans"),
    ("OrderFlag0"),
    ("OrderFlag1"),
    ("OrderFlag2"),
    ("OrderFlag3"),
    ("OrderFlag4"),
    ("OrderFlag5"),
    ("OrderFlag6"),
    ("OrderFlag7"),
    ("Mode0"),
    ("Mode1"),
    ("Mode2"),
    ("Mode3"),
    ("Mode4"),
    ("Mode5"),
    ("Mode6"),
    ("Mode7"),
    ("Yoffset"),
    ("Xoffset"),
    ("Draw"),
    ("Red"),
    ("Green"),
    ("Blue"),
    ("TotalPieces"),
    ("SubClass"),
    ("Xspace"),
    ("YSpace"),
    ("OperateRange"),
    ("Act"),
    ("Sync"),
    ("Flicker"),
    ("Overlay"),
    ("CollisionSubst"),
    ("Left"),
    ("Top"),
    ("Width"),
    ("Height"),
    ("BlockMissile"),
    ("DrawUnder"),
    ("HD"), ("TR"), ("LG"), ("RA"), ("LA"), ("RH"), ("LH"), ("SH"),
    ("S1"), ("S2"), ("S3"), ("S4"), ("S5"), ("S6"), ("S7"), ("S8"),

    // text
    ("Token"),

    NULL // DO NOT REMOVE !
};

char ** glb_txt_req_ptr[RQ_MAX] = {NULL, NULL, NULL, NULL};

CONFIG_S      glb_config;                     // global configuration datas
GLB_DS1EDIT_S glb_ds1edit;                    // global datas of the editor
GLB_MPQ_S     glb_mpq_struct [MAX_MPQ_FILE];  // global data of 1 mpq
DS1_S         * glb_ds1                = NULL; // ds1 datas
DT1_S         * glb_dt1                = NULL; // dt1 datas
char          glb_tiles_path        [] = "data/global/tiles/";
char          glb_ds1edit_data_dir  [] = "./res/data";
char          glb_ds1edit_tmp_dir   [] = "tmp"; // «∞∫Ûπ‚¡Ô¡Ô‘≠‘Ú

// debug files
char          * glb_path_lvltypes_mem = "debug/editor.lvltypes.memory.bin";
char          * glb_path_lvltypes_def = "debug/d2.lvltypes.headers.txt";
char          * glb_path_lvlprest_mem = "debug/editor.lvlprest.memory.bin";
char          * glb_path_lvlprest_def = "debug/d2.lvlprest.headers.txt";
char          * glb_path_obj_mem      = "debug/editor.obj.memory.bin";
char          * glb_path_obj_def      = "debug/editor.obj.headers.txt";
char          * glb_path_objects_mem  = "debug/editor.objects.memory.bin";
char          * glb_path_objects_def  = "debug/d2.objects.headers.txt";


// ==========================================================================
// near the start of the prog
void ds1edit_init(void)
{
    FILE        *out;
    int          i;
    int          o;
    char         tmp[80];

    static struct{
        char      name[40];
        MODE_E    idx;
    }cursor[MOD_MAX] = {
        {"res/pcx/cursor_t.pcx", MOD_T},       // tiles
        {"res/pcx/cursor_o.pcx", MOD_O},       // objects
        {"res/pcx/cursor_p.pcx", MOD_P},       // paths
        {"res/pcx/cursor_l.pcx", MOD_L}        // lights
    };

    static int   dir4[4]   = { 0,  1,  2,  3};
    static int   dir8[8]   = { 4,  0,  5,  1,  6,  2,  7,  3 };
    static int   dir16[16] = { 4,  8,  0,  9,  5, 10,  1, 11,
        6, 12,  2, 13,  7, 14,  3, 15 };
    static int   dir32[32] = { 4, 16,  8, 17,  0, 18,  9, 19,
        5, 20, 10, 21,  1, 22, 11, 23,
        6, 24, 12, 25,  2, 26, 13, 27,
        7, 28, 14, 29,  3, 30, 15, 31 };
    static int   obj_sub_tile[5][5] = {
        { 0,  2,  5,  9, 14},
        { 1,  4,  8, 13, 18},
        { 3,  7, 12, 17, 21},
        { 6, 11, 16, 20, 23},
        {10, 15, 19, 22, 24} };

    DEBUG_MESSAGE("ds1edit_init()\n");

    memset( & glb_config,  0, sizeof(glb_config) );
    memset( & glb_ds1edit, 0, sizeof(glb_ds1edit) );

    // allocate mem for DT1 & DS1
    i = sizeof(DS1_S) * DS1_MAX;
    DEBUG_MESSAGE("allocate %i bytes for glb_ds1[%i]\n", i, DS1_MAX);
    glb_ds1 = (DS1_S *) malloc(i);
    if(!glb_ds1){
        FATAL_EXIT("could not allocate %i bytes for the glb_ds1[%i] table.\n", i, DS1_MAX );
    }
    memset(glb_ds1, 0, i);

    i = sizeof(DT1_S) * DT1_MAX;
    DEBUG_MESSAGE("allocate %i bytes for glb_dt1[%i]\n", i, DT1_MAX);
    glb_dt1 = (DT1_S *) malloc(i);
    if(!glb_dt1){
        FATAL_EXIT("could not allocate %i bytes for the glb_dt1[%i] table.\n", i, DT1_MAX );
    }
    memset(glb_dt1, 0, i);

    for (i=0; i<MAX_MPQ_FILE; i++) {
        memset( & glb_mpq_struct[i], 0, sizeof(GLB_MPQ_S));
        glb_mpq_struct[i].is_open = FALSE;
    }

    // mouse cursors
    for (i=0; i<MOD_MAX; i++) {
        glb_ds1edit.mouse_cursor[i] = load_pcx(cursor[i].name, glb_ds1edit.dummy_pal);
        if(glb_ds1edit.mouse_cursor[i] == NULL){
            FATAL_EXIT("could not open the file \"%s\".\n", cursor[i].name);
        }
    }

    //char * txt_def_lvltype_req[] =
    //{
    //   ("Id"),      ("Act"),
    //   ("File 1"),  ("File 2"),  ("File 3"),  ("File 4"),  ("File 5"),
    //   ("File 6"),  ("File 7"),  ("File 8"),  ("File 9"),  ("File 10"),
    //   ("File 11"), ("File 12"), ("File 13"), ("File 14"), ("File 15"),
    //   ("File 16"), ("File 17"), ("File 18"), ("File 19"), ("File 20"),
    //   ("File 21"), ("File 22"), ("File 23"), ("File 24"), ("File 25"),
    //   ("File 26"), ("File 27"), ("File 28"), ("File 29"), ("File 30"),
    //   ("File 31"), ("File 32"),
    //   NULL // DO NOT REMOVE !
    //};
    // Œ™"±ÿ–Î"µƒ¡–
    // ªπ”–“ª–©¡–Œ™∑«±ÿ–Îµƒ..÷ª «Œ™¡À‘ˆº”ø…∂¡–‘µƒ
    // txt
    glb_txt_req_ptr[RQ_LVLTYPE]  = txt_def_lvltype_req;
    glb_txt_req_ptr[RQ_LVLPREST] = txt_def_lvlprest_req;
    glb_txt_req_ptr[RQ_OBJ]      = txt_def_obj_req;
    glb_txt_req_ptr[RQ_OBJECTS]  = txt_def_objects_req;

    // debug files
    remove(glb_path_lvltypes_mem);
    remove(glb_path_lvltypes_def);
    remove(glb_path_lvlprest_mem);
    remove(glb_path_lvlprest_def);
    remove(glb_path_obj_mem);
    remove(glb_path_obj_def);
    remove(glb_path_objects_mem);
    remove(glb_path_objects_def);

    // tables
    glb_ds1edit.new_dir1[0] = 0;
    for (i=0; i < 4; i++){
        glb_ds1edit.new_dir4[i] = dir4[i];
    }
    for (i=0; i < 8; i++){
        glb_ds1edit.new_dir8[i] = dir8[i];
    }
    for (i=0; i < 16; i++){
        glb_ds1edit.new_dir16[i] = dir16[i];
    }
    for (i=0; i < 32; i++){
        glb_ds1edit.new_dir32[i] = dir32[i];
    }


    //   for re-ordering sub-tile objects, from back to front
    //   static int   obj_sub_tile[5][5] = {
    //                            { 0,  2,  5,  9, 14},
    //                            { 1,  4,  8, 13, 18},
    //                            { 3,  7, 12, 17, 21},
    //                            { 6, 11, 16, 20, 23},
    //                            {10, 15, 19, 22, 24} };
    //   ’‚ø…ƒ‹ «“ª∏ˆ∫‹÷ÿ“™µƒ∂´Œ˜
    //   ∂¯«“ƒ«∏ˆdt1Œƒº˛µƒflagŒ“π¿º∆¿ÌΩ‚¥Ì¡À
    //
    //
    //   int           glb_ds1edit.obj_sub_tile_order[5][5];
    //   ∆Ê¡Àπ÷¡À..Œ™ ≤√¥≤ª÷±Ω”ÃÓ–¥, ∑«“™–¥’‚√¥∏ˆ∂´Œ˜
    for (i=0; i < 5; i++){
        for (o=0; o < 5; o++){
            glb_ds1edit.obj_sub_tile_order[i][o] = obj_sub_tile[i][o];
        }
    }

    // init the default values of the command line
    glb_ds1edit.cmd_line.ds1_filename  = NULL;
    glb_ds1edit.cmd_line.ini_filename  = NULL;
    glb_ds1edit.cmd_line.lvltype_id    = -1;
    glb_ds1edit.cmd_line.lvlprest_def  = -1;
    glb_ds1edit.cmd_line.resize_width  = -1;
    glb_ds1edit.cmd_line.resize_height = -1;
    glb_ds1edit.cmd_line.force_pal_num = -1;
    glb_ds1edit.cmd_line.no_check_act  = FALSE;
    glb_ds1edit.cmd_line.dt1_list_num  = -1;
    for (i=0; i < DT1_IN_DS1_MAX; i++){
        glb_ds1edit.cmd_line.dt1_list_filename[i] = NULL;
    }

    // 2nd row of infos
    glb_ds1edit.show_2nd_row = FALSE;

    // video pages
    glb_ds1edit.video_page_num = 0;

    DEBUG_MESSAGE("ds1edit_init():out\n");
}


// ==========================================================================
UDWORD ds1edit_get_bitmap_size(BITMAP * bmp)
{
    UDWORD size = 0;

    if (bmp == NULL)
        return 0;

    size += sizeof(BITMAP);
    size += (sizeof(UBYTE *) * bmp->h);

    switch (bitmap_color_depth(bmp))
    {
        case  8 : size += bmp->w * bmp->h; break;
        case 15 :
        case 16 : size += 2 * (bmp->w * bmp->h); break;
        case 24 : size += 3 * (bmp->w * bmp->h); break;
        case 32 : size += 4 * (bmp->w * bmp->h); break;
        default :
                  break;
    }

    return size;
}



// ==========================================================================
UDWORD ds1edit_get_RLE_bitmap_size(RLE_SPRITE * rle)
{
    UDWORD size = 0;

    if (rle == NULL)
        return 0;

    size += sizeof(RLE_SPRITE);
    size += rle->size;

    return size;
}


// ==========================================================================
// automatically called at the end, with the help of atexit()
void ds1edit_exit(void)
{
    int i, z, b;


    printf("\nds1edit_exit()\n");

    // close all mpq
    for (i=0; i<MAX_MPQ_FILE; i++)
    {
        if (glb_mpq_struct[i].is_open != FALSE)
        {
            fprintf(stderr, "closing %s\n", glb_mpq_struct[i].file_name);
            fflush(stderr);

            glb_mpq = & glb_mpq_struct[i];
            mpq_batch_close();

            memset( & glb_mpq_struct[i], 0, sizeof(GLB_MPQ_S));
            glb_mpq_struct[i].is_open = FALSE;
        }
    }

    // free all mem
    fprintf(stderr, "exit, memory free :\n");
    fflush(stderr);

    // mouse cursor
    fprintf(stderr, "   * mouse cursor...\n");
    fflush(stderr);
    show_mouse(NULL);
    for (i=0; i<MOD_MAX; i++)
    {
        if (glb_ds1edit.mouse_cursor[i] != NULL)
        {
            destroy_bitmap(glb_ds1edit.mouse_cursor[i]);
            glb_ds1edit.mouse_cursor[i] = NULL;
        }
    }

    // screen buffer
    fprintf(stderr, "   * screen buffer...\n");
    fflush(stderr);
    if (glb_ds1edit.screen_buff != NULL)
    {
        destroy_bitmap(glb_ds1edit.screen_buff);
        glb_ds1edit.screen_buff = NULL;
    }

    if (glb_ds1edit.big_screen_buff != NULL)
    {
        destroy_bitmap(glb_ds1edit.big_screen_buff);
        glb_ds1edit.big_screen_buff = NULL;
    }

    // config, mpq name
    fprintf(stderr, "   * config, mpq names...\n");
    fflush(stderr);
    for (i=0; i<MAX_MPQ_FILE; i++)
    {
        if(glb_config.mpq_file[i] != NULL)
            free(glb_config.mpq_file[i]);
    }

    // config, mod directory
    fprintf(stderr, "   * config, mod directory name...\n");
    fflush(stderr);
    for (i=0; i<MAX_MOD_DIR; i++)
    {
        if(glb_config.mod_dir[i] != NULL)
            free(glb_config.mod_dir[i]);
    }

    // palettes
    fprintf(stderr, "   * palettes...\n");
    fflush(stderr);
    for (i=0; i<ACT_MAX; i++)
    {
        if(glb_ds1edit.d2_pal[i] != NULL)
        {
            free(glb_ds1edit.d2_pal[i]);
            glb_ds1edit.d2_pal[i] = NULL;
            glb_ds1edit.pal_size[i] = 0;
        }
    }

    // dt1
    fprintf(stderr, "   * DT1 files...\n");
    fflush(stderr);
    if (glb_dt1 != NULL)
    {
        for (i=0; i<DT1_MAX; i++)
            dt1_free(i);
    }

    // ds1
    fprintf(stderr, "   * DS1 files...\n");
    fflush(stderr);
    if (glb_ds1 != NULL)
    {
        for (i=0; i<DS1_MAX; i++)
            ds1_free(i);
    }

    // objects descriptions
    fprintf(stderr, "   * objects descriptions...\n");
    fflush(stderr);
    if (glb_ds1edit.obj_desc != NULL)
    {
        anim_exit();
        free(glb_ds1edit.obj_desc);
        glb_ds1edit.obj_desc = NULL;
        glb_ds1edit.obj_desc_num = 0;
    }

    // buttons & tab
    fprintf(stderr, "   * buttons & tab...\n");
    fflush(stderr);
    wedit_free();

    // undo buffers
    fprintf(stderr, "   * undo buffers...\n");
    fflush(stderr);
    if (glb_ds1 != NULL)
        undo_exit();

    // walkable infos tiles
    fprintf(stderr, "   * walkable info tiles...\n");
    fflush(stderr);
    for (z=0; z<ZM_MAX; z++)
    {
        for (i=0; i<25; i++)
        {
            if (glb_ds1edit.subtile_nowalk[z][i] != NULL)
            {
                destroy_rle_sprite(glb_ds1edit.subtile_nowalk[z][i]);
                glb_ds1edit.subtile_nowalk[z][i] = NULL;
            }

            if (glb_ds1edit.subtile_nojump[z][i] != NULL)
            {
                destroy_rle_sprite(glb_ds1edit.subtile_nojump[z][i]);
                glb_ds1edit.subtile_nojump[z][i] = NULL;
            }
        }
    }

    if (glb_ds1edit.subtile_help != NULL)
    {
        destroy_bitmap(glb_ds1edit.subtile_help);
        glb_ds1edit.subtile_help = NULL;
    }


    // walkable infos tiles, combinations
    fprintf(stderr, "   * walkable info tiles combinations...\n");
    fflush(stderr);
    for (b=0; b<256; b++)
    {
        for (z=0; z<ZM_MAX; z++)
        {
            for (i=0; i<25; i++)
            {
                if (glb_ds1edit.subtile_flag[b][z][i] != NULL)
                {
                    destroy_rle_sprite(glb_ds1edit.subtile_flag[b][z][i]);
                    glb_ds1edit.subtile_flag[b][z][i] = NULL;
                }
            }
        }
    }

    // .txt buffers
    fprintf(stderr, "   * .txt buffers ...\n");
    fflush(stderr);
    if (glb_ds1edit.lvltypes_buff != NULL)
        glb_ds1edit.lvltypes_buff = txt_destroy(glb_ds1edit.lvltypes_buff);
    if (glb_ds1edit.lvlprest_buff != NULL)
        glb_ds1edit.lvlprest_buff = txt_destroy(glb_ds1edit.lvlprest_buff);
    if (glb_ds1edit.obj_buff != NULL)
        glb_ds1edit.obj_buff = txt_destroy(glb_ds1edit.obj_buff);

    // animdata.d2
    fprintf(stderr, "   * animdata.d2 buffer ...\n");
    fflush(stderr);
    if (glb_ds1edit.anim_data.buffer)
        free(glb_ds1edit.anim_data.buffer);

    // obj in ds1
    fprintf(stderr, "   * glb_ds1[] & glb_dt1[] & glb_ds1[].obj & glb_ds1[].obj_undo ...\n");
    fflush(stderr);

    // ds1 & dt1
    if (glb_ds1 != NULL)
    {
        for (i=0; i < DS1_MAX; i++)
        {
            if (glb_ds1[i].obj != NULL)
                free(glb_ds1[i].obj);
            if (glb_ds1[i].obj_undo != NULL)
                free(glb_ds1[i].obj_undo);
        }
        free(glb_ds1);
    }
    if (glb_dt1 != NULL)
        free(glb_dt1);

    fflush(stderr);
}




// ==========================================================================
// 1 tick each 1/25 of a second
void ds1edit_counter_tick(void)
{
    glb_ds1edit.ticks_elapsed++;
}
//END_OF_FUNCTION(ds1edit_counter_tick);


// ==========================================================================
// 1 tick each second
void ds1edit_counter_fps(void)
{
    glb_ds1edit.old_fps = glb_ds1edit.fps;
    glb_ds1edit.fps = 0;
}
//END_OF_FUNCTION(ds1edit_counter_fps);


// ==========================================================================
// open all mpq
void ds1edit_open_all_mpq(void)
{
    int  i;

    DEBUG_MESSAGE("ds1edit_open_all_mpq():in\n");
    for(i=0; i<MAX_MPQ_FILE; i++){
        if(glb_config.mpq_file[i] != NULL){
            DEBUG_MESSAGE("opening mpq %i : %s\n", i, glb_config.mpq_file[i]);
            glb_mpq = & glb_mpq_struct[i];
            mpq_batch_open(glb_config.mpq_file[i]);
        }
    }
    DEBUG_MESSAGE("ds1edit_open_all_mpq():out\n");
}


// ==========================================================================
// load palettes of the 5 acts from disk, else from mpq
void ds1edit_load_palettes(void)
{
    int  i, entry;
    char palname[80], tmp[150];

    DEBUG_MESSAGE("ds1edit_load_palettes():in\n");

    //#define ACT_MAX                5
    // act «πÿµƒ“‚Àº, “ª∏ˆπÿ¿Ô√Ê”–»Ù∏…»ŒŒÒ
    // Œ“‘⁄œÎ «≤ª «√ø“ªπÿ÷–µƒ‘™Àÿ±»ΩœΩ¸À∆~ 
    // ±»»Áµ⁄“ªπÿæÕ»´ «≤›µÿ  ˜ƒæ÷Æ¿‡µƒ∂´Œ˜
    // µ⁄∂˛πÿæÕ «…≥ƒÆ ø› ˜ ≤√¥µƒ
    for(i=0; i<ACT_MAX; i++){
        glb_ds1edit.pal_loaded[i] = TRUE;
        // first checking on disk
        // ’‚∏ˆæÕ «±£¥ÊµΩ¥≈≈ÃµƒtmpŒƒº˛∞…
        // Œ“µ˜ ‘ ±∫Ú∑µªÿtrue, ÷±Ω”Ã¯π˝ª®¿®∫≈¿Ô√Êµƒ¡À

        if(misc_load_pal_from_disk(i) == FALSE) {
            // not already on disk
            glb_ds1edit.pal_loaded[i] = FALSE;
            // make full path
            sprintf(palname, "data/global/palette/act%i/pal.pl2", i+1);
            // load the palette
            DEBUG_MESSAGE("want to read a palette from mpq : %s\n", palname);
            entry = misc_load_mpq_file( palname, (char **) & glb_ds1edit.d2_pal[i], & glb_ds1edit.pal_size[i], TRUE );
            if(entry == -1){
                DEBUG_MESSAGE("file \"%s\" not found.", palname );
                if (i < 4){
                    fprintf(stderr, tmp);
                }else{
                    printf("warning :\n%s\n", tmp);
                }
            }
            // save it for the next time
            misc_save_pal_on_disk(i, glb_ds1edit.d2_pal[i]);
        }

        // palette loaded, either from disk of from mpq, reorder it
        misc_pl2_correct(i);
        misc_pal_d2_2_vga(i);
    }
    DEBUG_MESSAGE("ds1edit_load_palettes():out\n");
}


// ==========================================================================
// as expected, the start of the prog
int main(int argc, char * argv[])
{
    int          i;
    int          mpq_num = 0;
    int          mod_num = 0;
    int          ds1_idx = 0;
    int          res_w;
    int          res_h;

    static char  tmp [512];
    static char  tmp2[512];

    char        *ininame = "./ds1edit.ini";
    // init

    DEBUG_MESSAGE("main():in\n");

    srand(time(NULL));
    allegro_init();
    set_gfx_mode(GFX_TEXT, 80, 25, 0, 0);

    if(install_keyboard() != 0){
        FATAL_EXIT("main(), error.\ncould not install the Keyboard Handler.");
    }
    if(install_timer() != 0){
        FATAL_EXIT("main(), error.\ncould not install the Timer Handler.");
    }

    set_color_depth(8);

    // ∞≤◊∞handler
    if(atexit(ds1edit_exit) != 0){
        FATAL_EXIT("main(), error.\ncould not install the 'atexit' Handler.");
    }

    ds1edit_init();

    get_desktop_resolution( & res_w, & res_h);
    DEBUG_MESSAGE("desktop_resolution  = %i * %i\n", res_w, res_h);

    set_window_title("D2IM-MAPEDITOR");

    // check data\tmp directory
    // ???
    sprintf(tmp, "%s/%s/.", glb_ds1edit_data_dir, glb_ds1edit_tmp_dir);
    if (file_exists(tmp, -1, NULL) == 0){
        // create tmp directory
        sprintf(tmp, "%s%s", glb_ds1edit_data_dir, glb_ds1edit_tmp_dir);
        if(strlen(tmp)){
            tmp[strlen(tmp) - 1] = 0;
        }
        if(mkdir(tmp) != 0){
            // re-use the tmp var for a different string
            FATAL_EXIT("could not create directory \"%s%s\".", glb_ds1edit_data_dir, glb_ds1edit_tmp_dir );
        }
    }

    // check if ds1edit.ini exists
    sprintf(tmp, "./ds1edit.ini");
    if(file_exists(tmp, -1, NULL) == 0){
        ini_create(tmp);
        FATAL_EXIT("no 'ds1edit.ini' file, create and reconfigure it.\n");
    }

    // init (config)
    ini_read(ininame);

    DEBUG_MESSAGE("==================================================================\n");
    DEBUG_MESSAGE("d2char                  = %s\n", glb_config.mpq_file[3]);
    DEBUG_MESSAGE("d2data                  = %s\n", glb_config.mpq_file[2]);
    DEBUG_MESSAGE("d2exp                   = %s\n", glb_config.mpq_file[1]);
    DEBUG_MESSAGE("patch_d2                = %s\n", glb_config.mpq_file[0]);
    DEBUG_MESSAGE("mod_dir                 = %s\n", glb_config.mod_dir[0]);
    DEBUG_MESSAGE("fullscreen              = %s\n", glb_config.fullscreen ? "YES" : "NO");
    DEBUG_MESSAGE("screen_width            = %i\n", glb_config.screen.width);
    DEBUG_MESSAGE("screen_height           = %i\n", glb_config.screen.height);
    DEBUG_MESSAGE("screen_depth            = %i\n", glb_config.screen.depth);
    DEBUG_MESSAGE("refresh_rate            = %i\n", glb_config.screen.refresh);
    DEBUG_MESSAGE("keyb_scroll_x           = %i\n", glb_config.scroll.keyb.x);
    DEBUG_MESSAGE("keyb_scroll_y           = %i\n", glb_config.scroll.keyb.y);
    DEBUG_MESSAGE("mouse_scroll_x          = %i\n", glb_config.scroll.mouse.x);
    DEBUG_MESSAGE("mouse_scroll_y          = %i\n", glb_config.scroll.mouse.y);
    DEBUG_MESSAGE("edit_scroll_x           = %i\n", glb_config.scroll.edit.x);
    DEBUG_MESSAGE("edit_scroll_y           = %i\n", glb_config.scroll.edit.y);   
    DEBUG_MESSAGE("obj_edit_scroll         = %i\n", glb_config.scroll.obj_edit);
    DEBUG_MESSAGE("mouse_speed_x           = %i\n", glb_config.mouse_speed.x);
    DEBUG_MESSAGE("mouse_speed_y           = %i\n", glb_config.mouse_speed.y);
    DEBUG_MESSAGE("gamma_correction        = %s\n", glb_gamma_str[glb_config.gamma].str);
    DEBUG_MESSAGE("only_normal_type2       = %s\n", glb_config.normal_type2        ? "YES" : "NO");
    DEBUG_MESSAGE("always_max_layers       = %s\n", glb_config.always_max_layers   ? "YES" : "NO");
    DEBUG_MESSAGE("stretch_sprites         = %s\n", glb_config.stretch_sprites     ? "YES" : "NO");
    DEBUG_MESSAGE("winobj_can_scroll_keyb  = %s\n", glb_config.winobj_scroll_keyb  ? "YES" : "NO");
    DEBUG_MESSAGE("winobj_can_scroll_mouse = %s\n", glb_config.winobj_scroll_mouse ? "YES" : "NO");

    switch(glb_config.center_zoom)
    {
        case -1     : DEBUG_MESSAGE("center_zoom             = ERROR\n");  break;
        case ZM_11  : DEBUG_MESSAGE("center_zoom             = 1:1\n"  );  break;
        case ZM_12  : DEBUG_MESSAGE("center_zoom             = 1:2\n"  );  break;
        case ZM_14  : DEBUG_MESSAGE("center_zoom             = 1:4\n"  );  break;
        case ZM_18  : DEBUG_MESSAGE("center_zoom             = 1:8\n"  );  break;
        case ZM_116 : DEBUG_MESSAGE("center_zoom             = 1:16\n" );  break;
        default     : DEBUG_MESSAGE("center_zoom             = ?\n"    );  break;
    }

    DEBUG_MESSAGE("nb_type1_per_act        = %i\n", glb_config.nb_type1_per_act);
    DEBUG_MESSAGE("nb_type2_per_act        = %i\n", glb_config.nb_type2_per_act);
    DEBUG_MESSAGE("ds1_saved_minimize      = %s\n", glb_config.minimize_ds1         ? "YES" : "NO");
    DEBUG_MESSAGE("lower_speed_zoom_out    = %s\n", glb_config.lower_speed_zoom_out ? "YES" : "NO");
    DEBUG_MESSAGE("workspace_enable        = %s\n", glb_config.workspace_enable     ? "YES" : "NO");
    DEBUG_MESSAGE("==================================================================\n");


    // check mod directory
    mod_num = 0;
    if(glb_config.mod_dir[0] != NULL){
        sprintf(tmp, "%s/.", glb_config.mod_dir[0]);
        if (file_exists(tmp, -1, NULL) == 0){
            WARNING_MESSAGE("could not find the mod directory defined in 'ds1edit.ini' :\n" "%s", tmp );
        }else{
            mod_num = 1;
        }
    }

    for(i=0; i<MAX_MPQ_FILE; i++){
        if (glb_config.mpq_file[i] != NULL){
            if(file_exists(glb_config.mpq_file[i], -1, NULL) == 0){
                WARNING_MESSAGE("could not find this mpq defined in 'ds1edit.ini' :%s\n", glb_config.mpq_file[i] );
            }else{
                mpq_num++;
            }
        }
    }
    if ((mod_num == 0) && (mpq_num == 0)){
        FATAL_EXIT("no mod directory and no mpq files available : it can't work.\n" );
    }else if (mpq_num < 4){
        WARNING_MESSAGE("not all the 4 mpq have been found\n");
    }

    // gamma correction
    glb_ds1edit.cur_gamma = glb_config.gamma;
    misc_read_gamma();

    // preview window update
    glb_ds1edit.win_preview.x0 = 0;
    glb_ds1edit.win_preview.y0 = 0;
    glb_ds1edit.win_preview.w  = glb_config.screen.width;
    glb_ds1edit.win_preview.h  = glb_config.screen.height;

    // edit window
    // Œ“≤ªÃ´πÿ–ƒ’‚∏ˆ..À˘“‘√ªø¥
    // µ´ «Ã·π©¡À“ª∏ˆGUIµƒ¥¶¿Ì∑Ω Ω
    // »Áπ˚œÎ“™◊ˆGUIµƒ ±∫Ú, ø…“‘≤Œøº“ªœ¬
    wedit_read_pcx();
    wedit_make_2nd_buttons();
    misc_walkable_tile_info_pcx();

    // screen buffer (we're still in 8bpp color depth !)

    // we're making a big buffer, with 300 pixels on each 4 borders, and then we'll make the true screen buffer be a sub-bitmap of this buffer
    // this is to avoid potential problems with clipings, especially when using the functions from gfx_custom.c
    // yes, I'm hidding the problem under the carpet

    glb_config.screen.width  += 600;
    glb_config.screen.height += 600;
    glb_ds1edit.big_screen_buff = create_bitmap( glb_config.screen.width, glb_config.screen.height );
    if (glb_ds1edit.big_screen_buff == NULL){
        FATAL_EXIT("could not create big_screen_buff (%i*%i pixels).", glb_config.screen.width, glb_config.screen.height );
    }
    glb_config.screen.width  -= 600;
    glb_config.screen.height -= 600;

    glb_ds1edit.screen_buff = create_sub_bitmap( glb_ds1edit.big_screen_buff, 300, 300, glb_config.screen.width, glb_config.screen.height );
    if (glb_ds1edit.screen_buff == NULL){
        FATAL_EXIT("could not create sub-bitmap screen_buff (%i*%i pixels).", glb_config.screen.width, glb_config.screen.height );
    }

    // open all mpq
    ds1edit_open_all_mpq();

    // load palettes from disk, else from mpq
    ds1edit_load_palettes();

    // parse the command line
    // ◊ÚÕÌµ˜ ‘µΩ’‚¿Ô
    if (misc_cmd_line_parse (argc, argv)){
        // ≤ªÃ´πÿ–ƒ’‚“ªøÈ
        // À˘“‘Ã¯π˝¡À
        FATAL_EXIT("problem in the command line.");
    }

    // create debug directory if necessary
    if (glb_ds1edit.cmd_line.debug_mode == TRUE){
        mkdir("debug");
    }

    // objects.txt
    read_objects_txt();

    // obj.txt
    read_obj_txt();

    if(glb_ds1edit.cmd_line.ds1_filename != NULL){
        //µ˜ ‘ ±∫Ú”√µƒ «.ini À˘“‘√ª”–‘⁄’‚¿Ô
        // .ds1
        // read the ds1
        if(glb_ds1edit.cmd_line.dt1_list_num != -1){
            // force dt1
            misc_open_1_ds1_force_dt1(ds1_idx);
        }else{
            // find dt1 list from .txt
            misc_open_1_ds1(
                    ds1_idx,
                    glb_ds1edit.cmd_line.ds1_filename,
                    glb_ds1edit.cmd_line.lvltype_id,
                    glb_ds1edit.cmd_line.lvlprest_def,
                    glb_ds1edit.cmd_line.resize_width,
                    glb_ds1edit.cmd_line.resize_height
                    );
        }
    }else if(glb_ds1edit.cmd_line.ini_filename != NULL){
        // .ini
        //Œ“”√µƒ¿˝◊” «.ini À˘“‘‘⁄’‚¿Ô~
        // 2nd row of infos
        glb_ds1edit.show_2nd_row = TRUE;
        // list of ds1 to open
        misc_open_several_ds1(argv[1]);
    }else{
        // bug
        fprintf(stderr, "main(), error.\nBug : neither .DS1 nor a .INI in the command line.");
    }

    // syntaxe of the command line
    printf("============================================================\n");
    if (argc >= 4){
        // at least 3 arguments (ds1 name + ID + DEF + options)
    } else if (argc == 2) {
        // 1 argument (assume it's a .ini file)
    } else {
        // syntax error
        printf("syntaxe 1 : ds1edit <file.ds1> <lvlTypes.txt Id> <lvlPrest.txt Def> [options]\n");
        printf("syntaxe 2 : ds1edit <file.ini>\n"
                "\n"
                "   file.ini in syntaxe 2 is a text file, each line for 1 ds1 to load,\n"
                "   3 elements : <lvlTypes.txt Id> <lvlPrest.txt Def> <file.ds1>\n");
        exit(DS1ERR_CMDLINE);
    }
    printf("============================================================\n");

    // animdata.d2
    printf("\nanimdata_load()\n");
    fflush(stdout);
    fflush(stderr);
    //√ªø¥∂Æ’‚∏ˆ∫Ø ˝
    animdata_load();

    // load necessary objects animation
    printf("loading ds1 objects animations :\n");
    fprintf(stderr, "loading ds1 objects animations : ");
    fflush(stdout);
    fflush(stderr);

    anim_update_gfx(TRUE); // TRUE is for "show dot progression"

    printf("\n");
    fprintf(stderr, "\n");
    fflush(stdout);
    fflush(stderr);

    // colormaps
    printf("\ncolor maps...");
    fprintf(stderr, "color maps");
    misc_make_cmaps();
    printf("done\n");
    fprintf(stderr, "done\n");

    // start
    fflush(stdout);
    fflush(stderr);
    if ( (glb_config.screen.depth !=  8) && (glb_config.screen.depth != 15) && (glb_config.screen.depth != 16) && (glb_config.screen.depth != 24) && (glb_config.screen.depth != 32)) {
        sprintf( tmp, "main(), error.\nInvalid color depth (%i).\nValid values are : 8, 15, 16, 24 and 32.\nCheck the 'Ds1edit.ini' file, at the 'screen_depth' line", glb_config.screen.depth);
        fprintf(stderr, tmp);
    }

    // set color depth for the screen
    set_color_depth(glb_config.screen.depth);

    request_refresh_rate(glb_config.screen.refresh);
    if (glb_config.fullscreen == TRUE) {
        if (set_gfx_mode(GFX_AUTODETECT_FULLSCREEN, glb_config.screen.width, glb_config.screen.height, 0, 0) != 0) {
            sprintf( tmp, "main(), error.\ncould not initialize this graphical mode : " "%i*%i %ibpp %iHz %s.\nAllegro_error = \"%s\".", glb_config.screen.width, glb_config.screen.height, glb_config.screen.depth, glb_config.screen.refresh, "Fullscreen", allegro_error);
            fprintf(stderr, tmp);
        }
    } else {
        if (set_gfx_mode(GFX_AUTODETECT_WINDOWED, glb_config.screen.width, glb_config.screen.height, 0, 0) != 0) {
            sprintf( tmp, "main(), error.\ncould not initialize this graphical mode : " "%i*%i %ibpp %iHz %s.\nAllegro_error = \"%s\".", glb_config.screen.width, glb_config.screen.height, glb_config.screen.depth, glb_config.screen.refresh, "Windowed", allegro_error);
            fprintf(stderr, tmp);
        }
    }
    glb_ds1edit.current_refresh_rate = get_refresh_rate();

    // video pages
    glb_ds1edit.video_page[0] = create_video_bitmap( glb_config.screen.width, glb_config.screen.height);
    if (glb_ds1edit.video_page[0] == NULL) {
        sprintf(tmp, "main(), error.\ncould not create video page 1.", glb_config.screen.width, glb_config.screen.height);
        fprintf(stderr, tmp);
    }

    glb_ds1edit.video_page[1] = create_video_bitmap( glb_config.screen.width, glb_config.screen.height);
    if (glb_ds1edit.video_page[1] == NULL) {
        sprintf(tmp, "main(), error.\ncould not create video page 2.", glb_config.screen.width, glb_config.screen.height);
        fprintf(stderr, tmp);
    }

    // when the editor is minimized, stop it until the user returns
    set_display_switch_mode(SWITCH_PAUSE);

    // get back to a 8bpp color depth, for all the next BITMAP creation
    set_color_depth(8);

    text_mode(-1); // draw text as sprite, no background color

    //LOCK_VARIABLE(glb_ds1edit.old_fps);
    //LOCK_VARIABLE(glb_ds1edit.fps);
    //LOCK_VARIABLE(glb_ds1edit.ticks_elapsed);
    //LOCK_FUNCTION(ds1edit_counter_tick);
    //LOCK_FUNCTION(ds1edit_counter_fps);

    /*
    if (install_int(ds1edit_counter_tick, 1000 / 25) != 0) {
        FATAL_EXIT("could not install the 'counter_tick' timer handler at 25Hz.\n");
    }
    if (install_int(ds1edit_counter_fps, 1000) != 0) {
        FATAL_EXIT("could not install the 'counter_fps' timer handler at 1Hz.\n");
    }
    */

    if (install_mouse() == -1) {
        FATAL_EXIT("could not install the Mouse handler.\n");
    }
    set_mouse_speed(glb_config.mouse_speed.x, glb_config.mouse_speed.y);

    // show_mouse(screen);

    glb_ds1edit.win_preview.x0 = glb_ds1[ds1_idx].own_wpreview.x0;
    glb_ds1edit.win_preview.y0 = glb_ds1[ds1_idx].own_wpreview.y0;
    glb_ds1edit.win_preview.w  = glb_ds1[ds1_idx].own_wpreview.w ;
    glb_ds1edit.win_preview.h  = glb_ds1[ds1_idx].own_wpreview.h ;


    // main loop
    freopen("stderr.txt", "wt", stderr);
    interfac_user_handler(ds1_idx);

    if (glb_ds1edit.video_page[0] != NULL)
        destroy_bitmap(glb_ds1edit.video_page[0]);

    if (glb_ds1edit.video_page[1] != NULL)
        destroy_bitmap(glb_ds1edit.video_page[1]);

    // end
    set_gfx_mode(GFX_TEXT, 80, 25, 0, 0);
    // fclose(stdout);
    fflush(stdout);
    fflush(stderr);
    return DS1ERR_OK;
}
END_OF_MAIN();
//ª„◊‹
//ø¥¿¥Œ““™¡–∏ˆ±Ì–¥“ªœ¬orientation∫Õ ˝æ›¿‡–Õµƒπÿœµ÷Æ¿‡µƒ
//Œ“∂º±ª’‚∏ˆ∏„∑≥¡À..’˚∏ˆ≥Ã–ÚµΩ¥¶∂º «’‚∏ˆ~
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////
//            // type
//            if (bt_ptr->orientation == 0)
//            {
//               // floor
//               bt_ptr->zero_line = 0;
//
//               if (b_ptr->animated == 0x01){
//                  bt_ptr->type = BT_ANIMATED;
//               } else {
//                  bt_ptr->type = BT_STATIC;
//               }
//            }
//            else if (bt_ptr->orientation == 13)
//            {
//               // shadow
//               bt_ptr->type      = BT_SHADOW;
//               bt_ptr->zero_line = - b_ptr->size_y;
//            }
//            else
//            {
//               // walls
//               if ((bt_ptr->orientation == 10) || (bt_ptr->orientation == 11))
//               {
//                  // special
//                  bt_ptr->type      = BT_SPECIAL;
//                  bt_ptr->zero_line = - b_ptr->size_y;
//               }
//               else if (bt_ptr->orientation == 15)
//               {
//                  // roof
//                  bt_ptr->type      = BT_ROOF;
//                  bt_ptr->roof_y    = b_ptr->roof_y;
//                  bt_ptr->zero_line = 0;
//               }
//               else if (bt_ptr->orientation < 15)
//               {
//                  // wall up
//                  bt_ptr->type      = BT_WALL_UP;
//                  bt_ptr->zero_line = - b_ptr->size_y;
//               }
//               else if (bt_ptr->orientation > 15)
//               {
//                  // wall down
//                  bt_ptr->type      = BT_WALL_DOWN;
//                  bt_ptr->zero_line = 96;
//               }
//            }
///////////////////////////////////////////////////////////////////////////////////////////////
//      ’‚“ª∂Œ¿¥◊‘misc.c
//      “‚ÀºæÕ «:
//      orientation == 0    :   floor
//      orientation == 13   :   shadow
//      ∆‰À˚∂º «wall,’‚∆‰÷–:
//          orientation == 10 || 11 :   special
//          orientation == 15       :   roof
//              ≤ª Ù”⁄“‘…œ∏˜¿‡, µ´ «:
//                  orientation < 15    :   wall up
//                  orientation > 15    :   wall down
//                      ’‚¿Ôµƒorientation≤ªÕ¨ª·÷∏ æ≤ªÕ¨µƒ«ΩÃÂ∂‘∆Î∑Ω Ω√¥(“≤æÕ ««ΩÃÂ≥ØœÚ)? ‘› ±≤ª«Â≥˛
//                      ”√dt1tool≤È¡À“ªœ¬, √≤À∆orientation:
//                           ˜∂º «14
//                          «ΩÃÂµƒ∂‘∆ÎŒ“ªπ√ª∏„√˜∞◊,√≤À∆µƒ»∑ «∏ˆ≥ØœÚŒ Ã‚
//
//
//
//      ΩÒÃÏÕª»ª∑¢œ÷, πÿ”⁄’‚–©∂´Œ˜, “≤–ÌŒ“∏√»•ø¥ø¥tile_editer( æÕ « Û±Í”“º¸∫ÛµƒΩÁ√Ê )
//      ƒ«±ﬂ√≤À∆ƒ‹πªÃ·π©≤ª…Ÿ∂´Œ˜
//
//‘⁄ª≠Õºµƒ ±∫Ú,”–’‚√¥“ªæ‰:
//
//      if (w_ptr[n].orientation == 10)
//         order_data[n].height = 255;


//        “‘œ¬¿¥◊‘dt1 tools:
//        // ploty adjustment
//        if (block_ptr->orientation & 0xF0){
//            //Ωÿ»°∏ﬂ4Œª,¥”16ø™ º œ‡µ±”⁄ orientation>15
//            ploty = 125; // walls bellow floor,“≤æÕ «walls down
//        }
//        else if ((block_ptr->direction == 3) && (block_ptr->orientation == 0))
//            ploty = (screen_y / 2); // only floor
//        else if ((block_ptr->direction == 5) && (block_ptr->orientation == 15))
//            ploty = screen_y - 15 - 80; // only roof
//        else
//            ploty = screen_y - 15; // walls to the up



#include <string.h>
#include "structs.h"
#include "error.h"
#include "ds1misc.h"
#include "txtread.h"
#include "dt1misc.h"
#include "mpq/mpqview.h"
#include "misc.h"


// ==========================================================================
// make a palette from the original one, with the current gamma correction
void misc_pal_d2_2_vga(int pal_idx)
{
    UBYTE r, g, b;
    int   i, ridx;

    if(glb_ds1edit.d2_pal[pal_idx] == NULL){
        for (i=0; i<256; i++){
            glb_ds1edit.vga_pal[pal_idx][i].r = i >> 2;
            glb_ds1edit.vga_pal[pal_idx][i].g = i >> 2;
            glb_ds1edit.vga_pal[pal_idx][i].b = i >> 2;
        }
        return;
    }

    for (i=0; i<256; i++){
        //‘À––µƒ’‚¿Ô
        // ridx = i << 2;
        ridx = 4 * i;
        r = glb_ds1edit.d2_pal[pal_idx][ridx];
        g = glb_ds1edit.d2_pal[pal_idx][ridx + 1];
        b = glb_ds1edit.d2_pal[pal_idx][ridx + 2];
        r = glb_ds1edit.gamma_table[glb_ds1edit.cur_gamma][r];
        g = glb_ds1edit.gamma_table[glb_ds1edit.cur_gamma][g];
        b = glb_ds1edit.gamma_table[glb_ds1edit.cur_gamma][b];

        //’‚¥Û∏≈ «"µ±«∞”√”⁄‰÷»æµƒpal"µƒ“‚Àº
        glb_ds1edit.vga_pal[pal_idx][i].r = r >> 2;
        glb_ds1edit.vga_pal[pal_idx][i].g = g >> 2;
        glb_ds1edit.vga_pal[pal_idx][i].b = b >> 2;
    }   
}


// ==========================================================================
// helper of the qsort function, same order as in the game
int misc_qsort_helper_block_table_1(const void * e1, const void * e2)
{
    BLOCK_TABLE_S * bt1, * bt2;
    long          n1=0, n2=0;

    bt1 = (BLOCK_TABLE_S *) e1;
    bt2 = (BLOCK_TABLE_S *) e2;
    //ø…“‘¥”’‚¿Ôø¥≥ˆ”≈œ»–‘:
    // orientation > main_index > sub_index > dt1_idx > rarity > block_idx
    if (bt1->orientation != bt2->orientation)
    {
        n1 = bt1->orientation;
        n2 = bt2->orientation;
    }
    else if (bt1->main_index != bt2->main_index)
    {
        n1 = bt1->main_index;
        n2 = bt2->main_index;
    }
    else if (bt1->sub_index != bt2->sub_index)
    {
        n1 = bt1->sub_index;
        n2 = bt2->sub_index;
    }
    else if (bt1->dt1_idx != bt2->dt1_idx)
    {
        n1 = bt1->dt1_idx_for_ds1;
        n2 = bt2->dt1_idx_for_ds1;

        if (n1 == 0) n1 = DT1_MAX;
        if (n2 == 0) n2 = DT1_MAX;
    }
    else if (bt1->rarity != bt2->rarity)
    {
        n1 = bt1->rarity;
        n2 = bt2->rarity;
    }
    else if (bt1->block_idx != bt2->block_idx)
    {
        n1 = bt1->block_idx;
        n2 = bt2->block_idx;
    }
    return n1 - n2;
}


// ==========================================================================
// helper of the qsort function, order for the end-user
// ∏„≤ª«Â≥˛‘⁄∏……∂
int misc_qsort_helper_block_table_2(const void * e1, const void * e2)
{
    BLOCK_TABLE_S * bt1, * bt2;
    long          n1=0, n2=0;

    bt1 = (BLOCK_TABLE_S *) e1;
    bt2 = (BLOCK_TABLE_S *) e2;

    /*
       if (bt1->dt1_idx != bt2->dt1_idx)
       {
       n1 = bt1->dt1_idx;
       n2 = bt2->dt1_idx;
       }
       else
     */
    if (bt1->main_index != bt2->main_index)
    {
        n1 = bt1->main_index;
        n2 = bt2->main_index;
    }
    else if (bt1->orientation != bt2->orientation)
    {
        n1 = bt1->orientation;
        n2 = bt2->orientation;
    }
    else if (bt1->sub_index != bt2->sub_index)
    {
        n1 = bt1->sub_index;
        n2 = bt2->sub_index;
    }

    // ----------------
    else if (bt1->dt1_idx != bt2->dt1_idx)
    {
        n1 = bt1->dt1_idx;
        n2 = bt2->dt1_idx;
    }
    // ----------------

    else if (bt1->rarity != bt2->rarity)
    {
        n1 = bt1->rarity;
        n2 = bt2->rarity;
    }
    else if (bt1->block_idx != bt2->block_idx)
    {
        n1 = bt1->block_idx;
        n2 = bt2->block_idx;
    }
    return n1 - n2;
}


// ==========================================================================
// after the 1st qsort, find the tiles the game will use
// it handles conflicts, and rarity of the tiles


void misc_check_tiles_conflicts(int ds1_idx)
{
    BLOCK_TABLE_S * bt = glb_ds1[ds1_idx].block_table;
    long          old_o, old_m, old_s, o, m, s;
    int           old_d, d, done = FALSE, done2, start_i = 0, i, end_i, r;
    int           last_block, first_block;
    int           bt_max = glb_ds1[ds1_idx].bt_num, b;
    long          sum_rarity, max_rarity;


    while ( ! done)
    {
        old_o = bt[start_i].orientation;
        old_m = bt[start_i].main_index;
        old_s = bt[start_i].sub_index;
        old_d = bt[start_i].dt1_idx;

        bt[start_i].used_by_game = bt[start_i].used_by_editor = FALSE;

        // how many tiles have the same Orientation / Main index / Sub index ?
        done2       = FALSE;
        sum_rarity  = bt[start_i].rarity;
        last_block  = start_i;
        i           = start_i + 1;
        max_rarity  = -1;
        if (bt[start_i].rarity)
            first_block = start_i;
        else
            first_block = -1;
        while ( ! done2)
        {
            o = bt[i].orientation;
            m = bt[i].main_index;
            s = bt[i].sub_index;
            d = bt[i].dt1_idx;
            r = bt[i].rarity;

            //BLOCK_S.rarity(dt1tool‘¥¥˙¬Î÷–µƒ)¥Û∏≈∫ÕBLOCK_S.frame≤Ó≤ª∂‡

            if ((old_o != o) || (old_m != m) || (old_s != s) || (i >= bt_max))
                done2 = TRUE;
            else
            {
                bt[i].used_by_game = bt[i].used_by_editor = FALSE;
                if (d == old_d)
                    last_block = i; // last block of the first dt1
                if (r)
                {
                    if (first_block == -1)
                        first_block = i; // first block having a rarity
                    //    (whichever the dt1 is is)
                    if (r > max_rarity)
                    {
                        first_block = i;
                        max_rarity = r;
                    }
                }
                sum_rarity += r;
                i++;
            }
        }
        end_i = i - 1;

        // which one of these tiles will use the game & the editor ?
        if (sum_rarity == 0)
        {
            // only last block of the first dt1
            bt[last_block].used_by_game = bt[last_block].used_by_editor = TRUE;
        }
        else
        {
            // editor : only first block having the highest rarity
            bt[first_block].used_by_editor = TRUE;

            // game   : same, but also others which have a non-zero rarity
            for (b = start_i; b <= end_i; b++)
            {
                if (bt[b].rarity)
                    bt[b].used_by_game = TRUE;
            }
        }

        // next
        if (i >= bt_max)
            done = TRUE;
        else
            start_i = i;
    }
}


// ==========================================================================
// make the block table of 1 ds1
void misc_make_block_table(int ds1_idx)
{
    //typedef struct BLOCK_TABLE_S
    //{
    //   // key
    //   int       dt1_idx_for_ds1;
    //   long      main_index;
    //   long      orientation;
    //   long      sub_index;
    //
    //   // datas
    //   int       dt1_idx;
    //   long      rarity;
    //   int       block_idx;
    //   BLK_TYP_E type;
    //   int       zero_line;
    //   int       roof_y;
    //
    //   // conflicts managment
    //   char      conflict;
    //   char      used_by_game;   // True / False
    //   char      used_by_editor; // True / False
    //
    //   // animated tile
    //   long      curr_frame;
    //   int       updated;
    //} BLOCK_TABLE_S;




    //typedef struct BLOCK_S
    //{
    //   long       direction;
    //   WORD       roof_y;
    //   UBYTE      sound;
    //   UBYTE      animated;
    //   long       size_y;
    //   long       size_x;
    //   // long       zeros1;
    //   long       orientation;
    //   long       main_index;
    //   long       sub_index;
    //   long       rarity;
    //   /*
    //   UBYTE      unknown_a;
    //   UBYTE      unknown_b;
    //   UBYTE      unknown_c;
    //   UBYTE      unknown_d;
    //   */
    //   UBYTE      sub_tiles_flags[25];
    //   // int        zeros2[7];
    //   long       tiles_ptr;
    //   long       tiles_length;
    //   long       tiles_number;
    //   // int        zeros3[12];
    //} BLOCK_S;


    //blockπ¿º∆ «tileƒ«“ª¿‡..æÕ «dt¿Ô√ÊµƒøÈ◊¥Ω·ππ
    //“ÚŒ™‘⁄blockƒ⁄≤ø”–“ª∏ˆsound”Ú,  «»ÀŒÔ≤»‘⁄…œ√Êµƒ…˘“Ù

    //block_table « ≤√¥¡À? “ÚŒ™Œ“∑¢œ÷block_s∫Õblock_table_s”–∫‹∂‡œ‡À∆µƒ”Ú
    //±»»Á orientation, main_index÷Æ¿‡µƒ
    //µ´ «block_table_s√ª”–sound”Ú

    BLOCK_TABLE_S    *bt_ptr;
    BLOCK_S          *b_ptr;
    char             tmp_str[80];
    int              i, d, b, size;
    int              n = 0;

    //#define DT1_IN_DS1_MAX        33
    //π¿º∆ «32+1∏ˆds1edit.dt1
    for (i=0; i<DT1_IN_DS1_MAX; i++){
        d = glb_ds1[ds1_idx].dt1_idx[i];
        if(d != -1){
            n += glb_dt1[d].block_num;
        }
        //nªÒ»°µƒ «À˘”–dt1Œƒº˛µƒblock◊‹ ˝
    }
    //Œ™√´◊‘‘ˆ¡À“ªœ¬
    n++;
    //’‚¿Ôø¥¿¥√ø∏ˆblock∂º”–“ª∏ˆblock_table_s∞°
    size = sizeof(BLOCK_TABLE_S) * n;
    glb_ds1[ds1_idx].block_table = (BLOCK_TABLE_S *) malloc(size);
    if(glb_ds1[ds1_idx].block_table == NULL){
        FATAL_EXIT("make_block_table(%i), not enough mem for %i bytes\n", ds1_idx, size );
    }
    memset(glb_ds1[ds1_idx].block_table, 0, size);
    //block_table_numµƒ“‚Àº
    glb_ds1[ds1_idx].bt_num = n;

    // fill it
    bt_ptr = glb_ds1[ds1_idx].block_table;

    //µ⁄“ª∏ˆ ÷∂ØµƒÃÓ–¥?
    //√≤À∆µ⁄“ª∏ˆ“≤√ª”√...ƒ—µ¿’‚æÕ «…œ√Ên++µƒ‘≠“Ú?


    //Œ“œ÷‘⁄ª≥“…’‚∂Œ¥˙¬Î «◊˜’ﬂ¥”¡Ì“ª∏ˆ◊˜’ﬂƒ«¿Ôƒ√¿¥–ﬁ–ﬁ≤π≤π”√µƒ
    bt_ptr->orientation     = -1;
    bt_ptr->main_index      = -1;
    bt_ptr->sub_index       = -1;
    bt_ptr->rarity          = -1;
    bt_ptr->dt1_idx_for_ds1 = -1;
    bt_ptr->dt1_idx         = -1;
    bt_ptr->block_idx       = -1;
    bt_ptr->roof_y          = -1;
    bt_ptr->type            = -1;
    bt_ptr->zero_line       = -1;

    //µ⁄∂˛∏ˆblock_table_sø™ º
    bt_ptr++;


    //’‚¿Ô∞—bh_bufferµƒ∂´Œ˜»´≤øÃÓ–¥µΩbt_table÷–¡À
    //bh_bufferµƒ≥ı ºªØπ˝≥Ã≤Œº˚ void dt1_bh_update(int i)
    for(i=0; i<DT1_IN_DS1_MAX; i++){
        d = glb_ds1[ds1_idx].dt1_idx[i];
        if(d != -1){
            b_ptr = glb_dt1[d].bh_buffer;
            for(b=0; b<glb_dt1[d].block_num; b++){
                // sort-key
                //nmb,’‚–©∂º «”√¿¥≈≈–Úµƒ

                bt_ptr->orientation = b_ptr->orientation;
                bt_ptr->main_index  = b_ptr->main_index;
                bt_ptr->sub_index   = b_ptr->sub_index;
                bt_ptr->rarity      = b_ptr->rarity;

                // datas
                //’‚–©∂º «∏¸º”handyµƒblock_table ˝æ›Ω·ππ¡À
                //µ´ «À˘”––≈œ¢∂º÷±Ω”¿¥◊‘dt1Œƒº˛Ω‚Œˆ ±∫Úµƒblock_header

                // block headers : block_num structs of BLOCK_S
                // void       * bh_buffer;

                //ø¥¿¥block_s «÷±Ω”√Ë ˆ.dt1Œƒº˛Ω·ππµƒ ˝æ›Ω·ππ
                //∂¯block_table_s «∏¸º”«„œÚ”⁄≥Ã–Ú±æ…Ìµƒ ˝æ›Ω·ππ, ¿Ô√Êº”»Î¡À“ª–©‘⁄≥Ã–Ú÷–±ª∑÷≈‰µƒ∏˜÷÷±‡∫≈∫Õtype~

                bt_ptr->dt1_idx_for_ds1 = i;
                bt_ptr->dt1_idx         = d;
                bt_ptr->block_idx       = b;
                bt_ptr->roof_y          = 0;
                bt_ptr->zero_line       = 0;

                // type
                if (bt_ptr->orientation == 0){
                    // floor
                    bt_ptr->zero_line = 0;

                    if (b_ptr->animated == 0x01){
                        bt_ptr->type = BT_ANIMATED;
                    } else {
                        bt_ptr->type = BT_STATIC;
                    }
                }else if(bt_ptr->orientation == 13){
                    // shadow
                    bt_ptr->type      = BT_SHADOW;
                    bt_ptr->zero_line = - b_ptr->size_y;
                } else {
                    // walls
                    if ((bt_ptr->orientation == 10) || (bt_ptr->orientation == 11)) {
                        // special
                        bt_ptr->type      = BT_SPECIAL;
                        bt_ptr->zero_line = - b_ptr->size_y;
                    } else if (bt_ptr->orientation == 15) {
                        // roof
                        bt_ptr->type      = BT_ROOF;
                        bt_ptr->roof_y    = b_ptr->roof_y;
                        bt_ptr->zero_line = 0;
                    } else if (bt_ptr->orientation < 15) {
                        // wall up
                        bt_ptr->type      = BT_WALL_UP;
                        bt_ptr->zero_line = - b_ptr->size_y;
                    } else if (bt_ptr->orientation > 15) {
                        // wall down
                        bt_ptr->type      = BT_WALL_DOWN;
                        bt_ptr->zero_line = 96;
                    }
                }

                // next elements
                bt_ptr++;
                b_ptr++;
            }
        }
    }

    // display dt1 idx & file, to help user
    printf("\ndt1_idx file\n" "------- ---------------------------------------------------------------------\n");
    for (d=0; d<DT1_IN_DS1_MAX; d++) {
        if (glb_ds1[ds1_idx].dt1_idx[d] != -1) {
            for (i=0; i<DT1_MAX; i++) {
                if (i == glb_ds1[ds1_idx].dt1_idx[d]) {
                    if (glb_dt1[i].ds1_usage > 0) {
                        printf("%7i %s\n", i, glb_dt1[i].name);
                    }
                }
            }
        }
    }

    // sort it for conflict
    qsort(glb_ds1[ds1_idx].block_table, n, sizeof(BLOCK_TABLE_S), misc_qsort_helper_block_table_1);

    // conflicts managment
    //√ª∏„∂Æ
    misc_check_tiles_conflicts(ds1_idx);

    // sort it for useability
    qsort(glb_ds1[ds1_idx].block_table, n, sizeof(BLOCK_TABLE_S), misc_qsort_helper_block_table_2);

    // display it
    printf("\nsorted block_table of glb_ds1[%i] (%i blocks) :\n", ds1_idx, n);
    printf("block orientation main_idx sub_idx frame dt1_idx blk_idx roof_y type line0\n");
    printf("----- ----------- -------- ------- ----- ------- ------- ------ ---- -----\n");
    for (b=0; b<glb_ds1[ds1_idx].bt_num; b++) {
        printf("%5i %11li %8li %7li %5li %7li %7li %6i %4i %5i",
                b,
                glb_ds1[ds1_idx].block_table[b].orientation,
                glb_ds1[ds1_idx].block_table[b].main_index,
                glb_ds1[ds1_idx].block_table[b].sub_index,
                glb_ds1[ds1_idx].block_table[b].rarity,
                glb_ds1[ds1_idx].block_table[b].dt1_idx,
                glb_ds1[ds1_idx].block_table[b].block_idx,
                glb_ds1[ds1_idx].block_table[b].roof_y,
                glb_ds1[ds1_idx].block_table[b].type,
                glb_ds1[ds1_idx].block_table[b].zero_line
              );
        glb_ds1[ds1_idx].block_table[b].conflict = FALSE;
        if (glb_ds1[ds1_idx].block_table[b].rarity == 0) {
            if (b>1) {
                if ( (glb_ds1[ds1_idx].block_table[b].orientation == glb_ds1[ds1_idx].block_table[b-1].orientation) &&
                        (glb_ds1[ds1_idx].block_table[b].main_index  == glb_ds1[ds1_idx].block_table[b-1].main_index)  &&
                        (glb_ds1[ds1_idx].block_table[b].sub_index   == glb_ds1[ds1_idx].block_table[b-1].sub_index)
                   ) {
                    //√ª”–÷¥––µΩ’‚¿Ôµƒ..±Ì æ√ª”–≥ÂÕª~
                    glb_ds1[ds1_idx].block_table[b].conflict = TRUE;
                }
            }
            if (b < (glb_ds1[ds1_idx].bt_num-1)) {
                if ( (glb_ds1[ds1_idx].block_table[b].orientation == glb_ds1[ds1_idx].block_table[b+1].orientation) &&
                        (glb_ds1[ds1_idx].block_table[b].main_index  == glb_ds1[ds1_idx].block_table[b+1].main_index)  &&
                        (glb_ds1[ds1_idx].block_table[b].sub_index   == glb_ds1[ds1_idx].block_table[b+1].sub_index)
                   ) {
                    glb_ds1[ds1_idx].block_table[b].conflict = TRUE;
                }
            }
        }
        if (glb_ds1[ds1_idx].block_table[b].conflict) {
            printf(" *");
        }
        printf("\n");
    }
}


// ==========================================================================
// read the gamma correction file
void misc_read_gamma(void)
{
    FILE    *in;
    int      gt;
    int      i;
    int      v;
    char     tmp[150];
    char     gamma_path[100];

    DEBUG_MESSAGE("misc_read_gamma():in\n");

    sprintf(gamma_path, "%s/%s", glb_ds1edit_data_dir, "gamma.dat");
    DEBUG_MESSAGE("read gamma correction table (%s)\n", gamma_path);
    in = fopen(gamma_path, "rb");
    if(in == NULL){
        FATAL_EXIT("misc_read_gamma() : can't open %s", gamma_path);
    }

    for(gt=GC_060; gt<GC_MAX; gt++){
        for(i=0; i<256; i++){
            v = fgetc(in);
            glb_ds1edit.gamma_table[gt][i] = v;
        }
    }
    fclose(in);
    DEBUG_MESSAGE("misc_read_gamma():out\n");
}


// ==========================================================================
// update all the palettes with the current gamma correction
void misc_update_pal_with_gamma(void)
{
    int i;

    for (i=0; i<ACT_MAX; i++)
        misc_pal_d2_2_vga(i);
}


// ==========================================================================
// hexedit the screenshot to have the *exact* original palette
//    (allegro lost the 2 lowest bits)
// use the current gamma correction
void misc_pcx_put_d2_palette(char * name, int pal_idx)
{
    FILE * in;
    int  i, r, g, b, ridx;

    in = fopen(name, "rb+");
    if (in == NULL)
    {
        printf("warning : can't modify palette of file %s\n", name);
        return;
    }

    fseek(in, -768, SEEK_END);
    for (i=0; i<256; i++)
    {
        ridx = 4 * i;
        r = glb_ds1edit.d2_pal[pal_idx][ridx];
        g = glb_ds1edit.d2_pal[pal_idx][ridx + 1];
        b = glb_ds1edit.d2_pal[pal_idx][ridx + 2];
        fputc(glb_ds1edit.gamma_table[glb_ds1edit.cur_gamma][r], in);
        fputc(glb_ds1edit.gamma_table[glb_ds1edit.cur_gamma][g], in);
        fputc(glb_ds1edit.gamma_table[glb_ds1edit.cur_gamma][b], in);
    }
    fclose(in);
}


// ==========================================================================
// color map helper
void misc_make_cmaps_helper(const PALETTE pal, int x, int y, RGB * rgb)
{
    if (x == COL_SHADOW)
    {
        // full white
        rgb->r = 63;
        rgb->g = 63;
        rgb->b = 63;
    }
    else if (x == COL_MOUSE)
    {
        // half way between 2/3 of (2 * src) & 1/3 dst
        // result is brighter & have more white
        rgb->r = (pal[x].r + pal[y].r * 4) / 3;
        rgb->g = (pal[x].g + pal[y].g * 4) / 3;
        rgb->b = (pal[x].b + pal[y].b * 4) / 3;
        if (rgb->r > 63) rgb->r = 63;
        if (rgb->g > 63) rgb->g = 63;
        if (rgb->b > 63) rgb->b = 63;
    }
    else
    {
        // common transparency, half way between src & dst
        rgb->r = (pal[x].r + pal[y].r) >> 1;
        rgb->g = (pal[x].g + pal[y].g) >> 1;
        rgb->b = (pal[x].b + pal[y].b) >> 1;
    }
}


// ==========================================================================
// make (or read) all colormaps for all palettes
void misc_make_cmaps(void)
{
    CMAP_E cm;
    int    a, cmap_ok, i, c, start;
    char   tmp[100];
    FILE   * out, * in;

    printf("\n");
    for (cm=0; cm < CM_MAX; cm++)
    {
        for (a=0; a < ACT_MAX; a++)
        {
            fprintf(stderr, ".");
            sprintf(tmp, "%scmap%i_%i.bin", glb_ds1edit_data_dir, a, cm);
            cmap_ok = FALSE;
            if (file_exists(tmp, -1, NULL) && (glb_ds1edit.pal_loaded[a] == TRUE))
            {
                // load the colormap from disk, instead of making it
                in = fopen(tmp, "rb");
                if (in == NULL)
                    printf("can't read %s\n", tmp);
                else
                {
                    printf("loading %s\n", tmp);
                    fread(& glb_ds1edit.cmap[cm][a], sizeof(COLOR_MAP), 1, in);
                    fclose(in);
                    cmap_ok = TRUE;
                }
            }

            if (cmap_ok == FALSE)
            {
                // not found or can't be open, so create it

                if (cm == CM_SELECT)
                {
                    // color table
                    create_color_table(& glb_ds1edit.cmap[cm][a],
                            glb_ds1edit.vga_pal[a],
                            misc_make_cmaps_helper,
                            NULL);

                }
                else if (cm == CM_TRANS)
                {
                    create_trans_table(& glb_ds1edit.cmap[cm][a],
                            glb_ds1edit.vga_pal[a],
                            128, 128, 128,
                            NULL);
                }
                else if (cm == CM_SHADOW)
                {
                    for (c=0; c < 256; c++)
                    {
                        start = 1024 + (256 * (c/8));
                        for (i=0; i<256; i++)
                        {
                            glb_ds1edit.cmap[cm][a].data[c][i] =
                                glb_ds1edit.d2_pal[a][start + i];
                        }
                    }
                }

                out = fopen(tmp, "wb");
                if (out == NULL)
                    printf("can't write %s\n", tmp);
                else
                {
                    printf("saving %s\n", tmp);
                    fwrite(& glb_ds1edit.cmap[cm][a], sizeof(COLOR_MAP), 1, out);
                    fclose(out);
                }
            }
        }
    }
}


// ==========================================================================
// try to load 1 palette from the ./res/data/ directory
int misc_load_pal_from_disk(int pal_idx)
{
    char         tmp[100];
    FILE        *in;
    long         size;

    sprintf(tmp, "%s/pal%i.bin", glb_ds1edit_data_dir, pal_idx);
    if(file_exists(tmp, -1, NULL)){
        // load the palette from disk, instead of mpq
        in = fopen(tmp, "rb");
        if (in == NULL){
            DEBUG_MESSAGE("could not read %s\n", tmp);
        }else{
            // «Û»°Œƒº˛¥Û–°µƒ≥£”√∑Ω∑®
            fseek(in, 0, SEEK_END);
            size = ftell(in);
            fseek(in, 0, SEEK_SET);

            // malloc
            glb_ds1edit.d2_pal[pal_idx] = (UBYTE *) malloc(size);
            if (glb_ds1edit.d2_pal[pal_idx] == NULL){
                FATAL_EXIT("misc_load_pal_from_disk() : not enough mem (%li bytes) for palette %i", size, pal_idx);
            }
            // filling it
            DEBUG_MESSAGE("loading %s\n", tmp);
            fread(glb_ds1edit.d2_pal[pal_idx], size, 1, in);
            fclose(in);
            glb_ds1edit.pal_size[pal_idx] = size;
            return TRUE;
        }
    }
    return FALSE;
}


// ==========================================================================
// save the palette in the data\ directory (for quicker access next time)
void misc_save_pal_on_disk(int pal_idx, UBYTE * d2_pal_ptr)
{
    char tmp[100];
    FILE * out;

    sprintf(tmp, "%spal%i.bin", glb_ds1edit_data_dir, pal_idx);
    out = fopen(tmp, "wb");
    if (out == NULL)
        printf("can't write %s\n", tmp);
    else
    {
        printf("saving %s\n", tmp);
        fwrite(d2_pal_ptr, glb_ds1edit.pal_size[pal_idx], 1, out);
        fclose(out);
    }
}


// ==========================================================================
// own version of fgets()
// any special char means End Of String now, but NOT spaces !
int misc_my_fgets(char * dst, int max, FILE * in)
{
    int      i = 0;
    int      c;

    if (max <= 0){
        return 0;
    }

    for(;;) {
        c = fgetc(in);
        if (c == EOF) {
            dst[i] = 0;
            if (i){
                return 1;
            }else{
                return 0;
            }
        }
        if ((i >= (max - 1)) || (c < 32)){
            dst[i] = 0;
            while ((c < 32) && (c != EOF)){
                c  = fgetc(in);
            }
            if (c != EOF){
                ungetc(c, in);
            }
            return 1;
        }
        dst[i] = c;
        i++;
    }
}


// ==========================================================================
// return start of ds1 file to open (multiple ds1 to open mode)
char * misc_search_name(char * tmp)
{
    int max, i=0;

    max = strlen(tmp);
    if (max < 1)
        return NULL;

    // skip spaces
    while ((i < max) && (tmp[i] <= 32))
        i++;
    if (i >= max)
        return NULL;

    // skip 1st number
    while ((i < max) && (tmp[i] > 32))
        i++;
    if (i >= max)
        return NULL;

    // skip spaces
    while ((i < max) && (tmp[i] <= 32))
        i++;
    if (i >= max)
        return NULL;

    // skip 2nd number
    while ((i < max) && (tmp[i] > 32))
        i++;
    if (i >= max)
        return NULL;

    // skip spaces
    while ((i < max) && (tmp[i] <= 32))
        i++;
    if (i >= max)
        return NULL;

    // found name
    return & tmp[i];
}


// ==========================================================================
// open 1 ds1, & all the dt1 it needs
void misc_open_1_ds1(int ds1_idx, char * name, int type, int def, int new_width, int new_height)
{
    // ds1
    // 04.15
    
    DEBUG_MESSAGE("misc_open_1_ds1(\"%s\"):in\n", name );

    ds1_read(name, ds1_idx, new_width, new_height);

    // lvl*.txt (and loading dt1 from mpq)
    DEBUG_MESSAGE("searching Dt1Mask...\n");
    //√ª‘ı√¥ø¥~
    read_lvlprest_txt(ds1_idx, def);

    DEBUG_MESSAGE("loading dt1 from mpq...\n");
    // ø¥µΩ’‚¿Ô04.07
    glb_ds1[ds1_idx].txt_act = read_lvltypes_txt(ds1_idx, type);
    DEBUG_MESSAGE("txt_act = %i\n", glb_ds1[ds1_idx].txt_act);

    // make the block_table of this ds1
    misc_make_block_table(ds1_idx);

    // prop to index in block table
    ds1_make_prop_2_block(ds1_idx);
    DEBUG_MESSAGE("misc_open_1_ds1(\"%s\"):out\n", name );
}


// ==========================================================================
// open 1 ds1, and all the the dt1 it'll use
void misc_open_1_ds1_force_dt1(int ds1_idx)
{
    int  d;
    char * ds1_name = glb_ds1edit.cmd_line.ds1_filename;
    int  new_width  = glb_ds1edit.cmd_line.resize_width;
    int  new_height = glb_ds1edit.cmd_line.resize_height;
    char ds1edt_file[] = "ds1edit.dt1";
    char tmp[150];


    // ds1
    printf("\nreading ds1 : %s\n", ds1_name);
    fflush(stdout);
    fprintf(stderr, "reading %s...", ds1_name);
    ds1_read(ds1_name, ds1_idx, new_width, new_height);
    fprintf(stderr, "done\n");

    // always open ds1edit.dt1
    sprintf(tmp, "%s%s", glb_ds1edit_data_dir, ds1edt_file);
    printf("\nwant to read a dt1 : %s\n", tmp);
    glb_ds1[ds1_idx].dt1_idx[0] = dt1_add_special(tmp);

    // opening other dt1
    for (d=0; d < DT1_IN_DS1_MAX; d++)
        glb_ds1[ds1_idx].dt1_idx[d + 1] = -1;

    printf("\nloading dt1 from disk...\n");

    for (d=0; d < glb_ds1edit.cmd_line.dt1_list_num; d++)
    {
        printf("\nwant to read a dt1 : %s\n", glb_ds1edit.cmd_line.dt1_list_filename[d]);
        glb_ds1[ds1_idx].dt1_idx[d + 1] = dt1_add_special(glb_ds1edit.cmd_line.dt1_list_filename[d]);
    }

    glb_ds1[ds1_idx].txt_act = glb_ds1[ds1_idx].act;
    printf("\ndone\n");

    // make the block_table of this ds1
    misc_make_block_table(ds1_idx);

    // prop to index in block table
    ds1_make_prop_2_block(ds1_idx);
}


// ==========================================================================
// loop for opening several ds1
void misc_open_several_ds1(char * filename)
{
    FILE    *in;
    char    *name;

    int      type;
    int      def;
    int      ret;
    char     tmp[1000];
    int      ds1_idx =   0;

    in = fopen(filename, "rt");
    if(in == NULL){
        FATAL_EXIT("misc_open_several_ds1(), can't open %s", filename);
    }

    // ◊˜’ﬂµƒ∫Ø ˝, ≥˝¡Àø’∏ÒÕ‚µƒ»Œ∫ŒÃÿ ‚◊÷∑˚∂º±ª ”Œ™EOF
    // Ãÿ ‚◊÷∑˚±»»Á\t
    ret = misc_my_fgets(tmp, sizeof(tmp), in);
    while(ret != 0){
        // ªÒ»°µ⁄“ª∏ˆ∫Õµ⁄∂˛∏ˆ ˝◊÷
        sscanf(tmp, "%i %i", &type, &def);
        // ªÒ»°√˚◊÷( ≥˝»•«∞¡Ω∏ˆ ˝◊÷ )
        // ’‚¿Ô√ª”–≥˝»•Œƒº˛¬∑æ∂
        name = misc_search_name(tmp);

        // read the ds1
        if(glb_ds1edit.cmd_line.dt1_list_num != -1){
            // force dt1
            misc_open_1_ds1_force_dt1(ds1_idx);
        }else{
            // .ini¿˝◊”÷–‘À––µƒ «’‚øÈ~
            // find dt1 list from .txt
            // type∫Õdef∑÷± «.iniŒƒº˛÷–√ø“ª––µƒµ⁄“ª∏ˆ∫Õµ⁄∂˛∏ˆ ˝◊÷
            // √≤À∆◊Ó÷˜“™µƒπ§◊˜æÕ «≥ı ºªØblock_table_s
            // ’‚¿Ô¥´»Îµƒ «name(dri_town4.ds1) √ª”– ≤√¥¬∑æ∂, æÕ“ª∏ˆŒƒº˛√˚
            misc_open_1_ds1(
                    ds1_idx,
                    name,
                    type,
                    def,
                    glb_ds1edit.cmd_line.resize_width,
                    glb_ds1edit.cmd_line.resize_height
                    );
        }

        ds1_idx++;
        ret = misc_my_fgets(tmp, sizeof(tmp), in);
    }

    fclose(in);
}


// ==========================================================================
// load several pcx and make all the various tiles pcx for walkable info
void misc_walkable_tile_info_pcx(void)
{
    static char pcxname[11][30] = {
        {"./res/pcx/bit0.pcx"},
        {"./res/pcx/bit1.pcx"},
        {"./res/pcx/bit2.pcx"},
        {"./res/pcx/bit3.pcx"},
        {"./res/pcx/bit4.pcx"},
        {"./res/pcx/bit5.pcx"},
        {"./res/pcx/bit6.pcx"},
        {"./res/pcx/bit7.pcx"},
        {"./res/pcx/bit8.pcx"},
        {"./res/pcx/st_nowalk.pcx"},
        {"./res/pcx/st_nojump.pcx"} };
    int    loop, i, x0, y0, z;
    int      w=0;
    int      h=0;
    int      b=0;
    BITMAP * tmpbmp, * subtile, * subtile2;
    char     tmp[150];



    DEBUG_MESSAGE("misc_walkable_tile_info_pcx():in\n");
    glb_ds1edit.subtile_help = load_pcx("./res/pcx/st_help.pcx", glb_ds1edit.dummy_pal);
    if (glb_ds1edit.subtile_help == NULL) {
        FATAL_EXIT("could not open st_help.pcx\n");
    }

    for (loop=0; loop<11; loop++) {
        tmpbmp = load_pcx(pcxname[loop], glb_ds1edit.dummy_pal);
        if (tmpbmp == NULL) {
            FATAL_EXIT("could not open %s\n", pcxname[loop]);
        }
        for (i=0; i<25; i++) {
            subtile = create_bitmap(160, 80);
            if (subtile == NULL) {
                FATAL_EXIT("could not create the (%i - %i) bitmap ", loop, i);
            }
            clear(subtile);
            x0 = 64 - ((i/5) * 16) + ((i%5) * 16);
            y0 = ((i/5) * 8) + ((i%5) * 8);
            draw_sprite(subtile, tmpbmp, x0, y0);

            if (loop < 9) {
                glb_ds1edit.subtile_flag[loop][ZM_11][i] = get_rle_sprite(subtile);
            } else if (loop == 9) {
                glb_ds1edit.subtile_nowalk[ZM_11][i] = get_rle_sprite(subtile);
            } else {
                glb_ds1edit.subtile_nojump[ZM_11][i] = get_rle_sprite(subtile);
            }

            for (z=0; z<ZM_MAX; z++) {
                if (z == ZM_11) {
                    continue;
                }
                switch(z) {
                    case ZM_12  : w = 160 /  2; h = 80 /  2; break;
                    case ZM_14  : w = 160 /  4; h = 80 /  4; break;
                    case ZM_18  : w = 160 /  8; h = 80 /  8; break;
                    case ZM_116 : w = 160 / 16; h = 80 / 16; break;
                }
                subtile2 = create_bitmap(w, h);
                clear(subtile2);
                if (subtile2 == NULL) {
                    FATAL_EXIT("could not create the (%i - %i) bitmap at zoom %i", loop, i, z);
                }
                stretch_blit(subtile, subtile2, 0, 0, 160, 80, 0, 0, w, h);

                if (loop < 9){
                    glb_ds1edit.subtile_flag[loop][z][i] = get_rle_sprite(subtile2);
                } else if (loop == 9) {
                    glb_ds1edit.subtile_nowalk[z][i] = get_rle_sprite(subtile2);
                } else {
                    glb_ds1edit.subtile_nojump[z][i] = get_rle_sprite(subtile2);
                }

                destroy_bitmap(subtile2);
            }
            destroy_bitmap(subtile);
        }
        destroy_bitmap(tmpbmp);
    }

    // walkable tile infos combinations
    DEBUG_MESSAGE("walkable tile infos combinations\n");
    for (i=0; i<25; i++) {
        for (z=0; z<ZM_MAX; z++) {
            w = glb_ds1edit.subtile_flag[0][z][i]->w;
            h = glb_ds1edit.subtile_flag[0][z][i]->h;

            for (loop=0; loop<256; loop++) {
                subtile2 = create_bitmap(w, h);
                clear(subtile2);
                if (subtile2 == NULL) {
                    FATAL_EXIT("could not create the (%i - %i) bitmap at zoom %i", loop, i, z);
                }

                draw_rle_sprite(subtile2, glb_ds1edit.subtile_flag[0][z][i], 0, 0);
                for (b=0; b < 8; b++) {
                    if (loop & (1 << b)) {
                        draw_rle_sprite( subtile2, glb_ds1edit.subtile_flag[b+1][z][i], 0, 0);
                    }
                }

                glb_ds1edit.subtile_flag_combination[loop][z][i] = get_rle_sprite(subtile2);

                destroy_bitmap(subtile2);
            }
        }
    }

    // we don't need the non-combination RLE anymore
    for (b=0; b<9; b++) {
        for (z=0; z<ZM_MAX; z++) {
            for (i=0; i<25; i++) {
                if (glb_ds1edit.subtile_flag[b][z][i] != NULL) {
                    destroy_rle_sprite(glb_ds1edit.subtile_flag[b][z][i]);
                    glb_ds1edit.subtile_flag[b][z][i] = NULL;
                }
            }
        }
    }

    DEBUG_MESSAGE("misc_walkable_tile_info_pcx():out\n");
}


// ==========================================================================
// search the 2nd block table index of a upper / left corner tile
// (2nd corner tile = orientation 4)
int misc_seach_block_or4(int ds1_idx, BLOCK_TABLE_S * bt_ptr, int b,
        int m, int s)
{
    for(;;)
    {
        if (b >= glb_ds1[ds1_idx].bt_num)
            return -1;
        else
        {
            if ( (bt_ptr[b].orientation == 4) &&
                    (bt_ptr[b].main_index  == m) &&
                    (bt_ptr[b].sub_index   == s)
               )
            {
                return b;
            }
        }
        b++;
    }
}


// ==========================================================================
// fill the table with the walkable infos of all layers for 1 cell
void misc_search_walk_infos(int ds1_idx, int x, int y, UBYTE * dsttable)
{
    BLOCK_TABLE_S * bt_ptr;
    CELL_F_S      * f_ptr;
    CELL_W_S      * w_ptr;
    int           tf, tw, b, f, w, di, bi, i;
    BLOCK_S       * bh_ptr;
    UBYTE         * u_ptr, all_floor_props = 0;


    tf    = (y * glb_ds1[ds1_idx].floor_line) + (x * glb_ds1[ds1_idx].floor_num);
    tw    = (y * glb_ds1[ds1_idx].wall_line)  + (x * glb_ds1[ds1_idx].wall_num);
    f_ptr = glb_ds1[ds1_idx].floor_buff + tf;
    w_ptr = glb_ds1[ds1_idx].wall_buff  + tw;

    // init
    for (i=0; i<25; i++)
        dsttable[i] = 0; // no flags by default
    bt_ptr = glb_ds1[ds1_idx].block_table;

    // floors
    for (f=0; f < glb_ds1[ds1_idx].floor_num; f++)
    {
        all_floor_props |= f_ptr[f].prop1 | f_ptr[f].prop2 |
            f_ptr[f].prop3 | f_ptr[f].prop4;
        if (f_ptr[f].prop3 & 0x02)
        {
            // this is a global unwalkable info
            for (i=0; i<25; i++)
                dsttable[i] |= 1;
        }
        b = f_ptr[f].bt_idx;
        if (b > 0) // not -1 and not 0
        {
            di     = bt_ptr[b].dt1_idx;
            bi     = bt_ptr[b].block_idx;
            bh_ptr = glb_dt1[di].bh_buffer;
            u_ptr  = bh_ptr[bi].sub_tiles_flags;

            // add the flags
            for (i=0; i<25; i++)
                dsttable[i] |= u_ptr[i];
        }
    }

    // if no floor at all (F1 & F2 layer) the tile is completly unwalkable
    if (glb_ds1[ds1_idx].floor_num == 1)
    {
        if (f_ptr[0].prop1 == 0)
        {
            for (i=0; i<25; i++)
                dsttable[i] |= 1;
        }
    }
    else if (glb_ds1[ds1_idx].floor_num == 2)
    {
        if ((f_ptr[0].prop1 == 0) && (f_ptr[1].prop1 == 0))
        {
            for (i=0; i<25; i++)
                dsttable[i] |= 1;
        }
    }

    // walls
    for (w=0; w < glb_ds1[ds1_idx].wall_num; w++)
    {
        if (w_ptr[w].prop3 & 0x02)
        {
            // this is a global unwalkable info
            for (i=0; i<25; i++)
                dsttable[i] |= 1;
        }
        b = w_ptr[w].bt_idx;
        if (b > 0) // not -1 and not 0
        {
            di     = bt_ptr[b].dt1_idx;
            bi     = bt_ptr[b].block_idx;
            bh_ptr = glb_dt1[di].bh_buffer;
            u_ptr  = bh_ptr[bi].sub_tiles_flags;

            // add the flags
            for (i=0; i<25; i++)
                dsttable[i] |= u_ptr[i];

            // upper / left tile corner 2nd tile
            if (w_ptr[w].orientation == 3)
            {
                i = misc_seach_block_or4(ds1_idx,
                        bt_ptr,
                        b,
                        bt_ptr[b].main_index,
                        bt_ptr[b].sub_index
                        );
                if (i != -1)
                {
                    b      = i;
                    di     = bt_ptr[b].dt1_idx;
                    bi     = bt_ptr[b].block_idx;
                    bh_ptr = glb_dt1[di].bh_buffer;
                    u_ptr  = bh_ptr[bi].sub_tiles_flags;

                    // add the flags
                    for (i=0; i<25; i++)
                        dsttable[i] |= u_ptr[i];
                }
            }
        }
    }
}


// ==========================================================================
// load a file from mpq
//    first try in the mod directory, if not found in the 1st mpq it can
int misc_load_mpq_file(char * filename, char ** buffer, long * buf_len, int output)
{
    int  i, entry, max;


    // convert slash ('/') to backslash ('\\')
    // seems the mpq library expect backslash and not slash as directory separator
    strcpy(glb_ds1edit.strtmp, filename);
    max = strlen(glb_ds1edit.strtmp);
    for (i=0; i < max; i++) {
        if (glb_ds1edit.strtmp[i] == '/')
            glb_ds1edit.strtmp[i] = '\\';
    }

    // 1st try in mod directory
    //ΩˆΩˆ «¥”.txtŒƒº˛÷–øΩ±¥µΩƒ⁄¥Ê÷–
    //’‚¿Ô «øΩ±¥µΩ¡Àbuffer÷–¡À
    for (i=0; i<MAX_MOD_DIR; i++) {
        entry = mod_load_in_mem( glb_config.mod_dir[i], glb_ds1edit.strtmp, buffer, buf_len );
        if (entry != -1) {
            if (output) {
                DEBUG_MESSAGE("found in %s\n", glb_config.mod_dir[i]);
            }
            return entry;
        }
    }

    // 2nd try, in a mpq
    for (i=0; i<MAX_MPQ_FILE; i++) {
        if (glb_mpq_struct[i].is_open != FALSE) {
            glb_mpq = & glb_mpq_struct[i];
            entry = mpq_batch_load_in_mem( glb_ds1edit.strtmp, buffer, buf_len, output);
            if (entry != -1) {
                if (output) {
                    DEBUG_MESSAGE("found in %s\n", glb_config.mpq_file[i]);
                }
                return entry;
            }
        }
    }

    // not found
    return -1;
}


// ==========================================================================
// return the column number of a txt file, given its name
int misc_get_txt_column_num(RQ_ENUM txt_idx, char * col_name)
{
    int      i = 0;
    char    *desc;
    char     tmp_str[256];

    char     txt_list[RQ_MAX][80] = {
        {"Data\\Global\\Excel\\LvlTypes.txt"},
        {"Data\\Global\\Excel\\LvlPrest.txt"},
        {"data\\obj.txt"},
        {"Data\\Global\\Excel\\Objects.txt"},
    };

    if (txt_idx >= RQ_MAX){
        return -1;
    }

    for(;;) {
        // ’‚∏ˆ∂´Œ˜ «“‘«∞ ÷∂ØÃÓ»Îµƒ
        desc = glb_txt_req_ptr[txt_idx][i];
        if (desc == NULL){
            FATAL_EXIT("misc_get_txt_column_num() :\n   can't find <%s> in txt file <%i> <%s>\n", col_name, txt_idx, txt_list[txt_idx] );
        }else{
            if (stricmp(col_name, desc) == 0){
                return i;
            }else{
                i++;
            }
        }
    }
}


// ==========================================================================
int misc_is_numerical(char * str)
{
    int i, max = strlen(str);

    for (i=0; i < max; i++)
    {
        if ( (str[i] == '-') ||
                (str[i] == '+') ||
                (str[i] == '.') ||
                ((str[i] >= '0') && (str[i] <= '9'))
           )
        {
            // ok
        }
        else
            return FALSE;
    }
    return TRUE;
}


// ==========================================================================
// correct the pl2, for making allegro draw_sprite work as expected
void misc_pl2_correct(int i)
{
    //√ªÃ´ø¥∂Æ
    UBYTE     * bptr;
    int       c;
    COLOR_MAP * cmap;

    bptr = glb_ds1edit.d2_pal[i];
    for (c=0; c < 256; c++) {

        cmap = (COLOR_MAP *) & bptr[COF_75TRANS * 256];
        cmap->data[0][c] = c;

        cmap = (COLOR_MAP *) & bptr[COF_50TRANS * 256];
        cmap->data[0][c] = c;

        cmap = (COLOR_MAP *) & bptr[COF_25TRANS * 256];
        cmap->data[0][c] = c;

        cmap = (COLOR_MAP *) & bptr[COF_ALPHA * 256];
        cmap->data[0][c] = c;

        cmap = (COLOR_MAP *) & bptr[COF_LUMINANCE * 256];
        cmap->data[0][c] = c;

        cmap = (COLOR_MAP *) & bptr[COF_ALPHABRIGHT * 256];
        cmap->data[0][c] = c;
    }
}


// ==========================================================================
// parse a command line
// return -1 if error, 0 otherwise
int misc_cmd_line_parse(int argc, char ** argv)
{
    int  i                  = 0;
    int  force_dt1_present  = FALSE;
    char * ext              = NULL;
    int  n                  = 0;
    int  lvltype_id_found   = 0;
    int  lvlprest_def_found = 0;


    // is -force_dt1 present ?
    for (i=1; i < argc; i++) {
        if (stricmp(argv[i], "-force_dt1") == 0) {
            force_dt1_present = TRUE; // no LvlType.txt ID and no LvlPrest.txt DEF expected in the arguments
        }
    }

    // scan all parameters 1 by 1
    // ¥”argv[1]ø™ º“ª∏ˆ“ª∏ˆ…®√Ë
    for (i=1; i < argc; i++) {
        if (i == 1) {
            // .ini or .ds1 ?
            ext = get_extension(argv[i]);
            if (stricmp(ext, "ini") == 0) {
                glb_ds1edit.cmd_line.ini_filename = argv[i];
            } else if (stricmp(ext, "ds1") == 0) {
                glb_ds1edit.cmd_line.ds1_filename = argv[i];
            } else {
                WARNING_MESSAGE("the first argument must be a .ini or a .ds1 file\n");
                WARNING_MESSAGE("current extension = \"%s\")\n", ext);
                return -1;
            }
        } else if (stricmp(argv[i], "-debug") == 0) {
            // -debug
            glb_ds1edit.cmd_line.debug_mode = TRUE;
        } else if (stricmp(argv[i], "-no_vis_debug") == 0) {
            // -no_vis_debug
            glb_ds1edit.cmd_line.no_vis_debug = TRUE;
        } else if (stricmp(argv[i], "-force_dt1") == 0) {
            // -force_dt1, folowed by 1 to 32 .dt1 files
            i++;
            for (n=0; ((i + n) < argc) && (stricmp(get_extension(argv[i + n]), "dt1") == 0); n++) {
            }
            if ((n < 1) || (n > DT1_IN_DS1_MAX)) {
                printf("misc_cmd_line_parse(), error : there must be between 1 and %i .DT1 files folowing the -force_dt1 parameter\n", DT1_IN_DS1_MAX);
                return -1;
            }
            glb_ds1edit.cmd_line.dt1_list_num = n;
            for (n=0; n < glb_ds1edit.cmd_line.dt1_list_num; n++)
                glb_ds1edit.cmd_line.dt1_list_filename[n] = argv[i + n];
            i += (n - 1);
        } else if (stricmp(argv[i], "-resize") == 0) {
            // -resize, folowed by width and height values
            i++;
            if (i >= argc)
            {
                printf("misc_cmd_line_parse(), error : the -resize parameter should be folowed by width and height values\n");
                return -1;
            }
            if (misc_is_numerical(argv[i]))
                glb_ds1edit.cmd_line.resize_width = atoi(argv[i]);
            else
            {
                printf("misc_cmd_line_parse(), error : the width value folowing the -resize parameter is not a numerical value\n");
                return -1;
            }
            // height
            i++;
            if (i >= argc)
            {
                printf("misc_cmd_line_parse(), error : the -resize parameter is folowed by just a width value, the height value is missing\n");
                return -1;
            }
            if (misc_is_numerical(argv[i]))
                glb_ds1edit.cmd_line.resize_height = atoi(argv[i]);
            else
            {
                printf("misc_cmd_line_parse(), error : the height value folowing the -resize parameter is not a numerical value\n");
                return -1;
            }
        }
        else if (stricmp(argv[i], "-force_pal") == 0)
        {
            // -force_pal, folowed by an act value
            i++;
            if (i >= argc)
            {
                printf("misc_cmd_line_parse(), error : the parameter -force_pal should be folowed by an act value\n");
                return -1;
            }
            if (misc_is_numerical(argv[i]))
            {
                n = atoi(argv[i]);
                if ((n < 1) || (n > 5))
                {
                    printf("misc_cmd_line_parse(), error : the act value folowing the -force_pal parameter must be between 1 and 5\n");
                    return -1;
                }
                glb_ds1edit.cmd_line.force_pal_num = n;
            }
            else
            {
                printf("misc_cmd_line_parse(), error : the act value folowing the -force_pal parameter is not a numerical value\n");
                return -1;
            }
        }
        else if (stricmp(argv[i], "-no_check_act") == 0)
        {
            // -no_check_act is a flag
            glb_ds1edit.cmd_line.no_check_act = TRUE;
        }
        else if ((force_dt1_present == FALSE) && (glb_ds1edit.cmd_line.ds1_filename != NULL))
        {
            if ( ! lvltype_id_found)
            {
                // LvlType.txt ID
                lvltype_id_found = 1;
                if (misc_is_numerical(argv[i]))
                    glb_ds1edit.cmd_line.lvltype_id = atoi(argv[i]);
                else
                {
                    printf("misc_cmd_line_parse(), error : the LvlType.txt ID value is not a numerical value\n");
                    return -1;
                }
            }
            else if ( ! lvlprest_def_found)
            {
                // LvlPrest.txt DEF
                lvlprest_def_found = 1;
                if (misc_is_numerical(argv[i]))
                    glb_ds1edit.cmd_line.lvlprest_def = atoi(argv[i]);
                else
                {
                    printf("misc_cmd_line_parse(), error : the LvlPrest.txt DEF value is not a numerical value\n");
                    return -1;
                }
            }
            else
            {
                printf("misc_cmd_line_parse(), error : unexpected \"%s\" parameter\n", argv[i]);
                return -1;
            }
        }
    }

    return 0;
}


// ==========================================================================
void misc_draw_screen(int mx, int my)
{
    /*
    BITMAP * video_bmp    = glb_ds1edit.video_page[glb_ds1edit.video_page_num];
    BITMAP * mouse_sprite = glb_ds1edit.mouse_cursor[glb_ds1edit.mode];


    blit( glb_ds1edit.screen_buff, video_bmp, 0, 0, 0, 0, glb_config.screen.width, glb_config.screen.height);
    draw_sprite(video_bmp, mouse_sprite, mx, my);
    show_video_bitmap(video_bmp);
    glb_ds1edit.video_page_num = (glb_ds1edit.video_page_num + 1) % 2;
    */


    // œ¬√Êµƒ¥˙¬Î «√ª∞Ï∑®, –ﬁ∏ƒπ˝µƒ
    // “ÚŒ™–Èƒ‚ª˙œ¬√Êvideo page¥¥Ω®¿œ «≥ˆ¥Ì
    // ‘≠ º¥˙¬Î‘⁄…œ√Ê
    BITMAP * video_bmp    = glb_ds1edit.video_page[0];
    BITMAP * mouse_sprite = glb_ds1edit.mouse_cursor[glb_ds1edit.mode];


    blit( glb_ds1edit.screen_buff, video_bmp, 0, 0, 0, 0, glb_config.screen.width, glb_config.screen.height);
    draw_sprite(video_bmp, mouse_sprite, mx, my);
    show_video_bitmap(video_bmp);
}

// ==================================================================================
// for a given ds1, increase its objects structures by (at least) nb_objects elements
// return 0 if ok, -1 if error
// √ªœÍœ∏ø¥, π¿º∆“≤æÕÃÌº”“ªµ„ƒ⁄¥Ê÷Æ¿‡µƒ
int misc_increase_ds1_objects_max(int ds1_idx, long nb_objects)
{
    long old_max;
    long new_max;
    void * new_buffer;
    long old_size;
    long new_size;
    long nb_gran;


    if (nb_objects < 0)
        return 0;

    nb_gran = 1 + (nb_objects / OBJ_MAX_GRANULARITY);
    old_max = glb_ds1[ds1_idx].current_obj_max;
    new_max = old_max + (nb_gran * OBJ_MAX_GRANULARITY);

    // drawing_order
    old_size = old_max * sizeof(int);
    new_size = new_max * sizeof(int);
    new_buffer = (int *) malloc(new_size);
    if (new_buffer == NULL)
        return -1;
    memset(new_buffer, 0x00, new_size);
    memcpy(new_buffer, glb_ds1[ds1_idx].drawing_order, old_size);
    free(glb_ds1[ds1_idx].drawing_order);
    glb_ds1[ds1_idx].drawing_order = (int *) new_buffer;

    // obj
    old_size = old_max * sizeof(OBJ_S);
    new_size = new_max * sizeof(OBJ_S);
    new_buffer = (OBJ_S *) malloc(new_size);
    if (new_buffer == NULL)
        return -1;

    memset(new_buffer, 0x00, new_size);
    memcpy(new_buffer, glb_ds1[ds1_idx].obj, old_size);
    free(glb_ds1[ds1_idx].obj);
    glb_ds1[ds1_idx].obj = (OBJ_S *) new_buffer;

    // obj_undo
    old_size = old_max * sizeof(OBJ_S);
    new_size = new_max * sizeof(OBJ_S);
    new_buffer = (OBJ_S *) malloc(new_size);
    if (new_buffer == NULL)
        return -1;
    memset(new_buffer, 0x00, new_size);
    memcpy(new_buffer, glb_ds1[ds1_idx].obj_undo, old_size);
    free(glb_ds1[ds1_idx].obj_undo);
    glb_ds1[ds1_idx].obj_undo = (OBJ_S *) new_buffer;

    glb_ds1[ds1_idx].current_obj_max = new_max;
    return 0;
}
#include "structs.h"
#include "wmsg.h"
#include "msg_quit.h"


// ==========================================================================
// Message Window that appear when user ask to QUIT
// return value :
//    -1 : error
//     0 : save all & quit
//     1 : quit
//     2 : cancel
int msg_quit_main(void)
{
	WMSG_BUT_S buttons[4]; // 4th button is NULL, needed
	WMSG_S     wmsg_quit;
	int        col_black    = makecol(0, 0, 0),
			   col_midgreen = makecol(0, 128, 0),
			   col_white    = makecol(255, 255, 255),
			   col_green    = makecol(0, 255, 0);


	// init buttons
	memset(buttons, 0, sizeof(buttons));

	// button "Save all & Quit"
	buttons[0].text               = "(S) SAVE ALL & QUIT";
	buttons[0].right_spaces       = 3;
	buttons[0].on.fg              = col_black;
	buttons[0].on.bg              = col_midgreen;
	buttons[0].on.border          = col_white;
	buttons[0].off.fg             = col_green;
	buttons[0].off.bg             = col_black;
	buttons[0].off.border         = col_green;
	buttons[0].shortcut[0].key[0] = KEY_S;

	// button "Quit"
	buttons[1].text               = "  (Q) QUIT  ";
	buttons[1].right_spaces       = 3;
	buttons[1].on.fg              = col_black;
	buttons[1].on.bg              = col_midgreen;
	buttons[1].on.border          = col_white;
	buttons[1].off.fg             = col_green;
	buttons[1].off.bg             = col_black;
	buttons[1].off.border         = col_green;
	buttons[1].shortcut[0].key[0] = KEY_A;
	buttons[1].shortcut[1].key[0] = KEY_Q;

	// button "Cancel"
	buttons[2].text               = " (Esc) CANCEL ";
	buttons[2].right_spaces       = 0;
	buttons[2].on.fg              = col_black;
	buttons[2].on.bg              = col_midgreen;
	buttons[2].on.border          = col_white;
	buttons[2].off.fg             = col_green;
	buttons[2].off.bg             = col_black;
	buttons[2].off.border         = col_green;
	buttons[2].shortcut[0].key[0] = KEY_ESC;

	// window setting
	wmsg_quit.title        = "WARNING";
	wmsg_quit.text         = "\nYou are about to quit the DS1 Editor. What do you want to do ?";
	wmsg_quit.font_width   = 8;
	wmsg_quit.font_height  = 8;
	wmsg_quit.col_win.bg   = col_black;
	wmsg_quit.col_win.fg   = col_white;
	wmsg_quit.col_title.bg = col_green;
	wmsg_quit.col_title.fg = col_black;
	wmsg_quit.col_text.bg  = -1;
	wmsg_quit.col_text.fg  = col_green;
	wmsg_quit.button       = & buttons[0];

	return wmsg_main( & wmsg_quit);
}
#include "structs.h"
#include "wmsg.h"
#include "msg_save.h"


// ==========================================================================
// Message Window that appear after user asked to SAVE a ds1
// (this is only an informative window)
// return value :
//    -1 : error
//     0 : ok
int msg_save_main(void)
{
   WMSG_BUT_S buttons[2]; // 2nd button is NULL, needed
   WMSG_S     wmsg_save;
   int        col_black    = makecol(0, 0, 0),
              col_midgreen = makecol(0, 128, 0),
              col_white    = makecol(255, 255, 255),
              col_green    = makecol(0, 255, 0);


   // init buttons
   memset(buttons, 0, sizeof(buttons));

   // button "OK"
   buttons[0].text               = "  OK  ";
   buttons[0].right_spaces       = 0;
   buttons[0].on.fg              = col_black;
   buttons[0].on.bg              = col_midgreen;
   buttons[0].on.border          = col_white;
   buttons[0].off.fg             = col_green;
   buttons[0].off.bg             = col_black;
   buttons[0].off.border         = col_green;
   buttons[0].shortcut[0].key[0] = KEY_ENTER;
   buttons[0].shortcut[1].key[0] = KEY_ENTER_PAD;
   buttons[0].shortcut[2].key[0] = KEY_ESC;

   // window setting
   wmsg_save.title        = "Information";
   wmsg_save.text         = "\nYour DS1 has been saved";
   wmsg_save.font_width   = 8;
   wmsg_save.font_height  = 8;
   wmsg_save.col_win.bg   = col_black;
   wmsg_save.col_win.fg   = col_white;
   wmsg_save.col_title.bg = col_green;
   wmsg_save.col_title.fg = col_black;
   wmsg_save.col_text.bg  = -1;
   wmsg_save.col_text.fg  = col_green;
   wmsg_save.button       = & buttons[0];

   return wmsg_main( & wmsg_save);
}
#include <string.h>
#include "structs.h"
#include "error.h"
#include "misc.h"
#include "dt1misc.h"
#include "mpqview.h"
#include "txtread.h"


// ==========================================================================
// prepare the reading of a col value
// give del_char TRUE to replace the TAB and CR/LF chars by 0
//
// function set nb_char to # of characters there's in that value
// function set is_new_line if after col was a LF of CR/LF
// function return NULL if after col is EOF, else pointer on next col / line
// note : handle both LF and CR/LF line type
char * txt_gets(char * bptr, int * nb_char, int * is_new_line, int del_char)
{
    * is_new_line = FALSE;
    * nb_char = 0;

    // 	bptr÷∏œÚµƒŒ™“ª∏ˆ¡¨–¯◊÷∑˚¥Æƒ⁄¥Ê..∏√ «±ªΩÿµÙÕ∑≤øµƒobjects.txt
    //	œÚ«∞√ÊÀµµƒ:
    //	abcb...
    //	bcd...
    //	cd...
    //	d...
    //	∑µªÿµƒŒ™¥”ø™Õ∑ø™ º,”ˆµΩµƒµ⁄“ª∏ˆ÷∆±Ì∑˚÷Æ∫Ûµƒ–¬column,ªÚ’ﬂªª––¥”–¬ø™ ºµƒcolumn
    //	∂‘∞°..À˘“‘ø…“‘∑µªÿ–¬µƒ––µƒ..’‚ ±∫Ú≤Œ ˝±Ì÷–ªπ“™ªÿ¥¯“ª∏ˆis_new_line
    //
    //	ΩÿÕ∑ Ωµƒ∑µªÿ◊÷∑˚¥Æ
    //	”…”⁄¿Ô√Ê∞—÷∆±Ì…∂µƒªª≥…¡À0,“≤æÕ «NULL¡À
    //	À˘“‘’‚—˘ «∞≤»´µƒ
    //	Œ“≤¡..ƒ«◊Ó∫ÛŒƒº˛Ω·Œ≤‘ı√¥±Íº«
    //	∂‘¡À..√ª∂¡Œƒº˛,’‚¿Ô∂¡µƒ «¡¨–¯ƒ⁄¥Ê
    //	»Áπ˚µ±«∞ «∑«0,±Ì æ”–,ºÃ–¯,∞—”ˆµΩµƒµ⁄“ª∏ˆ÷∆±Ìªª≥…0
    //	≤¢«“∑µªÿœ¬“ª∏ˆø™ º¥¶
    //	»Áπ˚”ˆµΩµƒ «0,÷±Ω”∑µªÿ0,±Ì æ’ÊµƒΩ·Œ≤¡À


    for (;;)
    {
        if (bptr[* nb_char] == 0)
        {
            // end of file
            return NULL;
        }
        else if (bptr[* nb_char] == '\t')
        {
            // tab
            if (del_char == TRUE)
                bptr[* nb_char] = 0;
            return bptr + (* nb_char) + 1;
        }
        else if (bptr[* nb_char] == 0x0A)
        {
            // end of LF line
            * is_new_line = TRUE;
            if (del_char == TRUE)
                bptr[* nb_char] = 0;
            return bptr + (* nb_char) + 1;
        }
        else if (bptr[* nb_char] == 0x0D)
        {
            // end of CR / LF line
            * is_new_line = TRUE;
            if (del_char == TRUE)
                bptr[* nb_char] = 0;
            //		∑µªÿ≤È’“µΩµƒ÷µ
            return bptr + (* nb_char) + 2;
        }
        else
            (* nb_char)++;
    }
}


// ==========================================================================
void txt_count_header_cols(char * cur_col, int * col_count)
{
    int  nb_char, is_new_line;
    char * next_col = NULL;


    if ((cur_col == NULL) || (col_count == NULL))
        return;

    (* col_count) = 0;
    while (cur_col != NULL)
    {
        next_col = txt_gets(cur_col, & nb_char, & is_new_line, FALSE);

        // don't count empty headers or "*eol" column
        if (nb_char)
        {
            if (strncasecmp(cur_col, "*eol", 4) != 0)
                (* col_count)++;
        }

        // next col
        if ((is_new_line) || (next_col == NULL))
            return;
        else
            cur_col = next_col;
    }
}


// ==========================================================================
char * txt_read_header(char * cur_col, TXT_S * txt)
{
    int  nb_char, i, col_pos = 0, is_new_line;
    char * next_col = NULL;


    while (cur_col != NULL)
    {
        next_col = txt_gets(cur_col, & nb_char, & is_new_line, TRUE);
        if (nb_char)
        {
            // search if that col header is one of the required (or one of the user defined filters)
            for (i=0; i < txt->col_num; i++)
            {
                if (stricmp(cur_col, txt->col[i].name) == 0)
                {
                    // equal
                    txt->col[i].pos = col_pos;
                }
            }
        }
        // this col done
        col_pos++;

        // next col
        if (is_new_line)
            return next_col;
        else
            cur_col = next_col;
    }
    return NULL;
}


// ==========================================================================
int txt_check_type_and_size(char * cur_col, TXT_S * txt)
{

    //		’‚¿Ôµƒcur_col «ÀÕ¡À“ª––π˝¿¥,’‚“ª––◊∞¡ÀtxtŒƒº˛µƒÀ˘”– ˝æ›
    //		¥”µ⁄∂˛––ø™ º..÷±µΩ◊Ó∫Û“ª––...
    //		µ⁄“ª–– «√ø¡–µƒ√˚≥∆...

    int  nb_char, i, col_pos = 0, is_new_line = FALSE, x;
    char * next_col;

    if (cur_col == NULL)
        return 1;

    // for all lines, check the string size of the interesting columns
    txt->line_num = 0;
    col_pos = 0;
    while (cur_col != NULL)
    {
        // read this col
        //’‚¿Ôª·≤ª∂œµƒ"ΩÿÕ∑"
        //æŸ¿˝◊”:
        //abcdef...
        //bcdef...
        //cdef...
        //def...
        //ef...
        //f...
        //...
        //’‚÷÷...
        next_col = txt_gets(cur_col, & nb_char, & is_new_line, FALSE);

        if (nb_char)
        {
            // does this col is one of the required ?
            for (i=0; i < txt->col_num; i++)
            {
                if (col_pos == txt->col[i].pos)
                {
                    // update its maximum size if needed
                    //’‚¿Ô√ªÃ´ø¥√˜∞◊
                    if (nb_char > txt->col[i].size)
                        txt->col[i].size = nb_char;

                    // check its type
                    if (i >= txt->nb_required_cols)
                    {
                        // user defined filter : force to be string
                        if (txt->col[i].type == CT_NULL)
                            txt->col[i].type = CT_STR;
                    }
                    else
                    {
                        if (txt->col[i].type == CT_NULL)
                            txt->col[i].type = CT_NUM;

                        if (txt->col[i].type != CT_STR)
                        {
                            for (x=0; x < nb_char; x++)
                            {
                                if ( ((cur_col[x] < '0') || (cur_col[x] > '9'))
                                        &&
                                        cur_col[x] != '-')
                                {
                                    txt->col[i].type = CT_STR;
                                    x = nb_char;
                                }
                            }
                        }
                    }
                }
            }
        }

        // this col done
        col_pos++;

        // next col
        if (is_new_line)
        {
            txt->line_num++;
            col_pos = 0;
        }
        cur_col = next_col;
    }
    return 0;
}


// ==========================================================================
int txt_fill_data(char * cur_col, TXT_S * txt)
{
    //cur_col≤ª «“ª––.. «À˘”–––..≈™≥…“ª∏ˆ––¥´π˝¿¥¡À
    // ˝æ› «¥”txtŒƒº˛µƒµ⁄∂˛––ø™ ºµƒ..µ⁄“ª–– «À˘”–¡–µƒ√˚≥∆
    int  nb_char, i, col_pos = 0, is_new_line, cur_line = 0;
    char * next_col, * data_ptr, * sptr;
    long * lptr;

    if ((cur_col == NULL) || (txt->data == NULL))
        return 1;

    // for all lines, read the data
    col_pos = 0;
    data_ptr = txt->data;
    while (cur_col != NULL)
    {
        // read this col
        next_col = txt_gets(cur_col, & nb_char, & is_new_line, TRUE);

        if (nb_char)
        {
            // does this col is one of the required ?
            for (i=0; i < txt->col_num; i++)
            {
                if (col_pos == txt->col[i].pos)
                {
                    // copy it
                    sptr = data_ptr + txt->col[i].offset;
                    if (txt->col[i].type == CT_STR)
                        strcpy(sptr, cur_col);
                    else if (txt->col[i].type == CT_NUM)
                    {
                        lptr = (long *) sptr;
                        * lptr = atol(cur_col);
                    }
                }
            }
        }

        // this col done
        col_pos++;

        // next col
        if (is_new_line)
        {
            cur_line++;
            if (cur_line > txt->line_num)
                return 1;
            else
            {
                data_ptr += txt->line_size;
                col_pos = 0;
            }
        }
        cur_col = next_col;
    }
    return 0;
}


// ==========================================================================
TXT_S * txt_destroy(TXT_S * txt)
{
    if (txt == NULL)
        return NULL;
    if (txt->data != NULL)
        free(txt->data);
    if (txt->col != NULL)
        free(txt->col);
    free(txt);
    return NULL;
}


// ==========================================================================
void txt_get_user_filter_cols(char * cur_col, TXT_S * txt)
{
    int  nb_char, is_new_line;
    char * next_col = NULL;
    int  i = 0;
    char tmp[500] = "";
    int  size = 0;


    if ((cur_col == NULL) || (txt == NULL))
        return;

    while (cur_col != NULL)
    {
        next_col = txt_gets(cur_col, & nb_char, & is_new_line, FALSE);

        // don't count empty headers or "*eol" column
        if (nb_char)
        {
            if (strncasecmp(cur_col, "*eol", 4) != 0)
            {
                // is this column already in the required cols ?
                for (i=0; i < txt->nb_required_cols; i++)
                {
                    size = 0;
                    while ( (cur_col[size] != 0x00) && (cur_col[size] != '\t') &&
                            (cur_col[size] != 0x0D) && (cur_col[size] != 0x0A) )
                    {
                        size++;
                    }

                    if (strncasecmp(txt->col[i].name, cur_col, size) == 0)
                        break;
                }

                if (i >= txt->nb_required_cols)
                {
                    // this header is NOT already in the required cols, add it as a user defined filter

                    // search first free filter slot
                    while ((i < txt->col_num) && (strlen(txt->col[i].name) > 0)) {
                        i++;
                    }

                    if (i < txt->col_num) {
                        if (size >= TXT_COL_NAME_LENGTH) {
                            FATAL_EXIT("txt_get_user_filter_cols() : found a user defined filter header name that is more than %i characters : \"%.*s...\" (%i characters)" , TXT_COL_NAME_LENGTH - 1, TXT_COL_NAME_LENGTH - 1, cur_col, size);
                        }
                        strncpy(txt->col[i].name, cur_col, size);
                    }
                }
            }
        }

        // next col
        if ((is_new_line) || (next_col == NULL))
            return;
        else
            cur_col = next_col;
    }
}


// ==========================================================================
// note : the mem buffer MUST end by a 0
TXT_S * txt_load(char * mem, RQ_ENUM enum_txt, char * filename)
{
    //mem «txtµƒ÷±Ω”∏¥÷∆
    //enum_txt  «txtŒƒº˛µƒ∏Ò Ω..’‚¿Ô∏√ «objects,“ÚŒ™”–º∏÷÷∏Ò ΩµƒtxtŒƒº˛..Œ“≤¡
    //≤ª÷™µ¿Œ™…∂∞—filename¥¯…œ

    TXT_S       *txt = NULL;
    int         i=0;
    int         size=0;
    int         all_col_ok = TRUE;
    char        *first_line = NULL;
    char        tmp[150] = "";
    char        **required_col = NULL;


    DEBUG_MESSAGE("txt_load(\"%s\"):in\n",filename );
    if (((enum_txt < 0)) || (enum_txt >= RQ_MAX)) {
        FATAL_EXIT("parameter 'enum_txt' = %i, should be between 0 and %i", enum_txt, RQ_MAX - 1);
    }

    //       ’‚∏ˆÕÍ»´ «“ª∏ˆ“ª∏ˆÃÓ–¥µƒ, æŸ∏ˆ¿˝◊”:
    //        char * txt_def_obj_req[] =
    //        {
    //            // number
    //            ("Act"),
    //            ("Type"),
    //            ("Id"),
    //            ("Direction"),
    //            ("Index"),
    //            ("Objects.txt_ID"),
    //            ("Monstats.txt_ID"),
    //
    //            // text
    //            ("Base"),
    //            ("Token"),
    //            ("Mode"),
    //            ("Class"),
    //            ("HD"), ("TR"), ("LG"), ("RA"), ("LA"), ("RH"), ("LH"), ("SH"),
    //            ("S1"), ("S2"), ("S3"), ("S4"), ("S5"), ("S6"), ("S7"), ("S8"),
    //            ("Colormap"),
    //            ("Description"),
    //
    //            NULL // DO NOT REMOVE !
    //        };
    //    ∂¯glb_txt_req_ptr[enum_txt]’‚–©∂º «“ª∏ˆ“ª∏ˆÃÓ–¥Ω¯»•µƒ
    //    ’‚∏ˆrequired_col «“ª∏ˆ¡–±Ì÷–±ÿ–Îµƒ,∂¯’‚–©±ÿ–Îµƒ∂º « ÷∂ØÃÓ–¥µƒ...»Á…œ√Ê


    required_col = glb_txt_req_ptr[enum_txt];

    DEBUG_MESSAGE("loading %s\n", filename);

    // create a new TXT_S structure
    size = sizeof(TXT_S);
    txt = (TXT_S *) malloc(size);
    if (txt == NULL) {
        FATAL_EXIT("could not allocate %i bytes", size);
    }
    memset(txt, 0, size);

    // count the required columns
    // count the required columns,±ÿ–ÎµƒœÓƒøµƒ ˝¡ø,’‚¿ÔÕ≥º∆“ªœ¬
    //’‚¿Ô’‚∏ˆNULLæÕ « ÷∂Ø≥ı ºªØ ±∫Ú◊Ó∫Û“ª∏ˆNULL±ÿ–Î”–..≤ª»ª“™π“
    txt->nb_required_cols = 0;
    while (required_col[txt->nb_required_cols] != NULL) {
        txt->nb_required_cols++;
    }

    // count all the columns
    txt->col_num = 0;
    if (enum_txt == RQ_OBJ) {
        // editor's data/obj.txt : count all columns that have a header, to include user filter columns
        txt_count_header_cols(mem, & txt->col_num);
    } else {
        txt->col_num = txt->nb_required_cols;
    }

    txt->col = (TXT_COL_S *) calloc(txt->col_num + 1, sizeof(TXT_COL_S));
    if (txt->col == NULL) {
        txt = txt_destroy(txt);
        FATAL_EXIT("calloc() error for %i element * %i bytes each", txt->col_num + 1, sizeof(TXT_COL_S));
    }

    // init the cols, required cols first
    for (i=0; i < txt->col_num; i++) {
        txt->col[i].pos = -1;
        //		’‚¿Ô√ø“ª∏ˆ « ˙––µƒ¡–...
        //		À˘“‘”–100¡–, ø¥objects.txt“≤ƒ‹ø¥≥ˆ¿¥
        //		∂¯≤ª «”–∂‡…Ÿ––, ’‚∏ˆŒƒº˛”–1K+––ƒÿ...
        if (i < txt->nb_required_cols) {
            strncpy(txt->col[i].name, required_col[i], TXT_COL_NAME_LENGTH);
        }
    }

    // finish the init of cols, non-required cols last
    if (txt->nb_required_cols != txt->col_num) {
        txt_get_user_filter_cols(mem, txt);
    }

    // stage 1, process header   
    first_line = txt_read_header(mem, txt);
    for (i=0; i < txt->col_num; i++) {
        if (txt->col[i].pos == -1) {
            WARNING_MESSAGE("could not find required column %i (%s)\n", i, txt->col[i].name);
            all_col_ok = FALSE;
        }
    }

    if (all_col_ok != TRUE) {
        txt = txt_destroy(txt);
        FATAL_EXIT("not all columns have been found\n");
    }

    // stage 2, search max size of all string columns except header
    if (txt_check_type_and_size(first_line, txt)) {
        txt = txt_destroy(txt);
        FATAL_EXIT("stage 2, error shouldn't have happen\n");
    }

    // stage 3, make the struct
    size = 0;
    for (i=0; i < txt->col_num; i++) {
        txt->col[i].offset = size;
        if (txt->col[i].type == CT_NUM) {
            size += sizeof(long);
        } else if (txt->col[i].type == CT_STR) {
            size += (txt->col[i].size + 1);
        }
    }
    //’‚¿Ôµ√µΩ¡À“ª––µƒ◊Ó¥Ûsize
    txt->line_size = size;

    //∑÷≈‰M*N∏ˆ¡¨–¯ƒ⁄¥Êµ•‘™, ≤¢≥ı ºªØŒ™0
    txt->data = (char *) calloc(txt->line_num + 1, txt->line_size);
    if (txt->data == NULL) {
        txt = txt_destroy(txt);
        FATAL_EXIT("calloc() error for %i elements * %i bytes each\n", txt->line_num + 1, txt->line_size);
    }

    // stage 4, load the txt into the struct
    if (txt_fill_data(first_line, txt)) {
        txt = txt_destroy(txt);
        FATAL_EXIT("stage 4, error shouldn't have happen\n");
    }

    DEBUG_MESSAGE("txt_load(\"%s\"):out\n",filename );

    return txt;
}


// ==========================================================================
// load a .txt from a mpq (or mod dir) into mem
void * txt_read_in_mem(char * txtname)
{
    void * buff = NULL, * new_buff;
    int  entry;
    long len;
    char tmp[150];

    DEBUG_MESSAGE("want to read a txt from mpq : %s\n", txtname);
    //   ÷±Ω”µƒ¥”txtŒƒº˛÷–∏¥÷∆≥ˆ¿¥∂¯“—,∏¥÷∆µΩbuff÷–
    entry = misc_load_mpq_file(txtname, (char **) & buff, & len, TRUE);
    if ((entry == -1) || (buff == NULL)) {
        FATAL_EXIT("file %s not found\n", txtname);
    }

    len++;
    //º”≥§“ª∏ˆ◊÷Ω⁄,æÕŒ™¡À‘⁄‘⁄ƒ©Œ≤ÃÓ“ª∏ˆ0
    new_buff = realloc(buff, len);
    if (new_buff == NULL) {
        if (buff != NULL) {
            free(buff);
        }
        FATAL_EXIT("could not reallocate %i bytes for %s\n", len, txtname);
    }

    if (new_buff != buff) {
        memcpy(new_buff, buff, len - 1);
    }

    * (((char *) new_buff) + len - 1) = 0;

    return buff;
}


// ==========================================================================
void txt_convert_slash(char * str)
{
    // ÀÊ±„∏ƒ∞…, ’‚∏ˆ∫Ø ˝æÕ±ªµ˜”√π˝“ª¥Œ
    int i, s = strlen(str);


    for (i=0; i < s; i++) {
        if (str[i] == '\\'){
            str[i] = '/';
        }
        str[i] = tolower(str[i]);
    }
}


// ==========================================================================
// load lvlTypes.txt in mem, then load each dt1 for a 1 ds1
void txt_debug(char * file_path_mem, char * file_path_def, TXT_S * txt)
{
    FILE * out = NULL;
    int  i     = 0;


    if (glb_ds1edit.cmd_line.debug_mode != TRUE)
        return;

    if ((file_path_mem == NULL) || (file_path_def == NULL) || (txt == NULL))
        return;

    out = fopen(file_path_mem, "wb");
    if (out != NULL)
    {
        fwrite(txt->data, txt->line_size, txt->line_num, out);
        fclose(out);
    }

    out = fopen(file_path_def, "wt");
    if (out != NULL)
    {
        fprintf(out, "memory_col col_type %-*s txt_col_num data_type txt_data_size memory_offset\n",  TXT_COL_NAME_LENGTH, "header_name");
        fprintf(out, "---------- -------- %-.*s ----------- --------- ------------- -------------\n", TXT_COL_NAME_LENGTH, "------------------------------");

        for (i=0; i < txt->col_num; i++)
        {
            fprintf(
                    out,
                    "%10i %-8s %-*s %11i %-9s %13i %13i\n",
                    i,
                    (i >= txt->nb_required_cols) ? "Filter" : "Required",
                    TXT_COL_NAME_LENGTH,
                    txt->col[i].name,
                    txt->col[i].pos,
                    txt->col[i].type == CT_NUM ? "NUM" : "STR",
                    txt->col[i].size,
                    txt->col[i].offset
                   );
        }
        fclose(out);
    }
}


// ==========================================================================
// load lvlTypes.txt in mem, then load each dt1 for a 1 ds1
int read_lvltypes_txt(int ds1_idx, int type)
{
    TXT_S          *txt           = NULL;
    long           *lptr          = NULL;
    long           *tmp_long      = NULL;
    char           *buff;
    char           *sptr;

    char            lvltypes[]    = "data/global/excel/lvltypes.txt";
    char            tmp[150]      = "";
    char            name[256]     = "";
    char            ds1edt_file[] = "ds1edit.dt1";

    int             i;
    int             f;
    long            act;

    int             col_idx       = 0;
    int             file_1_idx    = 0;

    // load the file in mem
    if(glb_ds1edit.lvltypes_buff == NULL){
        //÷±Ω”∂¡»°µΩbuff÷–~Œﬁ ˝æ›Ω·ππ
        buff = txt_read_in_mem(lvltypes);
        if (buff == NULL){
            return -1;
        }

        // load the .txt in a more handy struct
        // Ïœ§¡À~
        txt = txt_load(buff, RQ_LVLTYPE, lvltypes);
        glb_ds1edit.lvltypes_buff = txt;
        free(buff);
        if (txt == NULL){
            return -1;
        }

        // debug files
        if (glb_ds1edit.cmd_line.debug_mode == TRUE){
            txt_debug(glb_path_lvltypes_mem, glb_path_lvltypes_def, txt);
        }
    }else{
        txt = glb_ds1edit.lvltypes_buff;
    }

    // search the good Id
    for(i=0; i < txt->line_num; i++){
        sptr = txt->data + (i * txt->line_size) + txt->col[misc_get_txt_column_num(RQ_LVLTYPE, "ID")].offset;
        lptr = (long *) sptr;
        if((* lptr) == type){
            // Id found
            DEBUG_MESSAGE( "Found ID %i in LvlTypes.txt at row %i, col %i\n", type, i + 1, txt->col[misc_get_txt_column_num(RQ_LVLTYPE, "ID")].pos );

            // check act
            sptr = txt->data + (i * txt->line_size) + txt->col[misc_get_txt_column_num(RQ_LVLTYPE, "Act")].offset;
            lptr = (long *) sptr;
            act  = * lptr;
            if((act != glb_ds1[ds1_idx].act) && (glb_ds1edit.cmd_line.no_check_act == FALSE)){
                FATAL_EXIT("Acts from lvltypes.txt (%li) and the Ds1 (%li) " "are different", act, glb_ds1[ds1_idx].act );
            }

            // opening dt1
            DEBUG_MESSAGE( "Found dt1files :\n" );
            file_1_idx = misc_get_txt_column_num(RQ_LVLTYPE, "File 1");
            //Œ™ ≤√¥ «–°”⁄33?
            //÷ªƒ‹”–33∏ˆŒƒº˛√¥?
            //Œ“º«µ√ «√ø∏ˆ…∂◊Ó∂‡÷ªƒ‹”–32∏ˆfile
            //’‚¿Ô «33∏ˆ..ø…ƒ‹∂‡¡À“ª∏ˆData/ds1edit.dt1
            for (f=0; f<33; f++){
                glb_ds1[ds1_idx].dt1_idx[f] = -1;
                if (f==0){
                    sprintf(tmp, "%s/%s", glb_ds1edit_data_dir, ds1edt_file);
                    DEBUG_MESSAGE("want to read a dt1 : %s\n", tmp);
                    //∂¡»°.dt1¿‡–ÕŒƒº˛”–∏ˆdt1editø…“‘ø¥‘¥¥˙¬Î~
                    glb_ds1[ds1_idx].dt1_idx[f] = dt1_add_special(tmp);

                }else{
                    col_idx = file_1_idx + (f - 1);
                    sptr = txt->data + (i * txt->line_size) + txt->col[col_idx].offset;
                    if(txt->col[col_idx].type == CT_STR){
                        strcpy(tmp, sptr);
                    }else if (txt->col[col_idx].type == CT_NUM){
                        tmp_long = (long *) sptr;
                        sprintf(tmp, "%li", * tmp_long);
                    }
                    txt_convert_slash(tmp);
                    strcpy(name, glb_tiles_path);
                    strcat(name, tmp);
                    if(glb_ds1[ds1_idx].dt1_mask[f]){
                        //’‚∏ˆdt1mask√≤À∆æÕ «”√≤ª”√µ±«∞dt1µƒ...Œ“Õ¸¡À‘⁄ƒƒ¿Ôø¥µƒ.. 
                        DEBUG_MESSAGE("want to read a dt1 from mpq : %s\n", name);
                        glb_ds1[ds1_idx].dt1_idx[f] = dt1_add(name);
                    }else{
                        if((tmp[0] != '0') && tmp[1] != 0){
                            DEBUG_MESSAGE("\n(skip %s)\n", tmp);
                        }
                    }
                }
            }
            // end
            return act;
        }
    }
    FATAL_EXIT("could not find the ID %i in LvlTypes.txt\n", type);
    return -1;
}


// ==========================================================================
// load lvlPrest.txt into mem, then search the Dt1Mask, given the Def Id
int read_lvlprest_txt(int ds1_idx, int def)
{
    TXT_S       *txt;
    char        *buff;
    long        *lptr;
    char        *sptr;
    char        *found_ptr = NULL;
    char        *lvlprest = "data/global/excel/lvlprest.txt";

    char         tmp[150];
    int          i, b, mask, filename_colidx[6], filename_idx, length, c, found_nb, last_found=0, last_slash, found_col=0;


    // load the file in mem
    if(glb_ds1edit.lvlprest_buff == NULL){
        // Œ“µ˜ ‘µƒ ±∫Ú‘À––µƒ’‚¿Ô
        // ÷±Ω”∂¡µΩƒ⁄¥Ê÷–
        // buff÷– «∏√txtµƒÀ˘”– ˝æ›
        buff = txt_read_in_mem( lvlprest );
        if(buff == NULL){
            return -1;
        }

        // load the .txt in a more handy struct
        // loadµΩ ˝æ›Ω·ππ÷–...∫‹ Ïœ§µƒÃ◊¬∑¡À
        txt = txt_load(buff, RQ_LVLPREST, lvlprest);
        glb_ds1edit.lvlprest_buff = txt;
        free(buff);
        if (txt == NULL){
            return -1;
        }

        // debug files
        if (glb_ds1edit.cmd_line.debug_mode == TRUE)
            txt_debug(glb_path_lvlprest_mem, glb_path_lvlprest_def, txt);
    }else{
        txt = glb_ds1edit.lvlprest_buff;
    }

    // search the good Def
    if(def == -1){
        //’‚œ¬√Ê√ª”–‘À––≈∂
        printf("AUTOMATIC LVLPREST.DEF DETECTION\n");
        fflush(stdout);

        // automatic search, base on filename
        filename_colidx[0] = misc_get_txt_column_num(RQ_LVLPREST, "File1");
        filename_colidx[1] = misc_get_txt_column_num(RQ_LVLPREST, "File2");
        filename_colidx[2] = misc_get_txt_column_num(RQ_LVLPREST, "File3");
        filename_colidx[3] = misc_get_txt_column_num(RQ_LVLPREST, "File4");
        filename_colidx[4] = misc_get_txt_column_num(RQ_LVLPREST, "File5");
        filename_colidx[5] = misc_get_txt_column_num(RQ_LVLPREST, "File6");

        found_nb = 0;
        for(i=0; i < txt->line_num; i++){
            for(filename_idx = 0; filename_idx < 6; filename_idx++){
                sptr = txt->data + (i * txt->line_size) + txt->col[ filename_colidx[filename_idx] ].offset;
                if(sptr != NULL){
                    length = strlen(sptr);
                    if(length > 0)
                    {
                        // search last '/' or last '\'
                        last_slash = 0;
                        for (c=0; c < length; c++)
                        {
                            if ((sptr[c] == '/') || (sptr[c] == '\\'))
                                last_slash = c;
                        }

                        // compare this filename with our ds1 filename
                        if (last_slash)
                            last_slash++;
                        if (last_slash >= length)
                            last_slash = length - 1;
                        if (stricmp(sptr + last_slash, glb_ds1[ds1_idx].filename) == 0)
                        {
                            // found one
                            found_nb++;
                            last_found = i;
                            found_ptr  = sptr;
                            found_col  = filename_idx;
                        }
                    }
                }
            }
        }

        if (found_nb == 1)
        {
            // only one, so no error
            //’‚¿Ô√ª”–‘À––π˝...
            //‘À––µƒ «else∑÷÷ß~

            i = last_found;

            sptr = txt->data + (i * txt->line_size) + txt->col[misc_get_txt_column_num(RQ_LVLPREST, "Def")].offset;
            lptr = (long *) sptr;

            printf("Found \"%s\" in LvlPrest.txt at row %i (DEF = %li, 'File%i' = \"%s\")\n",
                    glb_ds1[ds1_idx].filename,
                    i + 1,
                    * lptr,
                    found_col + 1,
                    found_ptr
                  );
            fflush(stdout);

            // dt1mask
            sptr = txt->data + (i * txt->line_size) + txt->col[misc_get_txt_column_num(RQ_LVLPREST, "Dt1Mask")].offset;
            lptr = (long *) sptr;
            mask = * lptr;

            printf("DT1MASK = %li in LvlPrest.txt at row %i, col %i\n",
                    mask, i + 1, txt->col[misc_get_txt_column_num(RQ_LVLPREST, "Dt1Mask")].pos);
            fflush(stdout);

            for (b=0; b < DT1_IN_DS1_MAX; b++)
            {
                if (b == 0)
                    glb_ds1[ds1_idx].dt1_mask[b] = TRUE;
                else
                    glb_ds1[ds1_idx].dt1_mask[b] = mask & (1 << (b-1)) ? TRUE : FALSE;
            }

            // end
            return 0;
        } else {
            if (found_nb >= 2) {
                FATAL_EXIT("couldn't found ds1 filename \"%s\" in LvlPrest.txt for sure : present %i times\n", glb_ds1[ds1_idx].filename, found_nb);
            } else {
                FATAL_EXIT("couldn't found ds1 filename \"%s\" in LvlPrest.txt\n", glb_ds1[ds1_idx].filename);
            }
        }
    }else{
        //‘À––µƒ «’‚¿Ô~
        for(i=0; i < txt->line_num; i++){
            sptr = txt->data + (i * txt->line_size) + txt->col[misc_get_txt_column_num(RQ_LVLPREST, "Def")].offset;
            lptr = (long *) sptr;
            if((* lptr) == def){
                // Def found
                DEBUG_MESSAGE("Found DEF %i in LvlPrest.txt at row %i, col %i\n", def, i + 1, txt->col[misc_get_txt_column_num(RQ_LVLPREST, "Def")].pos);

                // dt1mask
                sptr = txt->data + (i * txt->line_size) + txt->col[misc_get_txt_column_num(RQ_LVLPREST, "Dt1Mask")].offset;
                lptr = (long *) sptr;
                mask = * lptr;

                DEBUG_MESSAGE("DT1MASK = %li in LvlPrest.txt at row %i, col %i\n", mask, i + 1, txt->col[misc_get_txt_column_num(RQ_LVLPREST, "Dt1Mask")].pos);

                for (b=0; b < DT1_IN_DS1_MAX; b++){
                    if (b == 0){
                        glb_ds1[ds1_idx].dt1_mask[b] = TRUE;
                    }else{
                        glb_ds1[ds1_idx].dt1_mask[b] = mask & (1 << (b-1)) ? TRUE : FALSE;
                    }
                }

                // end
                return 0;
            }
        }
    }

    // end
    FATAL_EXIT("could not found the DEF %i in LvlPrest.txt\n", def);
    return -1; // useless, just to not have a warning under VC6
}


// ==========================================================================
// load the obj.txt into mem
int read_obj_txt(void)
{
    TXT_S      *txt;
    char       *buff;
    char       *sptr;
    long       *lptr;

    int         i;
    int         size;
    long        len;
    char        tmp[150];
    char        obj[] = "obj.txt";


    DEBUG_MESSAGE("read_obj_txt():in\n");
    // load the file in mem
    if (glb_ds1edit.obj_buff == NULL){
        DEBUG_MESSAGE("want to read %s from %s\n", obj, glb_ds1edit_data_dir );
        // ÷±Ω”øΩ±¥µΩbuff, ≥…π¶∑µªÿ0,  ß∞‹∑µªÿ-1
        if( mod_load_in_mem(glb_ds1edit_data_dir, obj, &buff, &len) == -1 ){
            FATAL_EXIT("read_obj_txt() : file %s not found", obj);
        }

        // load the .txt in a more handy struct
        // ∫‹ Ïœ§µƒÃ◊¬∑¡À
        txt = txt_load(buff, RQ_OBJ, obj);
        glb_ds1edit.obj_buff = txt;
        free(buff);
        if (txt == NULL){
            return -1;
        }

        // debug files
        if (glb_ds1edit.cmd_line.debug_mode == TRUE){
            txt_debug(glb_path_obj_mem, glb_path_obj_def, txt);
        }
    }else{
        txt = glb_ds1edit.obj_buff;
    }

    // malloc
    glb_ds1edit.obj_desc_num = txt->line_num;
    size = glb_ds1edit.obj_desc_num * sizeof(OBJ_DESC_S);
    glb_ds1edit.obj_desc = (OBJ_DESC_S *) malloc(size);
    if (glb_ds1edit.obj_desc == NULL){
        FATAL_EXIT("not enough mem for %i bytes\n", size);
    }
    memset(glb_ds1edit.obj_desc, 0, size);

    // read the obj.txt
    // txt->line_numæÕ «txtµƒ√ø“ª––
    // ≥ı ºªØ√ø“ª∏ˆobj
    // Œ“≤ªÃ´∂Æobj.txtŒƒº˛¿Ô√Ê√Ë ˆµƒ « ≤√¥∂´Œ˜
    for (i=0; i < txt->line_num; i++){

        // act
        sptr = txt->data + (i * txt->line_size) + txt->col[misc_get_txt_column_num(RQ_OBJ, "Act")].offset;
        lptr = (long *) sptr;
        glb_ds1edit.obj_desc[i].act = * lptr;

        // type
        sptr = txt->data + (i * txt->line_size) + txt->col[misc_get_txt_column_num(RQ_OBJ, "Type")].offset;
        lptr = (long *) sptr;
        glb_ds1edit.obj_desc[i].type = * lptr;

        // id
        sptr = txt->data + (i * txt->line_size) + txt->col[misc_get_txt_column_num(RQ_OBJ, "ID")].offset;
        lptr = (long *) sptr;
        glb_ds1edit.obj_desc[i].id = * lptr;

        // description
        sptr = txt->data + (i * txt->line_size) + txt->col[misc_get_txt_column_num(RQ_OBJ, "Description")].offset;
        glb_ds1edit.obj_desc[i].desc = sptr;
    }

    // lookups, to avoid to search them again and again
    glb_ds1edit.col_obj_id = misc_get_txt_column_num(RQ_OBJ, "Objects.txt_ID");

    DEBUG_MESSAGE("read_obj_txt():out\n");
    return 0;
}


// ==========================================================================
// load the objects.txt into mem
// ’‚∏ˆÕÊ“‚∂˘ø…ƒ‹ «’Ê’˝µƒ∂Øª≠»ÀŒÔ, “ÚŒ™”–frameµƒ∏≈ƒÓ
int read_objects_txt(void)
{
    TXT_S    *txt;
    char     *buff;
    char     *objects = "data/global/excel/objects.txt";


    DEBUG_MESSAGE("read_objects_txt():in\n");
    // load the file in mem
    if(glb_ds1edit.objects_buff == NULL){

        //	   ∞—txtµƒƒ⁄»›÷±Ω”∂¡»ÎµΩbuff÷–
        //	   √ª”– ˝æ›Ω·ππµƒ
        //	   ≤¢«“‘⁄bufferµƒŒ≤≤ø∏Ωº”…œ“ª∏ˆ0
        buff = txt_read_in_mem(objects);
        if (buff == NULL) {
            return -1;
        }

        // load the .txt in a more handy struct

        //typedef struct TXT_S
        //{
        //   char      * data;           // buffer having all lines
        //   int       line_num;         // number of lines
        //   int       line_size;        // size of 1 line (in bytes)
        //   int       nb_required_cols; // number of required columns
        //   int       col_num;          // total number of columns (required + user defined filters)
        //   TXT_COL_S * col;            // pointer on a table of TXT_COL_S
        //} TXT_S;

        //	  ’‚¿Ô–¥“ª∏ˆtxt ˝æ›Ω·ππµƒ¿˝◊”
        //       «loadÕÍobjects.txt∫Ûµƒ ˝æ›Ω·ππ:
        //	  txt = {
        //		 . *data			= \0;
        //		 . line_num			=	574
        //		 . line_size		=	432
        //		 . nb_required_cols	=	108
        //		 . col_num			=108
        //		 //’‚ «“ª∏ˆ÷∏’Î..À˘“‘÷ªƒ‹ø¥µΩµ⁄“ª∏ˆ‘™Àÿ~ µº …œ”–108∏ˆ‘™Àÿ
        //		 . col = {
        //			 .name		=	"ID"
        //			 .pos		=	2
        //			 .type		=	CT_NUM
        //			 .size		=	3
        //			 .offset	=	0
        //		 }
        //	  }

        txt = txt_load(buff, RQ_OBJECTS, objects);
        glb_ds1edit.objects_buff = txt;
        free(buff);
        if (txt == NULL){
            return -1;
        }

        // debug files
        if (glb_ds1edit.cmd_line.debug_mode == TRUE){
            txt_debug(glb_path_objects_mem, glb_path_objects_def, txt);
        }
    }else{
        txt = glb_ds1edit.objects_buff;
    }

    // lookups, to avoid to search them again and again
    // objects.txt÷–

    glb_ds1edit.col_objects_id     = misc_get_txt_column_num(RQ_OBJECTS, "Id");

    glb_ds1edit.col_frame_delta[0] = misc_get_txt_column_num(RQ_OBJECTS, "FrameDelta0");
    glb_ds1edit.col_frame_delta[1] = misc_get_txt_column_num(RQ_OBJECTS, "FrameDelta1");
    glb_ds1edit.col_frame_delta[2] = misc_get_txt_column_num(RQ_OBJECTS, "FrameDelta2");
    glb_ds1edit.col_frame_delta[3] = misc_get_txt_column_num(RQ_OBJECTS, "FrameDelta3");
    glb_ds1edit.col_frame_delta[4] = misc_get_txt_column_num(RQ_OBJECTS, "FrameDelta4");
    glb_ds1edit.col_frame_delta[5] = misc_get_txt_column_num(RQ_OBJECTS, "FrameDelta5");
    glb_ds1edit.col_frame_delta[6] = misc_get_txt_column_num(RQ_OBJECTS, "FrameDelta6");
    glb_ds1edit.col_frame_delta[7] = misc_get_txt_column_num(RQ_OBJECTS, "FrameDelta7");

    // orderflag  «∏ˆ…Ò¬Ì????
    glb_ds1edit.col_orderflag[0] = misc_get_txt_column_num(RQ_OBJECTS, "OrderFlag0");
    glb_ds1edit.col_orderflag[1] = misc_get_txt_column_num(RQ_OBJECTS, "OrderFlag1");
    glb_ds1edit.col_orderflag[2] = misc_get_txt_column_num(RQ_OBJECTS, "OrderFlag2");
    glb_ds1edit.col_orderflag[3] = misc_get_txt_column_num(RQ_OBJECTS, "OrderFlag3");
    glb_ds1edit.col_orderflag[4] = misc_get_txt_column_num(RQ_OBJECTS, "OrderFlag4");
    glb_ds1edit.col_orderflag[5] = misc_get_txt_column_num(RQ_OBJECTS, "OrderFlag5");
    glb_ds1edit.col_orderflag[6] = misc_get_txt_column_num(RQ_OBJECTS, "OrderFlag6");
    glb_ds1edit.col_orderflag[7] = misc_get_txt_column_num(RQ_OBJECTS, "OrderFlag7");
    DEBUG_MESSAGE("read_objects_txt():out\n");
    return 0;

}
#include "structs.h"
#include "error.h"
#include "ds1misc.h"
#include "undo.h"


// ==========================================================================
// after each cell, reset the flags to prepare the next 1
void undo_reset_flags(int ds1_idx)
{
    UNDO_DAT_FLG_S * df = & glb_ds1[ds1_idx].undo.dat_flg;
    int            i;

    for (i=0; i < FLOOR_MAX_LAYER; i++)
        df->f[i] = 0;

    for (i=0; i < SHADOW_MAX_LAYER; i++)
        df->s[i] = 0;

    for (i=0; i < WALL_MAX_LAYER; i++)
        df->w[i] = 0;
}


// ==========================================================================
// del tmp files at the end of the prog
void undo_exit(void)
{
    UNDO_S * u;
    struct al_ffblk f;
    int    done, i;
    char   tmp[150];

    for (i=0; i<DS1_MAX; i++)
    {
        if (strlen(glb_ds1[i].name))
        {
            u = & glb_ds1[i].undo;
            if (u->fptr != NULL)
            {
                fclose(u->fptr);
                u->fptr = NULL;
                strcpy(u->name, "");
            }
        }
    }

    sprintf(tmp, "%s%sundo*.bin", glb_ds1edit_data_dir, glb_ds1edit_tmp_dir);
    printf("\nremoving tmp undo buffers (%s)...", tmp);
    fprintf(stderr, "      . removing tmp undo buffers (%s)...", tmp);
    fflush(stderr);
    fflush(stdout);
    done = al_findfirst(tmp, &f, -1);
    while ( ! done)
    {
        sprintf(tmp, "%s%s%s", glb_ds1edit_data_dir, glb_ds1edit_tmp_dir, f.name);
        remove(tmp);
        done = al_findnext(&f);
    }
    al_findclose(&f);
    printf("done\n");
    fprintf(stderr, "done\n");
    fflush(stderr);
    fflush(stdout);
}


// ==========================================================================
// create a new tmp file
void undo_new_tile_buffer(int ds1_idx)
{
    UNDO_S * u = & glb_ds1[ds1_idx].undo;
    long   fake = 0, i;
    char   tmp[150];

    // just in case
    if (u->fptr != NULL) {
        fclose(u->fptr);
        FATAL_EXIT("undo_new_buffer() : undo file pointer was not NULL, tile buffer %s", u->name);
    }

    // some undo have been made ?
    if (u->cur_buf_num < u->buf_num - 1)
    {
        // delete "old" undo buffer
        for (i = u->cur_buf_num + 1; i < u->buf_num; i++)
        {
            sprintf(tmp, "%s%sundo%itile%li.bin", glb_ds1edit_data_dir,
                    glb_ds1edit_tmp_dir, ds1_idx, i);
            remove(tmp);
        }

        // adjust the buffer counter
        u->buf_num = u->cur_buf_num + 1;
    }

    // writing the file
    sprintf(u->name, "%s%sundo%itile%li.bin", glb_ds1edit_data_dir, glb_ds1edit_tmp_dir, ds1_idx, u->buf_num);
    u->fptr = fopen(u->name, "wb");
    if (u->fptr == NULL) {
        FATAL_EXIT("undo_new_tile_buffer() : can't create %s", u->name);
    }

    // tag
    fwrite(u->tag, sizeof(u->tag), 1, u->fptr);

    // fake segment number (will be updated later)
    u->seg_offset = ftell(u->fptr);
    fwrite(&fake, sizeof(u->seg_num), 1, u->fptr);

    // init
    u->in_seg      = FALSE;
    u->seg_num     = 0;
    u->cell_offset = -1;
    u->cell_num    = 0;
    u->old_x       = (UBYTE) -1;
    u->old_y       = (UBYTE) -1;
    undo_reset_flags(ds1_idx);
}


// ==========================================================================
// start a new segment of continuous cells in the undo buffer file
void undo_start_seg_in_tile_buffer(int ds1_idx, UBYTE x, UBYTE y)
{
    UNDO_S * u = & glb_ds1[ds1_idx].undo;
    long   fake = 0;
    char   tmp[150];

    // just in case
    if (u->fptr == NULL) {
        fclose(u->fptr);
        FATAL_EXIT("undo_start_seg_in_tile_buffer() : undo file pointeris NULL, tile buffer %li", u->buf_num);
    }

    // just in case (bis)
    if (u->in_seg != FALSE)
    {
        fclose(u->fptr);
        FATAL_EXIT("undo_start_seg_in_tile_buffer() : try to start a segment of cells while current one not closed");
    }

    // start new seg
    u->in_seg = TRUE;
    u->seg_num++;

    // starting cell
    fwrite(&x, sizeof(x), 1, u->fptr);
    fwrite(&y, sizeof(y), 1, u->fptr);

    // fake cell number of this segment (will be updated later)
    u->cell_offset = ftell(u->fptr);
    fwrite(&fake, sizeof(u->cell_num), 1, u->fptr);

    // init
    u->cell_num = 0;
    u->old_x    = x - 1;
    u->old_y    = y;
}


// ==========================================================================
// close a segment
void undo_close_seg_in_tile_buffer(int ds1_idx)
{
    UNDO_S * u = & glb_ds1[ds1_idx].undo;
    long   old_ptr;
    char   tmp[150];

    // just in case
    if (u->fptr == NULL) {
        fclose(u->fptr);
        FATAL_EXIT("undo_close_seg_in_tile_buffer() : undo file pointeris NULL, tile buffer %li", u->buf_num);
    }

    if (u->seg_num != 0) {
        // just in case
        if (u->in_seg == FALSE) {
            fclose(u->fptr);
            FATAL_EXIT("undo_close_seg_in_tile_buffer() : try to close a segment of cells while none was started");
        }

        // end the segment, write the TRUE cell number
        old_ptr = ftell(u->fptr);
        fseek(u->fptr, u->cell_offset, SEEK_SET);
        fwrite(&u->cell_num, sizeof(u->cell_num), 1, u->fptr);
        fseek(u->fptr, old_ptr, SEEK_SET);
    }

    // init
    u->in_seg = FALSE;
}


// ==========================================================================
// add 1 cell datas to the current undo buffer
void undo_add_to_tile_buffer(int ds1_idx, int ix, int iy)
{
    UNDO_S         * u  = & glb_ds1[ds1_idx].undo;
    UNDO_DAT_FLG_S * df = & u->dat_flg;
    int            tf   = (iy * glb_ds1[ds1_idx].floor_line) +
        (ix * glb_ds1[ds1_idx].floor_num),
        ts   = (iy * glb_ds1[ds1_idx].shadow_line) +
            (ix * glb_ds1[ds1_idx].shadow_num),
        tw   = (iy * glb_ds1[ds1_idx].wall_line)  +
            (ix * glb_ds1[ds1_idx].wall_num),
        i;
    CELL_F_S       * f  = glb_ds1[ds1_idx].floor_buff  + tf;
    CELL_S_S       * s  = glb_ds1[ds1_idx].shadow_buff + ts;
    CELL_W_S       * w  = glb_ds1[ds1_idx].wall_buff   + tw;
    UWORD          layer_flag = 0; // 4 walls + 4 floors + 1 shadow = 9 bits
    UBYTE          x = ix & 0xFF, y = iy & 0xFF;
    char           tmp[150];

    // just in case
    if (u->fptr == NULL) {
        FATAL_EXIT("undo_add_to_tile_buffer() : can't write in undo tile buffer %li", u->buf_num);
    }

    // check which datas are to be to saved
    for (i=0; i < glb_ds1[ds1_idx].floor_num; i++)
        if (df->f[i])
            layer_flag |= 1 << i;
    for (i=0; i < glb_ds1[ds1_idx].shadow_num; i++)
        if (df->s[i])
            layer_flag |= 1 << (i + FLOOR_MAX_LAYER);
    for (i=0; i < glb_ds1[ds1_idx].wall_num; i++)
        if (df->w[i])
            layer_flag |= 1 << (i + FLOOR_MAX_LAYER + SHADOW_MAX_LAYER);

    // save them (if any)
    if (layer_flag)
    {
        // same segment ?
        if ( (u->seg_num == 0) || ((x != (u->old_x + 1)) || (y != u->old_y)) )
        {
            // another segment, close a precedent one ?
            if (u->in_seg != FALSE)
            {
                // close the precednet
                undo_close_seg_in_tile_buffer(ds1_idx);
            }

            // start a new one
            undo_start_seg_in_tile_buffer(ds1_idx, x, y);
        }

        // add this cell to the segment
        fwrite(&layer_flag, sizeof(layer_flag), 1, u->fptr);
        for (i=0; i < glb_ds1[ds1_idx].floor_num; i++)
        {
            if (layer_flag & (1 << i))
            {
                fwrite(&df->f[i], sizeof(df->f[i]), 1, u->fptr);

                if (df->f[i] & DF_P1)
                    fwrite(&f[i].prop1, sizeof(f[i].prop1), 1, u->fptr);

                if (df->f[i] & DF_P2)
                    fwrite(&f[i].prop2, sizeof(f[i].prop2), 1, u->fptr);

                if (df->f[i] & DF_P3)
                    fwrite(&f[i].prop3, sizeof(f[i].prop3), 1, u->fptr);

                if (df->f[i] & DF_P4)
                    fwrite(&f[i].prop4, sizeof(f[i].prop4), 1, u->fptr);

                if (df->f[i] & DF_BT)
                    fwrite(&f[i].bt_idx, sizeof(f[i].bt_idx), 1, u->fptr);

                if (df->f[i] & DF_FL)
                    fwrite(&f[i].flags, sizeof(f[i].flags), 1, u->fptr);
            }
        }
        for (i=0; i < glb_ds1[ds1_idx].shadow_num; i++)
        {
            if (layer_flag & (1 << (i + FLOOR_MAX_LAYER)))
            {
                fwrite(&df->s[i], sizeof(df->s[i]), 1, u->fptr);

                if (df->s[i] & DF_P1)
                    fwrite(&s[i].prop1, sizeof(s[i].prop1), 1, u->fptr);

                if (df->s[i] & DF_P2)
                    fwrite(&s[i].prop2, sizeof(s[i].prop2), 1, u->fptr);

                if (df->s[i] & DF_P3)
                    fwrite(&s[i].prop3, sizeof(s[i].prop3), 1, u->fptr);

                if (df->s[i] & DF_P4)
                    fwrite(&s[i].prop4, sizeof(s[i].prop4), 1, u->fptr);

                if (df->s[i] & DF_BT)
                    fwrite(&s[i].bt_idx, sizeof(s[i].bt_idx), 1, u->fptr);

                if (df->s[i] & DF_FL)
                    fwrite(&s[i].flags, sizeof(s[i].flags), 1, u->fptr);
            }
        }
        for (i=0; i < glb_ds1[ds1_idx].wall_num; i++)
        {
            if (layer_flag & (1 << (i + FLOOR_MAX_LAYER + SHADOW_MAX_LAYER)))
            {
                fwrite(&df->w[i], sizeof(df->w[i]), 1, u->fptr);

                if (df->w[i] & DF_P1)
                    fwrite(&w[i].prop1, sizeof(w[i].prop1), 1, u->fptr);

                if (df->w[i] & DF_P2)
                    fwrite(&w[i].prop2, sizeof(w[i].prop2), 1, u->fptr);

                if (df->w[i] & DF_P3)
                    fwrite(&w[i].prop3, sizeof(w[i].prop3), 1, u->fptr);

                if (df->w[i] & DF_P4)
                    fwrite(&w[i].prop4, sizeof(w[i].prop4), 1, u->fptr);

                if (df->w[i] & DF_OR)
                    fwrite(&w[i].orientation, sizeof(w[i].orientation), 1, u->fptr);

                if (df->w[i] & DF_BT)
                    fwrite(&w[i].bt_idx, sizeof(w[i].bt_idx), 1, u->fptr);

                if (df->w[i] & DF_FL)
                    fwrite(&w[i].flags, sizeof(w[i].flags), 1, u->fptr);
            }
        }

        // this cell was writen
        undo_reset_flags(ds1_idx);
        u->old_x++;
        u->cell_num++;
    }
}


// ==========================================================================
// close the undo buffer
void undo_close_tile_buffer(int ds1_idx)
{
    UNDO_S * u = & glb_ds1[ds1_idx].undo;
    long   old_ptr;
    char   tmp[150];

    // just in case
    if (u->fptr == NULL) {
        FATAL_EXIT("undo_close_tile_buffer() : no undo tile buffer pointer to close (%li)", u->buf_num);
    }

    if (u->in_seg != FALSE)
        undo_close_seg_in_tile_buffer(ds1_idx);

    // write the True segment number
    old_ptr = ftell(u->fptr);
    fseek(u->fptr, u->seg_offset, SEEK_SET);
    fwrite(&u->seg_num, sizeof(u->seg_num), 1, u->fptr);
    fseek(u->fptr, old_ptr, SEEK_SET);

    // close
    if (fclose(u->fptr) != 0) {
        FATAL_EXIT("undo_close_tile_buffer() : can't close undo tile buffer %li", u->buf_num);
    }

    // end
    u->cur_buf_num = u->buf_num;
    u->buf_num++;
    u->fptr = NULL;
    strcpy(u->name, "");
}


// ==========================================================================
// open and apply an undo buffer into the ds1
void undo_apply_tile_buffer(int ds1_idx)
{
    UNDO_S * u = & glb_ds1[ds1_idx].undo;
    FILE   * in;
    int    tf, ts, tw, i, c, s, seg_num, cell_num, x, y, layer_flag, data_flag;
    CELL_F_S * f;
    CELL_S_S * sh;
    CELL_W_S * w;
    char   undo_file[100], tmp[100];

    if ((u->buf_num <= 0) || (u->cur_buf_num < 0))
        return;

    sprintf(undo_file, "%s%sundo%itile%li.bin", glb_ds1edit_data_dir,
            glb_ds1edit_tmp_dir, ds1_idx, u->cur_buf_num);
    in = fopen(undo_file, "rb");
    if (in == NULL) {
        FATAL_EXIT("undo_apply_tile_buffer() : can't open %s", undo_file);
    }

    for (i=0; i < sizeof(u->tag); i++) {
        c = fgetc(in);
        if (c != u->tag[i]) {
            fclose(in);
            FATAL_EXIT("undo_apply_tile_buffer() : wrong tag in %s", u->name);
        }
    }

    seg_num = fgetc(in);
    for (s=0; s < seg_num; s++)
    {
        x  = fgetc(in);
        y  = fgetc(in);
        cell_num = fgetc(in);
        for (c=0; c < cell_num; c++)
        {
            if ( (x < 0) || (y < 0) || (x >= glb_ds1[ds1_idx].width) || (y >= glb_ds1[ds1_idx].height)) {
                fclose(in);
                FATAL_EXIT("undo_apply_tile_buffer() : wrong cell (%i, %i)", x, y);
            }
            tf = (y * glb_ds1[ds1_idx].floor_line)  + (x * glb_ds1[ds1_idx].floor_num);
            ts = (y * glb_ds1[ds1_idx].shadow_line) + (x * glb_ds1[ds1_idx].shadow_num);
            tw = (y * glb_ds1[ds1_idx].wall_line)   + (x * glb_ds1[ds1_idx].wall_num);
            f  = glb_ds1[ds1_idx].floor_buff  + tf;
            sh = glb_ds1[ds1_idx].shadow_buff + ts;
            w  = glb_ds1[ds1_idx].wall_buff   + tw;
            fread(&layer_flag, sizeof(UWORD), 1, in);
            for (i=0; i < glb_ds1[ds1_idx].floor_num; i++)
            {
                if (layer_flag & (1 << i))
                {
                    data_flag = fgetc(in);

                    if (data_flag & DF_P1)
                        f[i].prop1 = fgetc(in);

                    if (data_flag & DF_P2)
                        f[i].prop2 = fgetc(in);

                    if (data_flag & DF_P3)
                        f[i].prop3 = fgetc(in);

                    if (data_flag & DF_P4)
                        f[i].prop4 = fgetc(in);

                    if (data_flag & DF_BT)
                        fread(&f[i].bt_idx, sizeof(f[i].bt_idx), 1, in);
                    else
                        fprop_2_block(ds1_idx, &f[i]);

                    if (data_flag & DF_FL)
                        f[i].flags = fgetc(in);
                }
            }
            for (i=0; i < glb_ds1[ds1_idx].shadow_num; i++)
            {
                if (layer_flag & (1 << (i + FLOOR_MAX_LAYER)))
                {
                    data_flag = fgetc(in);

                    if (data_flag & DF_P1)
                        sh[i].prop1 = fgetc(in);

                    if (data_flag & DF_P2)
                        sh[i].prop2 = fgetc(in);

                    if (data_flag & DF_P3)
                        sh[i].prop3 = fgetc(in);

                    if (data_flag & DF_P4)
                        sh[i].prop4 = fgetc(in);

                    if (data_flag & DF_BT)
                        fread(&sh[i].bt_idx, sizeof(sh[i].bt_idx), 1, in);
                    else
                        sprop_2_block(ds1_idx, &sh[i]);

                    if (data_flag & DF_FL)
                        sh[i].flags = fgetc(in);
                }
            }
            for (i=0; i < glb_ds1[ds1_idx].wall_num; i++)
            {
                if (layer_flag & (1 << (i + FLOOR_MAX_LAYER + SHADOW_MAX_LAYER)))
                {
                    data_flag = fgetc(in);

                    if (data_flag & DF_P1)
                        w[i].prop1 = fgetc(in);

                    if (data_flag & DF_P2)
                        w[i].prop2 = fgetc(in);

                    if (data_flag & DF_P3)
                        w[i].prop3 = fgetc(in);

                    if (data_flag & DF_P4)
                        w[i].prop4 = fgetc(in);

                    if (data_flag & DF_OR)
                        w[i].orientation = fgetc(in);

                    if (data_flag & DF_BT)
                        fread(&w[i].bt_idx, sizeof(w[i].bt_idx), 1, in);
                    else
                        wprop_2_block(ds1_idx, &w[i]);

                    if (data_flag & DF_FL)
                        w[i].flags = fgetc(in);
                }
            }
            x++;
        }
    }
    fclose(in);
    u->cur_buf_num--;
}


// ==========================================================================
// add a cell to the undo buffer
// data aren't in the current ds1 cells
void undo_add_this_tile_to_buffer(int ds1_idx, int ix, int iy,
        CELL_F_S * f, CELL_W_S * w, CELL_S_S * s)
{
    UNDO_S         * u  = & glb_ds1[ds1_idx].undo;
    UNDO_DAT_FLG_S * df = & u->dat_flg;
    int            i;
    UWORD          layer_flag = 0; // 4 walls + 4 floors + 1 shadow = 9 bits
    UBYTE          x = ix & 0xFF, y = iy & 0xFF;
    char           tmp[150];


    // just in case
    if (u->fptr == NULL) {
        FATAL_EXIT("undo_add_to_tile_buffer() : can't write in undo tile buffer %li", u->buf_num);
    }

    // check which datas are to be to saved
    for (i=0; i < glb_ds1[ds1_idx].floor_num; i++)
        if (df->f[i])
            layer_flag |= 1 << i;

    for (i=0; i < glb_ds1[ds1_idx].shadow_num; i++)
        if (df->s[i])
            layer_flag |= 1 << (i + FLOOR_MAX_LAYER);

    for (i=0; i < glb_ds1[ds1_idx].wall_num; i++)
        if (df->w[i])
            layer_flag |= 1 << (i + FLOOR_MAX_LAYER + SHADOW_MAX_LAYER);


    // save them (if any)
    if (layer_flag)
    {
        // same segment ?
        if ( (u->seg_num == 0) || ((x != (u->old_x + 1)) || (y != u->old_y)) )
        {
            // another segment, close a precedent one ?
            if (u->in_seg != FALSE)
            {
                // close the precednet
                undo_close_seg_in_tile_buffer(ds1_idx);
            }

            // start a new one
            undo_start_seg_in_tile_buffer(ds1_idx, x, y);
        }

        // add this cell to the segment
        fwrite(&layer_flag, sizeof(layer_flag), 1, u->fptr);
        for (i=0; i < glb_ds1[ds1_idx].floor_num; i++)
        {
            if (layer_flag & (1 << i))
            {
                fwrite(&df->f[i], sizeof(df->f[i]), 1, u->fptr);

                if (df->f[i] & DF_P1)
                    fwrite(&f[i].prop1, sizeof(f[i].prop1), 1, u->fptr);

                if (df->f[i] & DF_P2)
                    fwrite(&f[i].prop2, sizeof(f[i].prop2), 1, u->fptr);

                if (df->f[i] & DF_P3)
                    fwrite(&f[i].prop3, sizeof(f[i].prop3), 1, u->fptr);

                if (df->f[i] & DF_P4)
                    fwrite(&f[i].prop4, sizeof(f[i].prop4), 1, u->fptr);

                if (df->f[i] & DF_BT)
                    fwrite(&f[i].bt_idx, sizeof(f[i].bt_idx), 1, u->fptr);

                if (df->f[i] & DF_FL)
                    fwrite(&f[i].flags, sizeof(f[i].flags), 1, u->fptr);
            }
        }
        for (i=0; i < glb_ds1[ds1_idx].shadow_num; i++)
        {
            if (layer_flag & (1 << (i + FLOOR_MAX_LAYER) ))
            {
                fwrite(&df->s[i], sizeof(df->s[i]), 1, u->fptr);

                if (df->s[i] & DF_P1)
                    fwrite(&s[i].prop1, sizeof(s[i].prop1), 1, u->fptr);

                if (df->s[i] & DF_P2)
                    fwrite(&s[i].prop2, sizeof(s[i].prop2), 1, u->fptr);

                if (df->s[i] & DF_P3)
                    fwrite(&s[i].prop3, sizeof(s[i].prop3), 1, u->fptr);

                if (df->s[i] & DF_P4)
                    fwrite(&s[i].prop4, sizeof(s[i].prop4), 1, u->fptr);

                if (df->s[i] & DF_BT)
                    fwrite(&s[i].bt_idx, sizeof(s[i].bt_idx), 1, u->fptr);

                if (df->s[i] & DF_FL)
                    fwrite(&s[i].flags, sizeof(s[i].flags), 1, u->fptr);
            }
        }
        for (i=0; i < glb_ds1[ds1_idx].wall_num; i++)
        {
            if (layer_flag & (1 << (i + FLOOR_MAX_LAYER + SHADOW_MAX_LAYER)))
            {
                fwrite(&df->w[i], sizeof(df->w[i]), 1, u->fptr);

                if (df->w[i] & DF_P1)
                    fwrite(&w[i].prop1, sizeof(w[i].prop1), 1, u->fptr);

                if (df->w[i] & DF_P2)
                    fwrite(&w[i].prop2, sizeof(w[i].prop2), 1, u->fptr);

                if (df->w[i] & DF_P3)
                    fwrite(&w[i].prop3, sizeof(w[i].prop3), 1, u->fptr);

                if (df->w[i] & DF_P4)
                    fwrite(&w[i].prop4, sizeof(w[i].prop4), 1, u->fptr);

                if (df->w[i] & DF_OR)
                    fwrite(&w[i].orientation, sizeof(w[i].orientation), 1, u->fptr);

                if (df->w[i] & DF_BT)
                    fwrite(&w[i].bt_idx, sizeof(w[i].bt_idx), 1, u->fptr);

                if (df->w[i] & DF_FL)
                    fwrite(&w[i].flags, sizeof(w[i].flags), 1, u->fptr);
            }
        }

        // this cell was writen
        undo_reset_flags(ds1_idx);
        u->old_x++;
        u->cell_num++;
    }
}
#include "structs.h"
#include "error.h"
#include "ds1misc.h"
#include "wbits.h"
#include "misc.h"


// ==========================================================================
void wbits_main_single_tile(int ds1_idx, int tx, int ty)
{
    CELL_F_S      * f_ptr;
    CELL_W_S      * w_ptr;
    CELL_S_S      * s_ptr;
    CELL_T_S      * t_ptr;
    int           t, n;
    int           w_x0, w_y0, w_x1, w_y1;
    int           ok_x0, ok_y0, cancel_x0;
    int           c_black      = makecol(0, 0, 0),
                  c_white      = makecol(255, 255, 255),
                  c_yellow     = makecol(255, 255, 0),
                  c_darkgreen  = makecol(0, 64, 0),
                  c_lightgreen = makecol(0, 255, 0),
                  c_red        = makecol(255, 0, 0),
                  c, c1, c2, c3, mx, my, mb;
    int           b, i, val[4], x, y, save = FALSE, done = FALSE;
    UBYTE         props[6][4], dir[4], shad[4];
    UDWORD        tag_dw;
    //   char          tmp[256];
    int           w_width = 545, w_height= 270;


    text_mode(-1);

    w_x0 = (glb_config.screen.width  - w_width) / 2;
    w_y0 = (glb_config.screen.height - w_height) / 2;
    w_x1 = w_x0 + w_width;
    w_y1 = w_y0 + w_height;

    ok_x0 = w_x0 + (w_width / 2) - 64;
    ok_y0 = w_y0 + w_height - 24;
    cancel_x0 = ok_x0 + 70;

    rectfill(glb_ds1edit.screen_buff, w_x0, w_y0, w_x1, w_y1, c_black);
    rect(glb_ds1edit.screen_buff, w_x0, w_y0, w_x1, w_y1, c_white);

    if (glb_ds1[ds1_idx].floor_num >= 1)
        textout(glb_ds1edit.screen_buff, font, "F1", w_x0 + 2, w_y0 +  2, c_yellow);
    if (glb_ds1[ds1_idx].floor_num >= 2)
        textout(glb_ds1edit.screen_buff, font, "F2", w_x0 + 2, w_y0 + 12, c_yellow);

    if (glb_ds1[ds1_idx].shadow_num >= 1)
        textout(glb_ds1edit.screen_buff, font, "SH", w_x0 + 2, w_y0 + 32, c_yellow);

    if (glb_ds1[ds1_idx].wall_num >= 1)
        textout(glb_ds1edit.screen_buff, font, "W1", w_x0 + 2, w_y0 + 52, c_yellow);
    if (glb_ds1[ds1_idx].wall_num >= 2)
        textout(glb_ds1edit.screen_buff, font, "W2", w_x0 + 2, w_y0 + 62, c_yellow);
    if (glb_ds1[ds1_idx].wall_num >= 3)
        textout(glb_ds1edit.screen_buff, font, "W3", w_x0 + 2, w_y0 + 72, c_yellow);
    if (glb_ds1[ds1_idx].wall_num >= 4)
        textout(glb_ds1edit.screen_buff, font, "W4", w_x0 + 2, w_y0 + 82, c_yellow);

    if (glb_ds1[ds1_idx].tag_num >= 1)
        textout(glb_ds1edit.screen_buff, font, "SUB", w_x0 + 2, w_y0 + 200, c_yellow);

    vline(glb_ds1edit.screen_buff, w_x0 + 237, w_y0 + 92, w_y0 + 105, c_yellow);
    textout(glb_ds1edit.screen_buff, font, "Unwalkable", w_x0 + 200, w_y0 + 110, c_yellow);

    vline(glb_ds1edit.screen_buff, w_x0 + 27, w_y0 + 92, w_y0 + 105, c_yellow);
    textout(glb_ds1edit.screen_buff, font, "Hidden", w_x0 + 10, w_y0 + 110, c_yellow);

    vline(glb_ds1edit.screen_buff, w_x0 + 87, w_y0 + 92, w_y0 + 105, c_yellow);
    textout(glb_ds1edit.screen_buff, font, "?", w_x0 + 82, w_y0 + 110, c_yellow);

    vline(glb_ds1edit.screen_buff, w_x0 + 97, w_y0 + 92, w_y0 + 125, c_yellow);
    textout(glb_ds1edit.screen_buff, font, "IsShadow", w_x0 + 60, w_y0 + 130, c_yellow);

    vline(glb_ds1edit.screen_buff, w_x0 + 162, w_y0 + 92, w_y0 + 140, c_yellow);
    textout(glb_ds1edit.screen_buff, font, "Main-index", w_x0 + 130, w_y0 + 145, c_yellow);

    vline(glb_ds1edit.screen_buff, w_x0 + 333, w_y0 + 92, w_y0 + 140, c_yellow);
    textout(glb_ds1edit.screen_buff, font, "Sub-index", w_x0 + 300, w_y0 + 145, c_yellow);

    vline(glb_ds1edit.screen_buff, w_x0 + 413, w_y0 + 92, w_y0 + 100, c_yellow);
    textout(glb_ds1edit.screen_buff, font, "Layers priority,", w_x0 + 360, w_y0 + 105, c_yellow);
    textout(glb_ds1edit.screen_buff, font, "Type of layers,",  w_x0 + 360, w_y0 + 115, c_yellow);
    textout(glb_ds1edit.screen_buff, font, "   and unknown",   w_x0 + 360, w_y0 + 125, c_yellow);

    vline(glb_ds1edit.screen_buff, w_x0 + 503, w_y0 + 92, w_y0 + 140, c_yellow);
    textout(glb_ds1edit.screen_buff, font, "Orientation", w_x0 + 455, w_y0 + 145, c_yellow);

    // save props
    t     = (ty * glb_ds1[ds1_idx].floor_line) + (tx * glb_ds1[ds1_idx].floor_num);
    f_ptr = glb_ds1[ds1_idx].floor_buff + t;

    for (i=0; i < glb_ds1[ds1_idx].floor_num; i++)
    {
        props[i][0] = f_ptr[i].prop1;
        props[i][1] = f_ptr[i].prop2;
        props[i][2] = f_ptr[i].prop3;
        props[i][3] = f_ptr[i].prop4;
    }

    t     = (ty * glb_ds1[ds1_idx].wall_line) + (tx * glb_ds1[ds1_idx].wall_num);
    w_ptr = glb_ds1[ds1_idx].wall_buff + t;
    for (i=0; i < glb_ds1[ds1_idx].wall_num; i++)
    {
        props[i+2][0] = w_ptr[i].prop1;
        props[i+2][1] = w_ptr[i].prop2;
        props[i+2][2] = w_ptr[i].prop3;
        props[i+2][3] = w_ptr[i].prop4;
        dir[i]        = w_ptr[i].orientation;
    }

    t     = (ty * glb_ds1[ds1_idx].shadow_line) + (tx * glb_ds1[ds1_idx].shadow_num);
    s_ptr = glb_ds1[ds1_idx].shadow_buff + t;
    for (i=0; i < glb_ds1[ds1_idx].shadow_num; i++)
    {
        shad[0] = s_ptr[i].prop1;
        shad[1] = s_ptr[i].prop2;
        shad[2] = s_ptr[i].prop3;
        shad[3] = s_ptr[i].prop4;
    }

    t     = (ty * glb_ds1[ds1_idx].tag_line) + (tx * glb_ds1[ds1_idx].tag_num);
    t_ptr = glb_ds1[ds1_idx].tag_buff + t;
    tag_dw = t_ptr->num;

    // mouse background
    // show_mouse(NULL);
    mx = mouse_x;
    my = mouse_y;
    mb = mouse_b;

    // main loop
    while ( ! done)
    {
        text_mode(-1);

        // OK button
        c1 = c_darkgreen;
        c2 = c_lightgreen;
        c3 = c_yellow;
        if ((mx >= ok_x0) && (mx <= ok_x0 + 64) && (my >= ok_y0) && (my <= ok_y0 + 20))
        {
            c1 = c_lightgreen;
            c2 = c_white;
            c3 = c_black;
            if (mb & 1)
            {
                // OK button selected
                save = TRUE;
                done = TRUE;
                while (mouse_b & 1)
                {
                    // wait until left mouse button is not pressed anymore
                }
            }
        }
        if (key[KEY_ENTER] || key[KEY_ENTER_PAD])
        {
            save = TRUE;
            done = TRUE;
        }
        rectfill(glb_ds1edit.screen_buff, ok_x0, ok_y0-3, ok_x0 + 64, ok_y0 + 20, c1);
        rect(glb_ds1edit.screen_buff,     ok_x0, ok_y0-3, ok_x0 + 64, ok_y0 + 20, c2);
        textout(glb_ds1edit.screen_buff, font, "OK", ok_x0+25, ok_y0+5, c3);

        // CANCEL button
        c1 = c_darkgreen;
        c2 = c_lightgreen;
        c3 = c_yellow;
        if ((mx >= cancel_x0) && (mx <= cancel_x0 + 64) && (my >= ok_y0) && (my <= ok_y0 + 20))
        {
            c1 = c_lightgreen;
            c2 = c_white;
            c3 = c_black;
            if (mb & 1)
            {
                // CANCEL button selected
                save = FALSE;
                done = TRUE;
                while (mouse_b & 1)
                {
                    // wait until left mouse button is not pressed anymore
                }
            }
        }
        if (key[KEY_ESC])
        {
            save = FALSE;
            done = TRUE;
        }
        rectfill(glb_ds1edit.screen_buff, cancel_x0, ok_y0-3, cancel_x0 + 64, ok_y0 + 20, c1);
        rect(glb_ds1edit.screen_buff,     cancel_x0, ok_y0-3, cancel_x0 + 64, ok_y0 + 20, c2);
        textout(glb_ds1edit.screen_buff, font, "CANCEL", cancel_x0+10, ok_y0+5, c3);

        text_mode(0);

        // floors
        y = w_y0 + 2;
        for (n=0; n<glb_ds1[ds1_idx].floor_num; n++)
        {
            val[0] = f_ptr[n].prop1;
            val[1] = f_ptr[n].prop2;
            val[2] = f_ptr[n].prop3;
            val[3] = f_ptr[n].prop4;
            x = w_x0 + 24;
            for (b=3; b >= 0 ; b--)
            {
                for (i=7; i >= 0; i--)
                {
                    c = c_white;
                    if ( (mx >= x) && (mx <= x+9) &&
                            (my >= y) && (my <= y+9) )
                    {
                        c  = c_red;
                        if (mb & 1)
                        {
                            if (val[b] & (1 << i))
                            {
                                // change to 0
                                val[b] = val[b] - (1 << i);
                            }
                            else
                            {
                                // change to 1
                                val[b] = val[b] + (1 << i);
                            }
                            while (mb & 1)
                            {
                                // wait until no mouse button pressed
                                mb = mouse_b;
                            }
                            switch(b)
                            {
                                case 0 : f_ptr[n].prop1 = val[b]; break;
                                case 1 : f_ptr[n].prop2 = val[b]; break;
                                case 2 : f_ptr[n].prop3 = val[b]; break;
                                case 3 : f_ptr[n].prop4 = val[b]; break;
                            }
                        }
                    }
                    if (val[b] & (1 << i))
                        textout(glb_ds1edit.screen_buff, font, "1", x, y, c);
                    else
                        textout(glb_ds1edit.screen_buff, font, "0", x, y, c);
                    x += 10;

                    if ((b==3) && ((i==7) || (i==6) || (i==5) || (i==3) || (i==2)))
                        x+=10;
                    else if ((b==2) && ((i==4) || (i==2) || (i==1) || (i==0)))
                        x+=10;
                    else if ((b==1) && ((i==6) || (i==0)))
                        x+=10;
                }
            }
            y += 10;
        }

        // shadow layer
        y += 10 * (2 - glb_ds1[ds1_idx].floor_num);
        y += 10;
        for (n=0; n<glb_ds1[ds1_idx].shadow_num; n++)
        {
            shad[0] = s_ptr[n].prop1;
            shad[1] = s_ptr[n].prop2;
            shad[2] = s_ptr[n].prop3;
            shad[3] = s_ptr[n].prop4;
            x = w_x0 + 24;
            for (b=3; b >= 0 ; b--)
            {
                for (i=7; i >= 0; i--)
                {
                    c = c_white;
                    if ( (mx >= x) && (mx <= x+9) &&
                            (my >= y) && (my <= y+9) )
                    {
                        c  = c_red;
                        if (mb & 1)
                        {
                            if (shad[b] & (1 << i))
                            {
                                // change to 0
                                shad[b] = shad[b] - (1 << i);
                            }
                            else
                            {
                                // change to 1
                                shad[b] = shad[b] + (1 << i);
                            }
                            while (mb & 1)
                            {
                                // wait until no mouse button pressed
                                mb = mouse_b;
                            }
                            switch(b)
                            {
                                case 0 : s_ptr[n].prop1 = shad[b]; break;
                                case 1 : s_ptr[n].prop2 = shad[b]; break;
                                case 2 : s_ptr[n].prop3 = shad[b]; break;
                                case 3 : s_ptr[n].prop4 = shad[b]; break;
                            }
                        }
                    }
                    if (shad[b] & (1 << i))
                        textout(glb_ds1edit.screen_buff, font, "1", x, y, c);
                    else
                        textout(glb_ds1edit.screen_buff, font, "0", x, y, c);
                    x += 10;

                    if ((b==3) && ((i==7) || (i==6) || (i==5) || (i==3) || (i==2)))
                        x+=10;
                    else if ((b==2) && ((i==4) || (i==2) || (i==1) || (i==0)))
                        x+=10;
                    else if ((b==1) && ((i==6) || (i==0)))
                        x+=10;
                }
            }
            y += 10;
        }

        // walls
        y += 10;
        for (n=0; n<glb_ds1[ds1_idx].wall_num; n++)
        {
            val[0] = w_ptr[n].prop1;
            val[1] = w_ptr[n].prop2;
            val[2] = w_ptr[n].prop3;
            val[3] = w_ptr[n].prop4;
            x = w_x0 + 24;

            // props
            for (b=3; b >= 0 ; b--)
            {
                for (i=7; i >= 0; i--)
                {
                    c = c_white;
                    if ( (mx >= x) && (mx <= x+9) &&
                            (my >= y) && (my <= y+9) )
                    {
                        c  = c_red;
                        if (mb & 1)
                        {
                            if (val[b] & (1 << i))
                            {
                                // change to 0
                                val[b] = val[b] - (1 << i);
                            }
                            else
                            {
                                // change to 1
                                val[b] = val[b] + (1 << i);
                            }
                            while (mb & 1)
                            {
                                // wait until no mouse button pressed
                                mb = mouse_b;
                            }
                            switch(b)
                            {
                                case 0 : w_ptr[n].prop1 = val[b]; break;
                                case 1 : w_ptr[n].prop2 = val[b]; break;
                                case 2 : w_ptr[n].prop3 = val[b]; break;
                                case 3 : w_ptr[n].prop4 = val[b]; break;
                            }
                        }
                    }
                    if (val[b] & (1 << i))
                        textout(glb_ds1edit.screen_buff, font, "1", x, y, c);
                    else
                        textout(glb_ds1edit.screen_buff, font, "0", x, y, c);
                    x += 10;

                    if ((b==3) && ((i==7) || (i==6) || (i==5) || (i==3) || (i==2)))
                        x+=10;
                    else if ((b==2) && ((i==4) || (i==2) || (i==1) || (i==0)))
                        x+=10;
                    else if ((b==1) && ((i==6) || (i==0)))
                        x+=10;
                    else if ((b==0) && (i==0))
                        x+=10;
                }
            }

            // orientation
            for (i=7; i >= 0; i--)
            {
                c = c_white;
                if ( (mx >= x) && (mx <= x+9) &&
                        (my >= y) && (my <= y+9) )
                {
                    c  = c_red;
                    if (mb & 1)
                    {
                        if (w_ptr[n].orientation & (1 << i))
                        {
                            // change to 0
                            w_ptr[n].orientation = w_ptr[n].orientation - (1 << i);
                        }
                        else
                        {
                            // change to 1
                            w_ptr[n].orientation = w_ptr[n].orientation + (1 << i);
                        }
                        while (mb & 1)
                        {
                            // wait until no mouse button pressed
                            mb = mouse_b;
                        }
                    }
                }
                if (w_ptr[n].orientation & (1 << i))
                    textout(glb_ds1edit.screen_buff, font, "1", x, y, c);
                else
                    textout(glb_ds1edit.screen_buff, font, "0", x, y, c);
                x += 10;
            }

            y += 10;
        }

        // substitution layer
        y += 10 * (4 - glb_ds1[ds1_idx].wall_num);
        y += 108;
        for (n=0; n<glb_ds1[ds1_idx].tag_num; n++)
        {
            tag_dw = t_ptr->num;
            x = w_x0 + 34;
            for (i=31; i >= 0; i--)
            {
                c = c_white;
                if ( (mx >= x) && (mx <= x+9) &&
                        (my >= y) && (my <= y+9) )
                {
                    c  = c_red;
                    if (mb & 1)
                    {
                        if (tag_dw & (1 << i))
                        {
                            // change to 0
                            tag_dw = tag_dw - (1 << i);
                        }
                        else
                        {
                            // change to 1
                            tag_dw = tag_dw + (1 << i);
                        }
                        while (mb & 1)
                        {
                            // wait until no mouse button pressed
                            mb = mouse_b;
                        }
                        t_ptr->num = tag_dw;
                    }
                }
                if (tag_dw & (1 << i))
                    textout(glb_ds1edit.screen_buff, font, "1", x, y, c);
                else
                    textout(glb_ds1edit.screen_buff, font, "0", x, y, c);
                x += 10;

                if ((i==8) || (i==16) || (i==24))
                    x+=10;
            }
            y += 10;
            x = w_x0 + 48;
            textprintf(glb_ds1edit.screen_buff, font, x,       y, c_lightgreen, "%8lu", (tag_dw & 0xFF000000LU) >> 24);
            textprintf(glb_ds1edit.screen_buff, font, x + 90,  y, c_lightgreen, "%8lu", (tag_dw & 0x00FF0000LU) >> 16);
            textprintf(glb_ds1edit.screen_buff, font, x + 180, y, c_lightgreen, "%8lu", (tag_dw & 0x0000FF00LU) >> 8);
            textprintf(glb_ds1edit.screen_buff, font, x + 270, y, c_lightgreen, "%8lu",  tag_dw & 0x000000FFLU);
        }

        misc_draw_screen(mx, my);

        // new mouse state
        mx = mouse_x;
        my = mouse_y;
        mb = mouse_b;
    }

    if (save == FALSE)
    {
        // restore original props
        for (i=0; i < glb_ds1[ds1_idx].floor_num; i++)
        {
            f_ptr[i].prop1 = props[i][0];
            f_ptr[i].prop2 = props[i][1];
            f_ptr[i].prop3 = props[i][2];
            f_ptr[i].prop4 = props[i][3];
        }
        for (i=0; i < glb_ds1[ds1_idx].wall_num; i++)
        {
            w_ptr[i].prop1 = props[i+2][0];
            w_ptr[i].prop2 = props[i+2][1];
            w_ptr[i].prop3 = props[i+2][2];
            w_ptr[i].prop4 = props[i+2][3];
            w_ptr[i].orientation = dir[i];
        }
        for (i=0; i < glb_ds1[ds1_idx].shadow_num; i++)
        {
            s_ptr[i].prop1 = shad[0];
            s_ptr[i].prop2 = shad[1];
            s_ptr[i].prop3 = shad[2];
            s_ptr[i].prop4 = shad[3];
        }
        t_ptr->num = tag_dw;
    }
    else
    {
        // find again all tiles
        ds1_make_prop_2_block(ds1_idx);
    }

    if (key[KEY_ESC])
    {
        while (key[KEY_ESC])
        {
            // wait until Escape is released
        }
    }
    if (key[KEY_ENTER] || key[KEY_ENTER_PAD])
    {
        while (key[KEY_ENTER] || key[KEY_ENTER_PAD])
        {
            // wait until Enter is released
        }
    }

    // end
    text_mode(-1);
}


// ====================================================================================
void wbits_apply_modification(int ds1_idx, WBITSDATA_S * ptr_wbitsdata)
{
    CELL_F_S    * f_ptr;
    CELL_W_S    * w_ptr;
    CELL_S_S    * s_ptr;
    CELL_T_S    * t_ptr;
    int         x, y, t, i, b;
    UDWORD      bt, b1, b2;


    for (y=0; y < glb_ds1[ds1_idx].height; y++)
    {
        for (x=0; x < glb_ds1[ds1_idx].width; x++)
        {
            // floors
            t = (y * glb_ds1[ds1_idx].floor_line) + (x * glb_ds1[ds1_idx].floor_num);
            for (i=0; i < glb_ds1[ds1_idx].floor_num; i++)
            {
                f_ptr = glb_ds1[ds1_idx].floor_buff + t + i;
                if (IS_SELECTED(f_ptr->flags))
                {
                    // set the new bits, if needeed

                    // prop1
                    for (b=0; b < 8; b++)
                    {
                        bt = ptr_wbitsdata->bit_type_f[i][0][b];
                        if (bt == WBITSTYPE_SAME)
                        {
                            b1 = ptr_wbitsdata->mix_f[i].prop1 & (1 << b);
                            b2 = f_ptr->prop1 & (1 << b);
                            if (b1 != b2)
                            {
                                if (b1)
                                    f_ptr->prop1 |= (1 << b); // set the bit
                                else
                                    f_ptr->prop1 &= ~(1 << b); // remove the bit
                            }
                        }
                    }

                    // prop2
                    for (b=0; b < 8; b++)
                    {
                        bt = ptr_wbitsdata->bit_type_f[i][1][b];
                        if (bt == WBITSTYPE_SAME)
                        {
                            b1 = ptr_wbitsdata->mix_f[i].prop2 & (1 << b);
                            b2 = f_ptr->prop2 & (1 << b);
                            if (b1 != b2)
                            {
                                if (b1)
                                    f_ptr->prop2 |= (1 << b); // set the bit
                                else
                                    f_ptr->prop2 &= ~(1 << b); // remove the bit
                            }
                        }
                    }

                    // prop3
                    for (b=0; b < 8; b++)
                    {
                        bt = ptr_wbitsdata->bit_type_f[i][2][b];
                        if (bt == WBITSTYPE_SAME)
                        {
                            b1 = ptr_wbitsdata->mix_f[i].prop3 & (1 << b);
                            b2 = f_ptr->prop3 & (1 << b);
                            if (b1 != b2)
                            {
                                if (b1)
                                    f_ptr->prop3 |= (1 << b); // set the bit
                                else
                                    f_ptr->prop3 &= ~(1 << b); // remove the bit
                            }
                        }
                    }

                    // prop4
                    for (b=0; b < 8; b++)
                    {
                        bt = ptr_wbitsdata->bit_type_f[i][3][b];
                        if ((bt == WBITSTYPE_SAME))
                        {
                            b1 = ptr_wbitsdata->mix_f[i].prop4 & (1 << b);
                            b2 = f_ptr->prop4 & (1 << b);
                            if (b1 != b2)
                            {
                                if (b1)
                                    f_ptr->prop4 |= (1 << b); // set the bit
                                else
                                    f_ptr->prop4 &= ~(1 << b); // remove the bit
                            }
                        }
                    }
                }
            }

            // shadows
            t = (y * glb_ds1[ds1_idx].shadow_line) + (x * glb_ds1[ds1_idx].shadow_num);
            for (i=0; i < glb_ds1[ds1_idx].shadow_num; i++)
            {
                s_ptr = glb_ds1[ds1_idx].shadow_buff + t + i;
                if (IS_SELECTED(s_ptr->flags))
                {
                    // set the new bits, if needeed

                    // prop1
                    for (b=0; b < 8; b++)
                    {
                        bt = ptr_wbitsdata->bit_type_s[i][0][b];
                        if (bt == WBITSTYPE_SAME)
                        {
                            b1 = ptr_wbitsdata->mix_s[i].prop1 & (1 << b);
                            b2 = s_ptr->prop1 & (1 << b);
                            if (b1 != b2)
                            {
                                if (b1)
                                    s_ptr->prop1 |= (1 << b); // set the bit
                                else
                                    s_ptr->prop1 &= ~(1 << b); // remove the bit
                            }
                        }
                    }

                    // prop2
                    for (b=0; b < 8; b++)
                    {
                        bt = ptr_wbitsdata->bit_type_s[i][1][b];
                        if (bt == WBITSTYPE_SAME)
                        {
                            b1 = ptr_wbitsdata->mix_s[i].prop2 & (1 << b);
                            b2 = s_ptr->prop2 & (1 << b);
                            if (b1 != b2)
                            {
                                if (b1)
                                    s_ptr->prop2 |= (1 << b); // set the bit
                                else
                                    s_ptr->prop2 &= ~(1 << b); // remove the bit
                            }
                        }
                    }

                    // prop3
                    for (b=0; b < 8; b++)
                    {
                        bt = ptr_wbitsdata->bit_type_s[i][2][b];
                        if (bt == WBITSTYPE_SAME)
                        {
                            b1 = ptr_wbitsdata->mix_s[i].prop3 & (1 << b);
                            b2 = s_ptr->prop3 & (1 << b);
                            if (b1 != b2)
                            {
                                if (b1)
                                    s_ptr->prop3 |= (1 << b); // set the bit
                                else
                                    s_ptr->prop3 &= ~(1 << b); // remove the bit
                            }
                        }
                    }

                    // prop4
                    for (b=0; b < 8; b++)
                    {
                        bt = ptr_wbitsdata->bit_type_s[i][3][b];
                        if (bt == WBITSTYPE_SAME)
                        {
                            b1 = ptr_wbitsdata->mix_s[i].prop4 & (1 << b);
                            b2 = s_ptr->prop4 & (1 << b);
                            if (b1 != b2)
                            {
                                if (b1)
                                    s_ptr->prop4 |= (1 << b); // set the bit
                                else
                                    s_ptr->prop4 &= ~(1 << b); // remove the bit
                            }
                        }
                    }
                }
            }

            // walls
            t = (y * glb_ds1[ds1_idx].wall_line) + (x * glb_ds1[ds1_idx].wall_num);
            for (i=0; i < glb_ds1[ds1_idx].wall_num; i++)
            {
                w_ptr = glb_ds1[ds1_idx].wall_buff + t + i;
                if (IS_SELECTED(w_ptr->flags))
                {
                    // set the new bits, if needeed

                    // prop1
                    for (b=0; b < 8; b++)
                    {
                        bt = ptr_wbitsdata->bit_type_w[i][0][b];
                        if (bt == WBITSTYPE_SAME)
                        {
                            b1 = ptr_wbitsdata->mix_w[i].prop1 & (1 << b);
                            b2 = w_ptr->prop1 & (1 << b);
                            if (b1 != b2)
                            {
                                if (b1)
                                    w_ptr->prop1 |= (1 << b); // set the bit
                                else
                                    w_ptr->prop1 &= ~(1 << b); // remove the bit
                            }
                        }
                    }

                    // prop2
                    for (b=0; b < 8; b++)
                    {
                        bt = ptr_wbitsdata->bit_type_w[i][1][b];
                        if (bt == WBITSTYPE_SAME)
                        {
                            b1 = ptr_wbitsdata->mix_w[i].prop2 & (1 << b);
                            b2 = w_ptr->prop2 & (1 << b);
                            if (b1 != b2)
                            {
                                if (b1)
                                    w_ptr->prop2 |= (1 << b); // set the bit
                                else
                                    w_ptr->prop2 &= ~(1 << b); // remove the bit
                            }
                        }
                    }

                    // prop3
                    for (b=0; b < 8; b++)
                    {
                        bt = ptr_wbitsdata->bit_type_w[i][2][b];
                        if (bt == WBITSTYPE_SAME)
                        {
                            b1 = ptr_wbitsdata->mix_w[i].prop3 & (1 << b);
                            b2 = w_ptr->prop3 & (1 << b);
                            if (b1 != b2)
                            {
                                if (b1)
                                    w_ptr->prop3 |= (1 << b); // set the bit
                                else
                                    w_ptr->prop3 &= ~(1 << b); // remove the bit
                            }
                        }
                    }

                    // prop4
                    for (b=0; b < 8; b++)
                    {
                        bt = ptr_wbitsdata->bit_type_w[i][3][b];
                        if (bt == WBITSTYPE_SAME)
                        {
                            b1 = ptr_wbitsdata->mix_w[i].prop4 & (1 << b);
                            b2 = w_ptr->prop4 & (1 << b);
                            if (b1 != b2)
                            {
                                if (b1)
                                    w_ptr->prop4 |= (1 << b); // set the bit
                                else
                                    w_ptr->prop4 &= ~(1 << b); // remove the bit
                            }
                        }
                    }

                    // orientation
                    for (b=0; b < 8; b++)
                    {
                        bt = ptr_wbitsdata->bit_type_w[i][4][b];
                        if (bt == WBITSTYPE_SAME)
                        {
                            b1 = ptr_wbitsdata->mix_w[i].orientation & (1 << b);
                            b2 = w_ptr->orientation & (1 << b);
                            if (b1 != b2)
                            {
                                if (b1)
                                    w_ptr->orientation |= (1 << b); // set the bit
                                else
                                    w_ptr->orientation &= ~(1 << b); // remove the bit
                            }
                        }
                    }
                }
            }

            // tags
            t = (y * glb_ds1[ds1_idx].tag_line) + (x * glb_ds1[ds1_idx].tag_num);
            for (i=0; i < glb_ds1[ds1_idx].tag_num; i++)
            {
                t_ptr = glb_ds1[ds1_idx].tag_buff + t + i;
                if (IS_SELECTED(t_ptr->flags))
                {
                    // set the new bits, if needeed

                    // tag num
                    for (b=0; b < 32; b++)
                    {
                        bt = ptr_wbitsdata->bit_type_t[i][b];
                        if (bt == WBITSTYPE_SAME)
                        {
                            b1 = ptr_wbitsdata->mix_t[i].num & (1 << b);
                            b2 = t_ptr->num & (1 << b);
                            if (b1 != b2)
                            {
                                if (b1)
                                    t_ptr->num |= (1 << b); // set the bit
                                else
                                    t_ptr->num &= ~(1 << b); // remove the bit
                            }
                        }
                    }

                }
            }
        }
    }
}


// ==========================================================================
void wbits_main_multiple_tiles(int ds1_idx, WBITSDATA_S * ptr_wbitsdata)
{
    int           w_x0, w_y0, w_x1, w_y1;
    int           ok_x0, ok_y0, cancel_x0;
    int           c_black      = makecol(0, 0, 0),
                  c_white      = makecol(255, 255, 255),
                  c_yellow     = makecol(255, 255, 0),
                  c_darkgreen  = makecol(0, 64, 0),
                  c_lightgreen = makecol(0, 255, 0),
                  c_red        = makecol(255, 0, 0),
                  c_unkn       = makecol(52, 156, 28),
                  c_blue       = makecol(36, 96, 216),
                  c1, c2, c3, mx, my, mb;
    UDWORD        tag_dw;
    //   char          tmp[256];
    int           w_width = 545, w_height= 270;
    int           save = FALSE, done = FALSE;
    int           x, y, i, b, c, n, val[4];
    UBYTE         shad[4];


    text_mode(-1);

    w_x0 = (glb_config.screen.width  - w_width) / 2;
    w_y0 = (glb_config.screen.height - w_height) / 2;
    w_x1 = w_x0 + w_width;
    w_y1 = w_y0 + w_height;

    ok_x0 = w_x0 + (w_width / 2) - 64;
    ok_y0 = w_y0 + w_height - 24;
    cancel_x0 = ok_x0 + 70;

    rectfill(glb_ds1edit.screen_buff, w_x0, w_y0, w_x1, w_y1, c_black);
    rect(glb_ds1edit.screen_buff, w_x0, w_y0, w_x1, w_y1, c_white);

    if (glb_ds1[ds1_idx].floor_num >= 1)
        textout(glb_ds1edit.screen_buff, font, "F1", w_x0 + 2, w_y0 +  2, c_yellow);
    if (glb_ds1[ds1_idx].floor_num >= 2)
        textout(glb_ds1edit.screen_buff, font, "F2", w_x0 + 2, w_y0 + 12, c_yellow);

    if (glb_ds1[ds1_idx].shadow_num >= 1)
        textout(glb_ds1edit.screen_buff, font, "SH", w_x0 + 2, w_y0 + 32, c_yellow);

    if (glb_ds1[ds1_idx].wall_num >= 1)
        textout(glb_ds1edit.screen_buff, font, "W1", w_x0 + 2, w_y0 + 52, c_yellow);
    if (glb_ds1[ds1_idx].wall_num >= 2)
        textout(glb_ds1edit.screen_buff, font, "W2", w_x0 + 2, w_y0 + 62, c_yellow);
    if (glb_ds1[ds1_idx].wall_num >= 3)
        textout(glb_ds1edit.screen_buff, font, "W3", w_x0 + 2, w_y0 + 72, c_yellow);
    if (glb_ds1[ds1_idx].wall_num >= 4)
        textout(glb_ds1edit.screen_buff, font, "W4", w_x0 + 2, w_y0 + 82, c_yellow);

    if (glb_ds1[ds1_idx].tag_num >= 1)
        textout(glb_ds1edit.screen_buff, font, "SUB", w_x0 + 2, w_y0 + 200, c_yellow);

    vline(glb_ds1edit.screen_buff, w_x0 + 237, w_y0 + 92, w_y0 + 105, c_yellow);
    textout(glb_ds1edit.screen_buff, font, "Unwalkable", w_x0 + 200, w_y0 + 110, c_yellow);

    vline(glb_ds1edit.screen_buff, w_x0 + 27, w_y0 + 92, w_y0 + 105, c_yellow);
    textout(glb_ds1edit.screen_buff, font, "Hidden", w_x0 + 10, w_y0 + 110, c_yellow);

    vline(glb_ds1edit.screen_buff, w_x0 + 87, w_y0 + 92, w_y0 + 105, c_yellow);
    textout(glb_ds1edit.screen_buff, font, "?", w_x0 + 82, w_y0 + 110, c_yellow);

    vline(glb_ds1edit.screen_buff, w_x0 + 97, w_y0 + 92, w_y0 + 125, c_yellow);
    textout(glb_ds1edit.screen_buff, font, "IsShadow", w_x0 + 60, w_y0 + 130, c_yellow);

    vline(glb_ds1edit.screen_buff, w_x0 + 162, w_y0 + 92, w_y0 + 140, c_yellow);
    textout(glb_ds1edit.screen_buff, font, "Main-index", w_x0 + 130, w_y0 + 145, c_yellow);

    vline(glb_ds1edit.screen_buff, w_x0 + 333, w_y0 + 92, w_y0 + 140, c_yellow);
    textout(glb_ds1edit.screen_buff, font, "Sub-index", w_x0 + 300, w_y0 + 145, c_yellow);

    vline(glb_ds1edit.screen_buff, w_x0 + 413, w_y0 + 92, w_y0 + 100, c_yellow);
    textout(glb_ds1edit.screen_buff, font, "Layers priority,", w_x0 + 360, w_y0 + 105, c_yellow);
    textout(glb_ds1edit.screen_buff, font, "Type of layers,",  w_x0 + 360, w_y0 + 115, c_yellow);
    textout(glb_ds1edit.screen_buff, font, "   and unknown",   w_x0 + 360, w_y0 + 125, c_yellow);

    vline(glb_ds1edit.screen_buff, w_x0 + 503, w_y0 + 92, w_y0 + 140, c_yellow);
    textout(glb_ds1edit.screen_buff, font, "Orientation", w_x0 + 455, w_y0 + 145, c_yellow);

    // mouse background
    // show_mouse(NULL);
    mx = mouse_x;
    my = mouse_y;
    mb = mouse_b;

    // main loop
    while ( ! done)
    {
        text_mode(-1);

        // OK button
        c1 = c_darkgreen;
        c2 = c_lightgreen;
        c3 = c_yellow;
        if ((mx >= ok_x0) && (mx <= ok_x0 + 64) && (my >= ok_y0) && (my <= ok_y0 + 20))
        {
            c1 = c_lightgreen;
            c2 = c_white;
            c3 = c_black;
            if (mb & 1)
            {
                // OK button selected
                save = TRUE;
                done = TRUE;
                while (mouse_b & 1)
                {
                    // wait until left mouse button is not pressed anymore
                }
            }
        }
        if (key[KEY_ENTER] || key[KEY_ENTER_PAD])
        {
            save = TRUE;
            done = TRUE;
        }
        rectfill(glb_ds1edit.screen_buff, ok_x0, ok_y0-3, ok_x0 + 64, ok_y0 + 20, c1);
        rect(glb_ds1edit.screen_buff,     ok_x0, ok_y0-3, ok_x0 + 64, ok_y0 + 20, c2);
        textout(glb_ds1edit.screen_buff, font, "OK", ok_x0+25, ok_y0+5, c3);

        // CANCEL button
        c1 = c_darkgreen;
        c2 = c_lightgreen;
        c3 = c_yellow;
        if ((mx >= cancel_x0) && (mx <= cancel_x0 + 64) && (my >= ok_y0) && (my <= ok_y0 + 20))
        {
            c1 = c_lightgreen;
            c2 = c_white;
            c3 = c_black;
            if (mb & 1)
            {
                // CANCEL button selected
                save = FALSE;
                done = TRUE;
                while (mouse_b & 1)
                {
                    // wait until left mouse button is not pressed anymore
                }
            }
        }
        if (key[KEY_ESC])
        {
            save = FALSE;
            done = TRUE;
        }
        rectfill(glb_ds1edit.screen_buff, cancel_x0, ok_y0-3, cancel_x0 + 64, ok_y0 + 20, c1);
        rect(glb_ds1edit.screen_buff,     cancel_x0, ok_y0-3, cancel_x0 + 64, ok_y0 + 20, c2);
        textout(glb_ds1edit.screen_buff, font, "CANCEL", cancel_x0+10, ok_y0+5, c3);

        text_mode(0);

        // floors
        y = w_y0 + 2;
        for (n=0; n < glb_ds1[ds1_idx].floor_num; n++)
        {
            val[0] = ptr_wbitsdata->mix_f[n].prop1;
            val[1] = ptr_wbitsdata->mix_f[n].prop2;
            val[2] = ptr_wbitsdata->mix_f[n].prop3;
            val[3] = ptr_wbitsdata->mix_f[n].prop4;
            x = w_x0 + 24;
            for (b=3; b >= 0 ; b--)
            {
                for (i=7; i >= 0; i--)
                {
                    if (ptr_wbitsdata->bit_type_f[n][b][i] == WBITSTYPE_DIFFERENT)
                        c = c_blue;
                    else if (ptr_wbitsdata->bit_type_f[n][b][i] == WBITSTYPE_UNKNOWN)
                        c = c_unkn;
                    else
                        c = c_white;

                    if ((mx >= x) && (mx <= x+9) && (my >= y) && (my <= y+9) &&
                            (ptr_wbitsdata->bit_type_f[n][b][i] != WBITSTYPE_UNKNOWN))
                    {
                        c  = c_red;
                        if (mb & 1)
                        {
                            if (val[b] & (1 << i))
                            {
                                // change to 0
                                val[b] = val[b] - (1 << i);
                            }
                            else
                            {
                                // change to 1
                                val[b] = val[b] + (1 << i);
                            }
                            while (mb & 1)
                            {
                                // wait until no mouse left button pressed
                                mb = mouse_b;
                            }
                            switch(b)
                            {
                                case 0 : ptr_wbitsdata->mix_f[n].prop1 = val[0]; break;
                                case 1 : ptr_wbitsdata->mix_f[n].prop2 = val[1]; break;
                                case 2 : ptr_wbitsdata->mix_f[n].prop3 = val[2]; break;
                                case 3 : ptr_wbitsdata->mix_f[n].prop4 = val[3]; break;
                            }
                            if (ptr_wbitsdata->bit_type_f[n][b][i] == WBITSTYPE_DIFFERENT)
                                ptr_wbitsdata->bit_type_f[n][b][i] = WBITSTYPE_SAME;
                        }
                    }
                    if (ptr_wbitsdata->bit_type_f[n][b][i] == WBITSTYPE_UNKNOWN)
                    {
                        textout(glb_ds1edit.screen_buff, font, "-", x, y, c);
                    }
                    else
                    {
                        if (val[b] & (1 << i))
                            textout(glb_ds1edit.screen_buff, font, "1", x, y, c);
                        else
                            textout(glb_ds1edit.screen_buff, font, "0", x, y, c);
                    }

                    x += 10;
                    if ((b==3) && ((i==7) || (i==6) || (i==5) || (i==3) || (i==2)))
                        x+=10;
                    else if ((b==2) && ((i==4) || (i==2) || (i==1) || (i==0)))
                        x+=10;
                    else if ((b==1) && ((i==6) || (i==0)))
                        x+=10;
                }
            }
            y += 10;
        }

        // shadow layer
        y += 10 * (2 - glb_ds1[ds1_idx].floor_num);
        y += 10;
        for (n=0; n<glb_ds1[ds1_idx].shadow_num; n++)
        {
            shad[0] = ptr_wbitsdata->mix_s[n].prop1;
            shad[1] = ptr_wbitsdata->mix_s[n].prop2;
            shad[2] = ptr_wbitsdata->mix_s[n].prop3;
            shad[3] = ptr_wbitsdata->mix_s[n].prop4;
            x = w_x0 + 24;
            for (b=3; b >= 0 ; b--)
            {
                for (i=7; i >= 0; i--)
                {
                    if (ptr_wbitsdata->bit_type_s[n][b][i] == WBITSTYPE_DIFFERENT)
                        c = c_blue;
                    else if (ptr_wbitsdata->bit_type_s[n][b][i] == WBITSTYPE_UNKNOWN)
                        c = c_unkn;
                    else
                        c = c_white;

                    if ((mx >= x) && (mx <= x+9) && (my >= y) && (my <= y+9) &&
                            (ptr_wbitsdata->bit_type_s[n][b][i] != WBITSTYPE_UNKNOWN))
                    {
                        c  = c_red;
                        if (mb & 1)
                        {
                            if (shad[b] & (1 << i))
                            {
                                // change to 0
                                shad[b] = shad[b] - (1 << i);
                            }
                            else
                            {
                                // change to 1
                                shad[b] = shad[b] + (1 << i);
                            }
                            while (mb & 1)
                            {
                                // wait until no mouse button pressed
                                mb = mouse_b;
                            }
                            switch(b)
                            {
                                case 0 : ptr_wbitsdata->mix_s[n].prop1 = shad[0]; break;
                                case 1 : ptr_wbitsdata->mix_s[n].prop2 = shad[1]; break;
                                case 2 : ptr_wbitsdata->mix_s[n].prop3 = shad[2]; break;
                                case 3 : ptr_wbitsdata->mix_s[n].prop4 = shad[3]; break;
                            }
                            if (ptr_wbitsdata->bit_type_s[n][b][i] == WBITSTYPE_DIFFERENT)
                                ptr_wbitsdata->bit_type_s[n][b][i] = WBITSTYPE_SAME;
                        }
                    }
                    if (ptr_wbitsdata->bit_type_s[n][b][i] == WBITSTYPE_UNKNOWN)
                    {
                        textout(glb_ds1edit.screen_buff, font, "-", x, y, c);
                    }
                    else
                    {
                        if (shad[b] & (1 << i))
                            textout(glb_ds1edit.screen_buff, font, "1", x, y, c);
                        else
                            textout(glb_ds1edit.screen_buff, font, "0", x, y, c);
                    }

                    x += 10;
                    if ((b==3) && ((i==7) || (i==6) || (i==5) || (i==3) || (i==2)))
                        x+=10;
                    else if ((b==2) && ((i==4) || (i==2) || (i==1) || (i==0)))
                        x+=10;
                    else if ((b==1) && ((i==6) || (i==0)))
                        x+=10;
                }
            }
            y += 10;
        }

        // walls
        y += 10;
        for (n=0; n<glb_ds1[ds1_idx].wall_num; n++)
        {
            val[0] = ptr_wbitsdata->mix_w[n].prop1;
            val[1] = ptr_wbitsdata->mix_w[n].prop2;
            val[2] = ptr_wbitsdata->mix_w[n].prop3;
            val[3] = ptr_wbitsdata->mix_w[n].prop4;
            x = w_x0 + 24;

            // props
            for (b=3; b >= 0 ; b--)
            {
                for (i=7; i >= 0; i--)
                {
                    if (ptr_wbitsdata->bit_type_w[n][b][i] == WBITSTYPE_DIFFERENT)
                        c = c_blue;
                    else if (ptr_wbitsdata->bit_type_w[n][b][i] == WBITSTYPE_UNKNOWN)
                        c = c_unkn;
                    else
                        c = c_white;

                    if ((mx >= x) && (mx <= x+9) && (my >= y) && (my <= y+9) &&
                            (ptr_wbitsdata->bit_type_w[n][b][i] != WBITSTYPE_UNKNOWN))
                    {
                        c  = c_red;
                        if (mb & 1)
                        {
                            if (val[b] & (1 << i))
                            {
                                // change to 0
                                val[b] = val[b] - (1 << i);
                            }
                            else
                            {
                                // change to 1
                                val[b] = val[b] + (1 << i);
                            }
                            while (mb & 1)
                            {
                                // wait until no mouse button pressed
                                mb = mouse_b;
                            }
                            switch(b)
                            {
                                case 0 : ptr_wbitsdata->mix_w[n].prop1 = val[0]; break;
                                case 1 : ptr_wbitsdata->mix_w[n].prop2 = val[1]; break;
                                case 2 : ptr_wbitsdata->mix_w[n].prop3 = val[2]; break;
                                case 3 : ptr_wbitsdata->mix_w[n].prop4 = val[3]; break;
                            }
                            if (ptr_wbitsdata->bit_type_w[n][b][i] == WBITSTYPE_DIFFERENT)
                                ptr_wbitsdata->bit_type_w[n][b][i] = WBITSTYPE_SAME;
                        }
                    }
                    if (ptr_wbitsdata->bit_type_w[n][b][i] == WBITSTYPE_UNKNOWN)
                    {
                        textout(glb_ds1edit.screen_buff, font, "-", x, y, c);
                    }
                    else
                    {
                        if (val[b] & (1 << i))
                            textout(glb_ds1edit.screen_buff, font, "1", x, y, c);
                        else
                            textout(glb_ds1edit.screen_buff, font, "0", x, y, c);
                    }

                    x += 10;
                    if ((b==3) && ((i==7) || (i==6) || (i==5) || (i==3) || (i==2)))
                        x+=10;
                    else if ((b==2) && ((i==4) || (i==2) || (i==1) || (i==0)))
                        x+=10;
                    else if ((b==1) && ((i==6) || (i==0)))
                        x+=10;
                    else if ((b==0) && (i==0))
                        x+=10;
                }
            }

            // orientation
            for (i=7; i >= 0; i--)
            {
                if (ptr_wbitsdata->bit_type_w[n][4][i] == WBITSTYPE_DIFFERENT)
                    c = c_blue;
                else if (ptr_wbitsdata->bit_type_w[n][4][i] == WBITSTYPE_UNKNOWN)
                    c = c_unkn;
                else
                    c = c_white;

                if ((mx >= x) && (mx <= x+9) && (my >= y) && (my <= y+9) &&
                        (ptr_wbitsdata->bit_type_w[n][4][i] != WBITSTYPE_UNKNOWN))
                {
                    c  = c_red;
                    if (mb & 1)
                    {
                        if (ptr_wbitsdata->mix_w[n].orientation & (1 << i))
                        {
                            // change to 0
                            ptr_wbitsdata->mix_w[n].orientation =
                                ptr_wbitsdata->mix_w[n].orientation - (1 << i);
                        }
                        else
                        {
                            // change to 1
                            ptr_wbitsdata->mix_w[n].orientation =
                                ptr_wbitsdata->mix_w[n].orientation + (1 << i);
                        }
                        while (mb & 1)
                        {
                            // wait until no mouse button pressed
                            mb = mouse_b;
                        }

                        if (ptr_wbitsdata->bit_type_w[n][4][i] == WBITSTYPE_DIFFERENT)
                            ptr_wbitsdata->bit_type_w[n][4][i] = WBITSTYPE_SAME;
                    }
                }
                if (ptr_wbitsdata->bit_type_w[n][4][i] == WBITSTYPE_UNKNOWN)
                {
                    textout(glb_ds1edit.screen_buff, font, "-", x, y, c);
                }
                else
                {
                    if (ptr_wbitsdata->mix_w[n].orientation & (1 << i))
                        textout(glb_ds1edit.screen_buff, font, "1", x, y, c);
                    else
                        textout(glb_ds1edit.screen_buff, font, "0", x, y, c);
                }
                x += 10;
            }

            y += 10;
        }

        // tag num (substitution layer)
        y += 10 * (4 - glb_ds1[ds1_idx].wall_num);
        y += 108;
        for (n=0; n<glb_ds1[ds1_idx].tag_num; n++)
        {
            tag_dw = ptr_wbitsdata->mix_t[n].num;
            x = w_x0 + 34;
            for (i=31; i >= 0; i--)
            {
                if (ptr_wbitsdata->bit_type_t[n][i] == WBITSTYPE_DIFFERENT)
                    c = c_blue;
                else if (ptr_wbitsdata->bit_type_t[n][i] == WBITSTYPE_UNKNOWN)
                    c = c_unkn;
                else
                    c = c_white;

                if ((mx >= x) && (mx <= x+9) && (my >= y) && (my <= y+9) &&
                        (ptr_wbitsdata->bit_type_t[n][i] != WBITSTYPE_UNKNOWN))
                {
                    c  = c_red;
                    if (mb & 1)
                    {
                        if (tag_dw & (1 << i))
                        {
                            // change to 0
                            tag_dw = tag_dw - (1 << i);
                        }
                        else
                        {
                            // change to 1
                            tag_dw = tag_dw + (1 << i);
                        }
                        while (mb & 1)
                        {
                            // wait until no mouse button pressed
                            mb = mouse_b;
                        }

                        ptr_wbitsdata->mix_t[n].num = tag_dw;

                        if (ptr_wbitsdata->bit_type_t[n][i] == WBITSTYPE_DIFFERENT)
                            ptr_wbitsdata->bit_type_t[n][i] = WBITSTYPE_SAME;
                    }
                }
                if (ptr_wbitsdata->bit_type_t[n][i] == WBITSTYPE_UNKNOWN)
                {
                    textout(glb_ds1edit.screen_buff, font, "-", x, y, c);
                }
                else
                {
                    if (tag_dw & (1 << i))
                        textout(glb_ds1edit.screen_buff, font, "1", x, y, c);
                    else
                        textout(glb_ds1edit.screen_buff, font, "0", x, y, c);
                }
                x += 10;

                if ((i==8) || (i==16) || (i==24))
                    x+=10;
            }
            y += 10;
            x = w_x0 + 48;
            textprintf(glb_ds1edit.screen_buff, font, x,       y, c_lightgreen, "%8lu", (tag_dw & 0xFF000000LU) >> 24);
            textprintf(glb_ds1edit.screen_buff, font, x + 90,  y, c_lightgreen, "%8lu", (tag_dw & 0x00FF0000LU) >> 16);
            textprintf(glb_ds1edit.screen_buff, font, x + 180, y, c_lightgreen, "%8lu", (tag_dw & 0x0000FF00LU) >> 8);
            textprintf(glb_ds1edit.screen_buff, font, x + 270, y, c_lightgreen, "%8lu",  tag_dw & 0x000000FFLU);
        }

        misc_draw_screen(mx, my);

        // new mouse state
        mx = mouse_x;
        my = mouse_y;
        mb = mouse_b;
    }

    if (save == FALSE)
    {
        // no changes
    }
    else
    {
        // set all new bits values to the selection, where needed
        wbits_apply_modification(ds1_idx, ptr_wbitsdata);

        // find again all tiles
        ds1_make_prop_2_block(ds1_idx);
    }

    if (key[KEY_ESC])
    {
        while (key[KEY_ESC])
        {
            // wait until Escape is released
        }
    }
    if (key[KEY_ENTER] || key[KEY_ENTER_PAD])
    {
        while (key[KEY_ENTER] || key[KEY_ENTER_PAD])
        {
            // wait until Enter is released
        }
    }

    // end
    text_mode(-1);
}


// ==========================================================================
void wbits_main(int ds1_idx, int tx, int ty)
{
    WBITSDATA_S * ptr_wbitsdata;
    CELL_F_S    * f_ptr;
    CELL_W_S    * w_ptr;
    CELL_S_S    * s_ptr;
    CELL_T_S    * t_ptr;
    int         x, y, t, i, size, b, b1, b2;
    int         has_selection;
    char        tmp[256];


    // init
    size = sizeof(WBITSDATA_S);
    ptr_wbitsdata = (WBITSDATA_S *) malloc(size);
    if (ptr_wbitsdata == NULL) {
        FATAL_EXIT("wbits_main() : can't alocate %i bytes for 'ptr_wbitsdata'\n", size);
    }
    memset(ptr_wbitsdata, 0, size);

    // fill ptr_wbitsdata, by analysing all tiles

    // first, search if there's a selection
    has_selection = FALSE;
    for (y=0; y < glb_ds1[ds1_idx].height; y++)
    {
        for (x=0; x < glb_ds1[ds1_idx].width; x++)
        {
            // floors
            t = (y * glb_ds1[ds1_idx].floor_line) + (x * glb_ds1[ds1_idx].floor_num);
            for (i=0; i < glb_ds1[ds1_idx].floor_num; i++)
            {
                f_ptr = glb_ds1[ds1_idx].floor_buff + t + i;
                if (IS_SELECTED(f_ptr->flags))
                    has_selection = TRUE;
            }

            // shadows
            t = (y * glb_ds1[ds1_idx].shadow_line) + (x * glb_ds1[ds1_idx].shadow_num);
            for (i=0; i < glb_ds1[ds1_idx].shadow_num; i++)
            {
                s_ptr = glb_ds1[ds1_idx].shadow_buff + t + i;
                if (IS_SELECTED(s_ptr->flags))
                    has_selection = TRUE;
            }

            // walls
            t = (y * glb_ds1[ds1_idx].wall_line) + (x * glb_ds1[ds1_idx].wall_num);
            for (i=0; i < glb_ds1[ds1_idx].wall_num; i++)
            {
                w_ptr = glb_ds1[ds1_idx].wall_buff + t + i;
                if (IS_SELECTED(w_ptr->flags))
                    has_selection = TRUE;
            }

            // tags
            t = (y * glb_ds1[ds1_idx].tag_line) + (x * glb_ds1[ds1_idx].tag_num);
            for (i=0; i < glb_ds1[ds1_idx].tag_num; i++)
            {
                t_ptr = glb_ds1[ds1_idx].tag_buff + t + i;
                if (IS_SELECTED(t_ptr->flags))
                    has_selection = TRUE;
            }
        }
    }

    if (has_selection == FALSE)
    {
        // only the tile under the mouse was 'selected'
        // --> use the normal bitfield edition window
        wbits_main_single_tile(ds1_idx, tx, ty);
    }
    else
    {
        // there were at least 1 layer of 1 tile selected
        // --> use the advanced bitfield edition window, that works
        //     ONLY on the selection (not necessary on the tile where
        //     the mouse is)

        // but first, fill up ptr_wbitsdata
        for (y=0; y < glb_ds1[ds1_idx].height; y++)
        {
            for (x=0; x < glb_ds1[ds1_idx].width; x++)
            {
                // floors
                t = (y * glb_ds1[ds1_idx].floor_line) + (x * glb_ds1[ds1_idx].floor_num);
                for (i=0; i < glb_ds1[ds1_idx].floor_num; i++)
                {
                    f_ptr = glb_ds1[ds1_idx].floor_buff + t + i;
                    if (IS_SELECTED(f_ptr->flags))
                    {
                        // add this layer into the bitfield window data

                        if (IS_SELECTED(ptr_wbitsdata->mix_f[i].flags))
                        {
                            // we can compare with precedent layer

                            // for all bits of prop1
                            for (b=0; b < 8; b++)
                            {
                                b1 = ptr_wbitsdata->mix_f[i].prop1 & (1 << b);
                                b2 = f_ptr->prop1 & (1 << b);
                                if (b1 != b2)
                                    ptr_wbitsdata->bit_type_f[i][0][b] = WBITSTYPE_DIFFERENT;
                            }

                            // for all bits of prop2
                            for (b=0; b < 8; b++)
                            {
                                b1 = ptr_wbitsdata->mix_f[i].prop2 & (1 << b);
                                b2 = f_ptr->prop2 & (1 << b);
                                if (b1 != b2)
                                    ptr_wbitsdata->bit_type_f[i][1][b] = WBITSTYPE_DIFFERENT;
                            }

                            // for all bits of prop3
                            for (b=0; b < 8; b++)
                            {
                                b1 = ptr_wbitsdata->mix_f[i].prop3 & (1 << b);
                                b2 = f_ptr->prop3 & (1 << b);
                                if (b1 != b2)
                                    ptr_wbitsdata->bit_type_f[i][2][b] = WBITSTYPE_DIFFERENT;
                            }

                            // for all bits of prop4
                            for (b=0; b < 8; b++)
                            {
                                b1 = ptr_wbitsdata->mix_f[i].prop4 & (1 << b);
                                b2 = f_ptr->prop4 & (1 << b);
                                if (b1 != b2)
                                    ptr_wbitsdata->bit_type_f[i][3][b] = WBITSTYPE_DIFFERENT;
                            }
                        }
                        else
                        {
                            SET_SELECTED(ptr_wbitsdata->mix_f[i].flags);

                            // this is the 1st time we meet this layer
                            for (b=0; b < 8; b++)
                                ptr_wbitsdata->bit_type_f[i][0][b] = WBITSTYPE_SAME;
                            for (b=0; b < 8; b++)
                                ptr_wbitsdata->bit_type_f[i][1][b] = WBITSTYPE_SAME;
                            for (b=0; b < 8; b++)
                                ptr_wbitsdata->bit_type_f[i][2][b] = WBITSTYPE_SAME;
                            for (b=0; b < 8; b++)
                                ptr_wbitsdata->bit_type_f[i][3][b] = WBITSTYPE_SAME;
                        }

                        // mix the bits values
                        ptr_wbitsdata->mix_f[i].prop1 |= f_ptr->prop1;
                        ptr_wbitsdata->mix_f[i].prop2 |= f_ptr->prop2;
                        ptr_wbitsdata->mix_f[i].prop3 |= f_ptr->prop3;
                        ptr_wbitsdata->mix_f[i].prop4 |= f_ptr->prop4;
                    }
                }

                // shadows
                t = (y * glb_ds1[ds1_idx].shadow_line) + (x * glb_ds1[ds1_idx].shadow_num);
                for (i=0; i < glb_ds1[ds1_idx].shadow_num; i++)
                {
                    s_ptr = glb_ds1[ds1_idx].shadow_buff + t + i;
                    if (IS_SELECTED(s_ptr->flags))
                    {
                        // add this layer into the bitfield window data

                        if (IS_SELECTED(ptr_wbitsdata->mix_s[i].flags))
                        {
                            // we can compare with precedent layer

                            // for all bits of prop1
                            for (b=0; b < 8; b++)
                            {
                                b1 = ptr_wbitsdata->mix_s[i].prop1 & (1 << b);
                                b2 = s_ptr->prop1 & (1 << b);
                                if (b1 != b2)
                                    ptr_wbitsdata->bit_type_s[i][0][b] = WBITSTYPE_DIFFERENT;
                            }

                            // for all bits of prop2
                            for (b=0; b < 8; b++)
                            {
                                b1 = ptr_wbitsdata->mix_s[i].prop2 & (1 << b);
                                b2 = s_ptr->prop2 & (1 << b);
                                if (b1 != b2)
                                    ptr_wbitsdata->bit_type_s[i][1][b] = WBITSTYPE_DIFFERENT;
                            }

                            // for all bits of prop3
                            for (b=0; b < 8; b++)
                            {
                                b1 = ptr_wbitsdata->mix_s[i].prop3 & (1 << b);
                                b2 = s_ptr->prop3 & (1 << b);
                                if (b1 != b2)
                                    ptr_wbitsdata->bit_type_s[i][2][b] = WBITSTYPE_DIFFERENT;
                            }

                            // for all bits of prop4
                            for (b=0; b < 8; b++)
                            {
                                b1 = ptr_wbitsdata->mix_s[i].prop4 & (1 << b);
                                b2 = s_ptr->prop4 & (1 << b);
                                if (b1 != b2)
                                    ptr_wbitsdata->bit_type_s[i][3][b] = WBITSTYPE_DIFFERENT;
                            }
                        }
                        else
                        {
                            SET_SELECTED(ptr_wbitsdata->mix_s[i].flags);

                            // this is the 1st time we meet this layer
                            for (b=0; b < 8; b++)
                                ptr_wbitsdata->bit_type_s[i][0][b] = WBITSTYPE_SAME;
                            for (b=0; b < 8; b++)
                                ptr_wbitsdata->bit_type_s[i][1][b] = WBITSTYPE_SAME;
                            for (b=0; b < 8; b++)
                                ptr_wbitsdata->bit_type_s[i][2][b] = WBITSTYPE_SAME;
                            for (b=0; b < 8; b++)
                                ptr_wbitsdata->bit_type_s[i][3][b] = WBITSTYPE_SAME;
                        }

                        // mix the bits values
                        ptr_wbitsdata->mix_s[i].prop1 |= s_ptr->prop1;
                        ptr_wbitsdata->mix_s[i].prop2 |= s_ptr->prop2;
                        ptr_wbitsdata->mix_s[i].prop3 |= s_ptr->prop3;
                        ptr_wbitsdata->mix_s[i].prop4 |= s_ptr->prop4;
                    }
                }

                // walls
                t = (y * glb_ds1[ds1_idx].wall_line) + (x * glb_ds1[ds1_idx].wall_num);
                for (i=0; i < glb_ds1[ds1_idx].wall_num; i++)
                {
                    w_ptr = glb_ds1[ds1_idx].wall_buff + t + i;
                    if (IS_SELECTED(w_ptr->flags))
                    {
                        // add this layer into the bitfield window data

                        if (IS_SELECTED(ptr_wbitsdata->mix_w[i].flags))
                        {
                            // we can compare with precedent layer

                            // for all bits of prop1
                            for (b=0; b < 8; b++)
                            {
                                b1 = ptr_wbitsdata->mix_w[i].prop1 & (1 << b);
                                b2 = w_ptr->prop1 & (1 << b);
                                if (b1 != b2)
                                    ptr_wbitsdata->bit_type_w[i][0][b] = WBITSTYPE_DIFFERENT;
                            }

                            // for all bits of prop2
                            for (b=0; b < 8; b++)
                            {
                                b1 = ptr_wbitsdata->mix_w[i].prop2 & (1 << b);
                                b2 = w_ptr->prop2 & (1 << b);
                                if (b1 != b2)
                                    ptr_wbitsdata->bit_type_w[i][1][b] = WBITSTYPE_DIFFERENT;
                            }

                            // for all bits of prop3
                            for (b=0; b < 8; b++)
                            {
                                b1 = ptr_wbitsdata->mix_w[i].prop3 & (1 << b);
                                b2 = w_ptr->prop3 & (1 << b);
                                if (b1 != b2)
                                    ptr_wbitsdata->bit_type_w[i][2][b] = WBITSTYPE_DIFFERENT;
                            }

                            // for all bits of prop4
                            for (b=0; b < 8; b++)
                            {
                                b1 = ptr_wbitsdata->mix_w[i].prop4 & (1 << b);
                                b2 = w_ptr->prop4 & (1 << b);
                                if (b1 != b2)
                                    ptr_wbitsdata->bit_type_w[i][3][b] = WBITSTYPE_DIFFERENT;
                            }

                            // for all bits of orientation
                            for (b=0; b < 8; b++)
                            {
                                b1 = ptr_wbitsdata->mix_w[i].orientation  & (1 << b);
                                b2 = w_ptr->orientation & (1 << b);
                                if (b1 != b2)
                                    ptr_wbitsdata->bit_type_w[i][4][b] = WBITSTYPE_DIFFERENT;
                            }
                        }
                        else
                        {
                            SET_SELECTED(ptr_wbitsdata->mix_w[i].flags);

                            // this is the 1st time we meet this layer
                            for (b=0; b < 8; b++)
                                ptr_wbitsdata->bit_type_w[i][0][b] = WBITSTYPE_SAME;
                            for (b=0; b < 8; b++)
                                ptr_wbitsdata->bit_type_w[i][1][b] = WBITSTYPE_SAME;
                            for (b=0; b < 8; b++)
                                ptr_wbitsdata->bit_type_w[i][2][b] = WBITSTYPE_SAME;
                            for (b=0; b < 8; b++)
                                ptr_wbitsdata->bit_type_w[i][3][b] = WBITSTYPE_SAME;
                            for (b=0; b < 8; b++)
                                ptr_wbitsdata->bit_type_w[i][4][b] = WBITSTYPE_SAME;
                        }

                        // mix the bits values
                        ptr_wbitsdata->mix_w[i].prop1 |= w_ptr->prop1;
                        ptr_wbitsdata->mix_w[i].prop2 |= w_ptr->prop2;
                        ptr_wbitsdata->mix_w[i].prop3 |= w_ptr->prop3;
                        ptr_wbitsdata->mix_w[i].prop4 |= w_ptr->prop4;
                        ptr_wbitsdata->mix_w[i].orientation |= w_ptr->orientation;
                    }
                }

                // tags
                t = (y * glb_ds1[ds1_idx].tag_line) + (x * glb_ds1[ds1_idx].tag_num);
                for (i=0; i < glb_ds1[ds1_idx].tag_num; i++)
                {
                    t_ptr = glb_ds1[ds1_idx].tag_buff + t + i;
                    if (IS_SELECTED(t_ptr->flags))
                    {
                        // add this layer into the bitfield window data

                        if (IS_SELECTED(ptr_wbitsdata->mix_t[i].flags))
                        {
                            // we can compare with precedent layer

                            // for all bits of tag num
                            for (b=0; b < 32; b++)
                            {
                                b1 = ptr_wbitsdata->mix_t[i].num & (1 << b);
                                b2 = t_ptr->num & (1 << b);
                                if (b1 != b2)
                                    ptr_wbitsdata->bit_type_t[i][b] = WBITSTYPE_DIFFERENT;
                            }
                        }
                        else
                        {
                            SET_SELECTED(ptr_wbitsdata->mix_t[i].flags);

                            // this is the 1st time we meet this layer
                            for (b=0; b < 32; b++)
                                ptr_wbitsdata->bit_type_t[i][b] = WBITSTYPE_SAME;
                        }

                        // mix the bits values
                        ptr_wbitsdata->mix_t[i].num |= t_ptr->num;
                    }
                }
            }
        }

        // let the user edit the bits
        wbits_main_multiple_tiles(ds1_idx, ptr_wbitsdata);
    }

    // end
    free(ptr_wbitsdata);
}
#include "structs.h"
#include "wpreview.h"
#include "error.h"
#include "undo.h"
#include "misc.h"
#include "wedit.h"

#define ctuif( expr ) do{ if( expr ){ continue; }}while(0)
#define brkif( expr ) do{ if( expr ){ break;    }}while(0)


// ==========================================================================
// draw shadow layer
void wedit_draw_s(int ds1_idx, int x, int y)
{
    WIN_ELEMENT_S * w_elm = & glb_ds1edit.win_edit.w_preview;
    BITMAP        * sub;
    BLOCK_TABLE_S * bt_ptr;
    BITMAP        * tmp_bmp;
    CELL_S_S      * s_ptr;
    int           n, t, bt_idx, dt1_idx, block_idx, y1;
    int           ux1, ux2, ux3, ux4, uy1, uy2, uy3;


    t     = (y * glb_ds1[ds1_idx].shadow_line) + (x * glb_ds1[ds1_idx].shadow_num);
    s_ptr = glb_ds1[ds1_idx].shadow_buff + t;
    sub   = create_sub_bitmap(glb_ds1edit.screen_buff, w_elm->i_x0, w_elm->i_y0, w_elm->inside->w, w_elm->inside->h);

    for (n=0; n<glb_ds1[ds1_idx].shadow_num; n++) {
        bt_idx = s_ptr[n].bt_idx; // index in block table
        if (bt_idx == -1) {
            ux1 = 0;
            ux2 = ux1 + 79;
            ux3 = ux1 + 80;
            ux4 = ux1 + 159;

            uy1 = sub->h - 160;
            uy2 = uy1 + 39;
            uy3 = uy1 + 78;

            line(sub, ux1, uy2, ux2, uy1, 168);
            line(sub, ux3, uy1, ux4, uy2, 168);
            line(sub, ux3, uy3, ux4, uy2, 168);
            line(sub, ux1, uy2, ux2, uy3, 168);

            textprintf(sub, font, ux1+8, uy2-2, 0, "%u %u %u %u", s_ptr[n].prop1, s_ptr[n].prop2, s_ptr[n].prop3, s_ptr[n].prop4);
            textprintf(sub, font, ux1+7, uy2-3, 255, "%u %u %u %u", s_ptr[n].prop1, s_ptr[n].prop2, s_ptr[n].prop3, s_ptr[n].prop4);
        }
        if (bt_idx <= 0) {
            continue;
        }

        bt_ptr = glb_ds1[ds1_idx].block_table + bt_idx; // pointer in block table
        if (bt_ptr->type != BT_SHADOW) {
            continue; // only shadows
        }

        dt1_idx   = bt_ptr->dt1_idx;
        block_idx = bt_ptr->block_idx;
        tmp_bmp   = * (glb_dt1[dt1_idx].block_zoom[ZM_11] + block_idx);

        if (tmp_bmp == NULL) {
            continue;
        }

        y1 = sub->h - 160 - bt_ptr->zero_line;
        y1 += 80; // shadows, like walls are lower than floors
        // (and than roofs) by 80 pixels

        switch(glb_ds1[ds1_idx].shadow_layer_mask[0])
        {
            case 1 :
                draw_sprite(sub, tmp_bmp, 0, y1);
                break;

            case 2 :
                if (glb_ds1edit.cmd_line.force_pal_num == -1)
                    color_map = & glb_ds1edit.cmap[CM_SELECT][glb_ds1[ds1_idx].act - 1];
                else
                    color_map = & glb_ds1edit.cmap[CM_SELECT][glb_ds1edit.cmd_line.force_pal_num - 1];
                draw_lit_sprite(sub, tmp_bmp, 0, y1, COL_SHADOW);
                break;

            case 3 :
                if (glb_ds1edit.cmd_line.force_pal_num == -1)
                    color_map = & glb_ds1edit.cmap[CM_TRANS][glb_ds1[ds1_idx].act - 1];
                else
                    color_map = & glb_ds1edit.cmap[CM_TRANS][glb_ds1edit.cmd_line.force_pal_num - 1];
                draw_trans_sprite(sub, tmp_bmp, 0, y1);
                break;
        }
    }
    destroy_bitmap(sub);
}


// ==========================================================================
// draw floor layers
void wedit_draw_f(int ds1_idx, int x, int y)
{
    WIN_ELEMENT_S * w_elm = & glb_ds1edit.win_edit.w_preview;
    BITMAP        * sub;
    BLOCK_TABLE_S * bt_ptr;
    BITMAP        * tmp_bmp;
    CELL_F_S      * f_ptr;
    int           n, t, bt_idx, dt1_idx, block_idx, y1;
    ORDER_DATA_S  order_data[4];
    int           ux1, ux2, ux3, ux4, uy1, uy2, uy3;


    t     = (y * glb_ds1[ds1_idx].floor_line) + (x * glb_ds1[ds1_idx].floor_num);
    f_ptr = glb_ds1[ds1_idx].floor_buff + t;
    sub   = create_sub_bitmap(glb_ds1edit.screen_buff, w_elm->i_x0, w_elm->i_y0, w_elm->inside->w, w_elm->inside->h);

    for (n=0; n<glb_ds1[ds1_idx].floor_num; n++) {
        order_data[n].idx    = n;
        order_data[n].height = f_ptr[n].prop1;
    }
    qsort(order_data, glb_ds1[ds1_idx].floor_num, sizeof(ORDER_DATA_S), qsort_helper_order_data);

    for (n=0; n<glb_ds1[ds1_idx].floor_num; n++) {
        bt_idx = f_ptr[order_data[n].idx].bt_idx; // index in block table
        if (bt_idx == -1) {
            ux1 = 0;
            ux2 = ux1 + 79;
            ux3 = ux1 + 80;
            ux4 = ux1 + 159;

            uy1 = sub->h - 160;
            uy2 = uy1 + 39;
            uy3 = uy1 + 78;

            line(sub, ux1, uy2, ux2, uy1, 168);
            line(sub, ux3, uy1, ux4, uy2, 168);
            line(sub, ux3, uy3, ux4, uy2, 168);
            line(sub, ux1, uy2, ux2, uy3, 168);

            textprintf(sub, font, ux1+8, uy2-2, 0, "%u %u %u %u", f_ptr[order_data[n].idx].prop1, f_ptr[order_data[n].idx].prop2, f_ptr[order_data[n].idx].prop3, f_ptr[order_data[n].idx].prop4);
            textprintf(sub, font, ux1+7, uy2-3, 255, "%u %u %u %u", f_ptr[order_data[n].idx].prop1, f_ptr[order_data[n].idx].prop2, f_ptr[order_data[n].idx].prop3, f_ptr[order_data[n].idx].prop4);
        }
        if (bt_idx <= 0) {
            continue;
        }

        bt_ptr = glb_ds1[ds1_idx].block_table + bt_idx; // pointer in block table
        if ( (bt_ptr->type != BT_STATIC) && (bt_ptr->type != BT_ANIMATED) ) {
            continue; // only floors
        }

        dt1_idx   = bt_ptr->dt1_idx;
        block_idx = bt_ptr->block_idx;
        tmp_bmp   = * (glb_dt1[dt1_idx].block_zoom[ZM_11] + block_idx);

        if (tmp_bmp == NULL) {
            continue;
        }

        y1 = sub->h - 160 - bt_ptr->zero_line;
        draw_sprite(sub, tmp_bmp, 0, y1);
    }
    destroy_bitmap(sub);
}


// ==========================================================================
// draw wall layers
void wedit_draw_w(int ds1_idx, int x, int y, int upper)
{
    WIN_ELEMENT_S * w_elm = & glb_ds1edit.win_edit.w_preview;
    BITMAP        * sub;
    BLOCK_TABLE_S * bt_ptr;
    BITMAP        * tmp_bmp;
    CELL_W_S      * w_ptr;
    int           n, t, bt_idx, dt1_idx, block_idx, m, s, y1;
    int           done, found, o;
    ORDER_DATA_S  order_data[4];
    int           ux1, ux2, ux3, ux4, uy1, uy2, uy3;


    t     = (y * glb_ds1[ds1_idx].wall_line) + (x * glb_ds1[ds1_idx].wall_num);
    w_ptr = glb_ds1[ds1_idx].wall_buff + t;
    sub   = create_sub_bitmap(glb_ds1edit.screen_buff, w_elm->i_x0, w_elm->i_y0, w_elm->inside->w, w_elm->inside->h);

    for (n=0; n<glb_ds1[ds1_idx].wall_num; n++) {
        order_data[n].idx    = n;
        order_data[n].height = w_ptr[n].prop1;
        if (w_ptr[n].orientation == 10) {
            order_data[n].height = 255;
        }
    }
    qsort(order_data, glb_ds1[ds1_idx].wall_num, sizeof(ORDER_DATA_S), qsort_helper_order_data);

    for (n=0; n<glb_ds1[ds1_idx].wall_num; n++) {
        o = w_ptr[order_data[n].idx].orientation;
        if ((upper == TRUE) && (o >= 15)) {
            continue;
        }
        if ((upper == FALSE) && (o <= 15)) {
            continue;
        }

        if (glb_ds1[ds1_idx].special_layer_mask && ((o == 10) || (o == 11))) {
            // special tile asked to draw later
            continue;
        }

        bt_idx = w_ptr[order_data[n].idx].bt_idx; // index in block table

        if (bt_idx == 0) {
            continue; // no tiles here
        }

        if (w_ptr[order_data[n].idx].prop4 & 0x80) {
            // binary : 1000-0000
            // hidden
            if ((o != 10) && (o != 11)) {
                bt_idx = -1; // a hidden floor --> "unknown"
            }
        }

        if (bt_idx == -1) {
            ux1 = 0;
            ux2 = ux1 + 79;
            ux3 = ux1 + 80;
            ux4 = ux1 + 159;

            uy1 = sub->h - 160;
            uy2 = uy1 + 39;
            uy3 = uy1 + 78;

            line(sub, ux1, uy2, ux2, uy1, 168);
            line(sub, ux3, uy1, ux4, uy2, 168);
            line(sub, ux3, uy3, ux4, uy2, 168);
            line(sub, ux1, uy2, ux2, uy3, 168);

            textprintf(sub, font, ux1+8, uy2-2, 0, "(%u) %u %u %u %u", w_ptr[order_data[n].idx].orientation, w_ptr[order_data[n].idx].prop1, w_ptr[order_data[n].idx].prop2, w_ptr[order_data[n].idx].prop3, w_ptr[order_data[n].idx].prop4 );
            textprintf(sub, font, ux1+7, uy2-3, 255, "(%u) %u %u %u %u", w_ptr[order_data[n].idx].orientation, w_ptr[order_data[n].idx].prop1, w_ptr[order_data[n].idx].prop2, w_ptr[order_data[n].idx].prop3, w_ptr[order_data[n].idx].prop4 );
            continue;
        }

        bt_ptr = glb_ds1[ds1_idx].block_table + bt_idx; // pointer in block table
        if ( (bt_ptr->type != BT_WALL_UP)   && (bt_ptr->type != BT_WALL_DOWN) && (bt_ptr->type != BT_SPECIAL)) {
            // only walls or special tiles, but no roof
            continue;
        }

        dt1_idx   = bt_ptr->dt1_idx;
        block_idx = bt_ptr->block_idx;

        tmp_bmp = * (glb_dt1[dt1_idx].block_zoom[ZM_11] + block_idx);

        if (tmp_bmp == NULL) {
            continue;
        }

        y1 = sub->h - 160 - bt_ptr->zero_line;
        y1 += 80; // walls are lower than floors (and than roofs) by 80 pixels
        draw_sprite(sub, tmp_bmp, 0, y1);

        if (bt_ptr->orientation == 3) {
            // upper-left corner
            // search the o=4 m=m s=s
            m = bt_ptr->main_index;
            s = bt_ptr->sub_index;
            done  = FALSE;
            found = FALSE;
            while( ! done) {
                if (bt_idx >= glb_ds1[ds1_idx].bt_num) {
                    done = TRUE;
                } else {
                    bt_ptr++;
                    if (bt_ptr->orientation < 4) {
                        bt_idx++;
                    } else {
                        if (bt_ptr->orientation == 4) {
                            if ((bt_ptr->main_index == m) && (bt_ptr->sub_index == s)) {
                                done = found = TRUE;
                            }
                        }
                    }
                }
            }

            if (found == TRUE) {
                dt1_idx   = bt_ptr->dt1_idx;
                block_idx = bt_ptr->block_idx;
                tmp_bmp   = * (glb_dt1[dt1_idx].block_zoom[ZM_11] + block_idx);

                if (tmp_bmp == NULL) {
                    continue;
                }

                y1 = sub->h - 160 - bt_ptr->zero_line;
                y1 += 80;
                draw_sprite(sub, tmp_bmp, 0, y1);
            }
        }
    }
    destroy_bitmap(sub);
}

// ==========================================================================
// draw roof layers
void wedit_draw_r(int ds1_idx, int x, int y)
{
    WIN_ELEMENT_S * w_elm = & glb_ds1edit.win_edit.w_preview;
    BITMAP        * sub;
    BLOCK_TABLE_S * bt_ptr;
    BITMAP        * tmp_bmp;
    CELL_W_S      * r_ptr;
    int           n, t, bt_idx, dt1_idx, block_idx, y1;
    ORDER_DATA_S  order_data[4];

    t     = (y * glb_ds1[ds1_idx].wall_line) + (x * glb_ds1[ds1_idx].wall_num);
    r_ptr = glb_ds1[ds1_idx].wall_buff + t;
    sub   = create_sub_bitmap(glb_ds1edit.screen_buff, w_elm->i_x0, w_elm->i_y0, w_elm->inside->w, w_elm->inside->h);

    for (n=0; n<glb_ds1[ds1_idx].wall_num; n++) {
        order_data[n].idx    = n;
        order_data[n].height = r_ptr[n].prop1;
    }
    qsort(order_data, glb_ds1[ds1_idx].wall_num, sizeof(ORDER_DATA_S), qsort_helper_order_data);

    for (n=0; n<glb_ds1[ds1_idx].wall_num; n++) {
        if (r_ptr[order_data[n].idx].prop4 & 0x80) {
            // binary : 1000-0000
            continue; // don't draw this tile
        }

        bt_idx = r_ptr[order_data[n].idx].bt_idx; // index in block table
        if (bt_idx <= 0) {
            continue;
        }

        bt_ptr = glb_ds1[ds1_idx].block_table + bt_idx; // pointer in block table
        if (bt_ptr->type != BT_ROOF) {
            continue; // only roof
        }

        dt1_idx   = bt_ptr->dt1_idx;
        block_idx = bt_ptr->block_idx;
        tmp_bmp   = * (glb_dt1[dt1_idx].block_zoom[ZM_11] + block_idx);

        if (tmp_bmp == NULL) {
            continue;
        }

        y1 = sub->h - 160 - bt_ptr->zero_line;
        y1 -= bt_ptr->roof_y;
        draw_sprite(sub, tmp_bmp, 0, y1);
    }
    destroy_bitmap(sub);
}


// ==========================================================================
// draw special tiles
void wedit_draw_sp(int ds1_idx, int x, int y)
{
    WIN_ELEMENT_S * w_elm = & glb_ds1edit.win_edit.w_preview;
    BITMAP        * sub;
    BLOCK_TABLE_S * bt_ptr;
    BITMAP        * tmp_bmp;
    CELL_W_S      * w_ptr;
    int           n, t, bt_idx, dt1_idx, block_idx, y1, o;
    ORDER_DATA_S  order_data[4];
    int           ux1, ux2, ux3, ux4, uy1, uy2, uy3;


    t     = (y * glb_ds1[ds1_idx].wall_line) + (x * glb_ds1[ds1_idx].wall_num);
    w_ptr = glb_ds1[ds1_idx].wall_buff + t;
    sub   = create_sub_bitmap(glb_ds1edit.screen_buff, w_elm->i_x0, w_elm->i_y0, w_elm->inside->w, w_elm->inside->h);

    for (n=0; n<glb_ds1[ds1_idx].wall_num; n++) {
        order_data[n].idx    = n;
        order_data[n].height = w_ptr[n].prop1;
        if (w_ptr[n].orientation == 10) {
            order_data[n].height = 255;
        }
    }
    qsort(order_data, glb_ds1[ds1_idx].wall_num, sizeof(ORDER_DATA_S), qsort_helper_order_data);

    for (n=0; n<glb_ds1[ds1_idx].wall_num; n++) {
        bt_idx = w_ptr[order_data[n].idx].bt_idx; // index in block table

        if (bt_idx == 0) {
            // no tile here
            continue;
        }

        o = w_ptr[order_data[n].idx].orientation;

        if ((o != 10) && (o != 11)) {
            // not a special tile
            continue;
        } else {
            // special tile

            if (bt_idx <= 0) {
                // unknown special tile
                ux1 = 0;
                ux2 = ux1 + 79;
                ux3 = ux1 + 80;
                ux4 = ux1 + 159;

                uy1 = sub->h - 160;
                uy2 = uy1 + 39;
                uy3 = uy1 + 78;

                line(glb_ds1edit.screen_buff, ux1, uy2, ux2, uy1, 168);
                line(glb_ds1edit.screen_buff, ux3, uy1, ux4, uy2, 168);
                line(glb_ds1edit.screen_buff, ux3, uy3, ux4, uy2, 168);
                line(glb_ds1edit.screen_buff, ux1, uy2, ux2, uy3, 168);

                textprintf(glb_ds1edit.screen_buff, font, ux1+8, uy2-2, 0, "(%u) %u %u %u %u", w_ptr[order_data[n].idx].orientation, w_ptr[order_data[n].idx].prop1, w_ptr[order_data[n].idx].prop2, w_ptr[order_data[n].idx].prop3, w_ptr[order_data[n].idx].prop4);
                textprintf(glb_ds1edit.screen_buff, font, ux1+7, uy2-3, 255, "(%u) %u %u %u %u", w_ptr[order_data[n].idx].orientation, w_ptr[order_data[n].idx].prop1, w_ptr[order_data[n].idx].prop2, w_ptr[order_data[n].idx].prop3, w_ptr[order_data[n].idx].prop4);
                continue;
            }
        }

        // draw only special tiles
        bt_ptr = glb_ds1[ds1_idx].block_table + bt_idx; // pointer in block table
        if (bt_ptr->type != BT_SPECIAL) {
            continue; // only special tiles
        }

        dt1_idx   = bt_ptr->dt1_idx;
        block_idx = bt_ptr->block_idx;

        tmp_bmp = * (glb_dt1[dt1_idx].block_zoom[ZM_11] + block_idx);

        if (tmp_bmp == NULL) {
            continue;
        }

        y1 = sub->h - 160 - bt_ptr->zero_line;
        y1 += 80; // walls are lower than floors (and than roofs) by 80 pixels
        draw_sprite(sub, tmp_bmp, 0, y1);
    }
    destroy_bitmap(sub);
}


// ==========================================================================
// make a button gfx at run-time, an activated button
void wedit_make_2nd_buttons(void)
{
    BUTTON_S * b;
    BITMAP   * tmp;
    int      i;

    for (i = BU_NULL+1; i<BU_MAX; i++) {
        b = & glb_ds1edit.win_edit.button[i];
        tmp = create_bitmap(b->w, b->h);
        if (tmp == NULL){
            FATAL_EXIT("not enough mem for 1 button");
        }
        b->bmp[1] = tmp;
        clear_to_color(tmp, 172); // almost black (but NOT color of index 0)
        // Ë≤å‰ºº‰æßÈù¢‰∏§‰∏™ÂÉèÁ¥†
        blit(b->bmp[0], tmp, 0, 0, 2, 2, b->w, b->h);
    }
}


// ==========================================================================
// read all pcx and prepare some windows
void wedit_read_pcx(void)
{
    WIN_ELEMENT_S * w_elm;
    BITMAP        * tmp_bmp;
    BITMAP        * pcx[9];
    BUTTON_S      * b;
    static struct
    {
        char      file[30];
        BUT_TYP_E b_num;
        BLK_TYP_E t_num;
        int       x0;
        int       y0;
    } data[] = {
        {"but_ok",      BU_OK,        BT_NULL,        8,  8},
        {"but_cancel",  BU_CANCEL,    BT_NULL,       83,  8},
        {"but_floor1",  BU_FLOOR1,    BT_NULL,      186, 38},
        {"but_floor2",  BU_FLOOR2,    BT_NULL,      257, 38},
        {"but_shadow",  BU_SHADOW,    BT_NULL,      470, 38},
        {"but_wall1",   BU_WALL1,     BT_NULL,      186,  8},
        {"but_wall2",   BU_WALL2,     BT_NULL,      257,  8},
        {"but_wall3",   BU_WALL3,     BT_NULL,      328,  8},
        {"but_wall4",   BU_WALL4,     BT_NULL,      399,  8},
        {"view_rand",   BU_VIEW_RAND, BT_NULL,      470,  8},
        {"tab_static",  BU_NULL,      BT_STATIC,     -1, -1},
        {"tab_anim",    BU_NULL,      BT_ANIMATED,   -1, -1},
        {"tab_upper",   BU_NULL,      BT_WALL_UP,    -1, -1},
        {"tab_lower",   BU_NULL,      BT_WALL_DOWN,  -1, -1},
        {"tab_roofs",   BU_NULL,      BT_ROOF,       -1, -1},
        {"tab_special", BU_NULL,      BT_SPECIAL,    -1, -1},
        {"tab_shadow",  BU_NULL,      BT_SHADOW,     -1, -1},
        {"", BU_NULL, BT_NULL, -1, -1} // do not remove
    };
    char filename[80];
    char pcx_name[9][20] = {
        {"up-left"},
        {"up"},
        {"up-right"},
        {"left"},
        {"fill"},
        {"right"},
        {"down-left"},
        {"down"},
        {"down-right"}
    };
    int  i=0, n1, n2, x0, y0, w, h, my_border, x, y;

    DEBUG_MESSAGE("wedit_read_pcx():in\n");
    while (strlen(data[i].file) != 0) {
        n1 = data[i].b_num;
        n2 = data[i].t_num;
        if (n1 != BU_NULL) {
            // button off
            b = & glb_ds1edit.win_edit.button[n1];
            sprintf(filename, "./res/pcx/%s.pcx", data[i].file);
            b->bmp[0] = load_pcx(filename, glb_ds1edit.dummy_pal);
            b->w = b->bmp[0]->w;
            b->h = b->bmp[0]->h;
            b->x0 = data[i].x0;
            b->y0 = data[i].y0;
        }
        if (n2 != BT_NULL) {
            // tab off
            b = & glb_ds1edit.win_edit.tab[n2];
            sprintf(filename, "./res/pcx/%s_off.pcx", data[i].file);
            b->bmp[0] = load_pcx(filename, glb_ds1edit.dummy_pal);
            b->w = b->bmp[0]->w;
            b->h = b->bmp[0]->h;

            // tab on
            sprintf(filename, "./res/pcx/%s.pcx", data[i].file);
            b->bmp[1] = load_pcx(filename, glb_ds1edit.dummy_pal);
        }
        i++;
    }

    // make preview window
    for (i=0; i<9; i++) {
        sprintf(filename, "./res/pcx/preview/%s.pcx", pcx_name[i]);
        pcx[i] = load_pcx(filename, glb_ds1edit.dummy_pal);
    }
    my_border = 8;
    x0 = my_border;
    y0 = 38;
    w = 160 + pcx[0]->w + pcx[2]->w;
    h = glb_config.screen.height - y0 - my_border;

    tmp_bmp = create_bitmap(w, h);

    clear(tmp_bmp);

    for (x=0; x<w; x += pcx[1]->w) {
        blit(pcx[1], tmp_bmp, 0, 0, x, 0, pcx[1]->w, pcx[1]->h);
    }

    for (x=0; x<w; x += pcx[7]->w) {
        blit(pcx[7], tmp_bmp, 0, 0, x, h - pcx[7]->h, pcx[7]->w, pcx[7]->h);
    }

    for (y=0; y<h; y += pcx[3]->h) {
        blit(pcx[3], tmp_bmp, 0, 0, 0, y, pcx[3]->w, pcx[3]->h);
    }

    for (y=0; y<h; y += pcx[5]->h) {
        blit(pcx[5], tmp_bmp, 0, 0, w-pcx[5]->w, y, pcx[5]->w, pcx[5]->h);
    }

    blit(pcx[0], tmp_bmp, 0, 0, 0,                     0, pcx[0]->w, pcx[0]->h);
    blit(pcx[2], tmp_bmp, 0, 0, w-pcx[2]->w,           0, pcx[2]->w, pcx[2]->h);
    blit(pcx[6], tmp_bmp, 0, 0, 0,           h-pcx[6]->h, pcx[6]->w, pcx[6]->h);
    blit(pcx[8], tmp_bmp, 0, 0, w-pcx[8]->w, h-pcx[8]->h, pcx[8]->w, pcx[8]->h);

    w_elm = & glb_ds1edit.win_edit.w_preview;
    w_elm->border = get_rle_sprite(tmp_bmp);
    w_elm->b_x0 = x0;
    w_elm->b_y0 = y0;

    for (y=0; y<h; y += pcx[4]->h) {
        for (x=0; x<w; x += pcx[4]->w) {
            blit(pcx[4], tmp_bmp, 0, 0, x, y, pcx[4]->w, pcx[4]->h);
        }
    }
    w_elm->inside = create_bitmap(w - pcx[3]->w * 2, h - pcx[1]->h * 2);
    blit(tmp_bmp, w_elm->inside, pcx[3]->w, pcx[1]->h, 0, 0, w - pcx[3]->w * 2, h - pcx[1]->h * 2);
    w_elm->i_x0 = w_elm->b_x0 + pcx[3]->w;
    w_elm->i_y0 = w_elm->b_y0 + pcx[1]->h;

    for (i=0; i<9; i++) {
        destroy_bitmap(pcx[i]);
    }
    destroy_bitmap(tmp_bmp);


    // make tiles window
    for (i=0; i<9; i++) {
        sprintf(filename, "./res/pcx/tiles/%s.pcx", pcx_name[i]);
        pcx[i] = load_pcx(filename, glb_ds1edit.dummy_pal);
    }
    x0 = w_elm->b_x0 + w_elm->border->w + my_border;
    y0 = 119;
    w = glb_config.screen.width  - x0 - my_border;
    h = glb_config.screen.height - y0 - my_border;
    tmp_bmp = create_bitmap(w, h);
    clear(tmp_bmp);

    for (x=0; x<w; x += pcx[1]->w) {
        blit(pcx[1], tmp_bmp, 0, 0, x, 0, pcx[1]->w, pcx[1]->h);
    }

    for (x=0; x<w; x += pcx[7]->w) {
        blit(pcx[7], tmp_bmp, 0, 0, x, h - pcx[7]->h, pcx[7]->w, pcx[7]->h);
    }

    for (y=0; y<h; y += pcx[3]->h) {
        blit(pcx[3], tmp_bmp, 0, 0, 0, y, pcx[3]->w, pcx[3]->h);
    }

    for (y=0; y<h; y += pcx[5]->h) {
        blit(pcx[5], tmp_bmp, 0, 0, w-pcx[5]->w, y, pcx[5]->w, pcx[5]->h);
    }

    blit(pcx[0], tmp_bmp, 0, 0, 0,                     0, pcx[0]->w, pcx[0]->h);
    blit(pcx[2], tmp_bmp, 0, 0, w-pcx[2]->w,           0, pcx[2]->w, pcx[2]->h);
    blit(pcx[6], tmp_bmp, 0, 0, 0,           h-pcx[6]->h, pcx[6]->w, pcx[6]->h);
    blit(pcx[8], tmp_bmp, 0, 0, w-pcx[8]->w, h-pcx[8]->h, pcx[8]->w, pcx[8]->h);

    w_elm = & glb_ds1edit.win_edit.w_tiles;
    w_elm->border = get_rle_sprite(tmp_bmp);
    w_elm->b_x0 = x0;
    w_elm->b_y0 = y0;

    for (y=0; y<h; y += pcx[4]->h) {
        for (x=0; x<w; x += pcx[4]->w) {
            blit(pcx[4], tmp_bmp, 0, 0, x, y, pcx[4]->w, pcx[4]->h);
        }
    }

    w_elm->inside = create_bitmap(w - pcx[3]->w * 2, h - pcx[1]->h * 2);
    blit(tmp_bmp, w_elm->inside, pcx[3]->w, pcx[1]->h, 0, 0, w - pcx[3]->w * 2, h - pcx[1]->h * 2);
    w_elm->i_x0 = w_elm->b_x0 + pcx[3]->w;
    w_elm->i_y0 = w_elm->b_y0 + pcx[1]->h;

    for (i=0; i<9; i++){
        destroy_bitmap(pcx[i]);
    }
    destroy_bitmap(tmp_bmp);

    DEBUG_MESSAGE("wedit_read_pcx():out\n");
}


// ==========================================================================
// end of 'tile edit window', free its mem
void wedit_free(void)
{
    WIN_ELEMENT_S * w_elm;
    BUTTON_S      * b, * t;
    int           i, n;

    // buttons
    for (i = BU_NULL+1; i<BU_MAX; i++)
    {
        b = & glb_ds1edit.win_edit.button[i];
        for (n=0; n<2; n++)
        {
            if (b->bmp[n] != NULL)
            {
                destroy_bitmap(b->bmp[n]);
                b->bmp[n] = NULL;
            }
        }
    }

    // tabs
    for (i = BT_NULL+1; i<BT_MAX; i++)
    {
        t = & glb_ds1edit.win_edit.tab[i];
        for (n=0; n<2; n++)
        {
            if (t->bmp[n] != NULL)
            {
                destroy_bitmap(t->bmp[n]);
                t->bmp[n] = NULL;
            }
        }
    }

    // preview & tiles windows
    for (i=0; i<2; i++)
    {
        // choose one
        if (i == 0)
            w_elm = & glb_ds1edit.win_edit.w_preview;
        else if (i == 1)
            w_elm = & glb_ds1edit.win_edit.w_tiles;
        else
            w_elm = NULL;

        // free
        if (w_elm->border != NULL)
        {
            destroy_rle_sprite(w_elm->border);
            w_elm->border = NULL;
        }
        if (w_elm->inside != NULL)
        {
            destroy_bitmap(w_elm->inside);
            w_elm->inside = NULL;
        }
    }
}


// ==========================================================================
// draw a button in the screen buffer
void wedit_draw_button(BUT_TYP_E b_num)
{
    BUTTON_S * b = & glb_ds1edit.win_edit.button[b_num];
    int x1, y1, x2, y2;

    if ( ! b->active) {
        return;
    }
    x1 = b->x0;
    x2 = x1 + b->w - 1;
    y1 = b->y0;
    y2 = y1 + b->h - 1;
    rectfill(glb_ds1edit.screen_buff, x1, y1, x2, y2, 0);
    //  ÂíåÊàë‰ª•ÂâçÂπ≤ÁöÑÂ∑Æ‰∏çÂ§ö
    draw_sprite(glb_ds1edit.screen_buff, b->bmp[b->state], b->x0, b->y0);
}


// ==========================================================================
// draw a tab in the screen buffer
void wedit_draw_tab(BLK_TYP_E t_num)
{
    BUTTON_S * t = & glb_ds1edit.win_edit.tab[t_num];
    int x1, y1, x2, y2;

    if ( ! t->active)
        return;
    x1 = t->x0;
    x2 = x1 + t->w - 1;
    y1 = t->y0;
    y2 = y1 + t->h - 1;
    rectfill(glb_ds1edit.screen_buff, x1, y1, x2, y2, 0);
    draw_sprite(glb_ds1edit.screen_buff, t->bmp[t->state], t->x0, t->y0);
}


// ==========================================================================
// does a tab have at least 1 tile of its type ?
int wedit_tab_have(int ds1_idx, BLK_TYP_E t)
{

    BLOCK_TABLE_S * bt_ptr = glb_ds1[ds1_idx].block_table;
    int           i;

    for (i=0; i<glb_ds1[ds1_idx].bt_num; i++) {
        if (bt_ptr->type == t) {
            return TRUE;
        }
        bt_ptr++;
    }

    return FALSE;
}


// ==========================================================================
// free the tiles tables for each tab
void wedit_tiles_free(void)
{
    WIN_EDIT_S  * w = & glb_ds1edit.win_edit;
    MAIN_LINE_S * m_ptr;
    int         t, m;

    for (t=BT_NULL+1; t<BT_MAX; t++)
    {
        if (w->main_line_tab[t] != NULL)
        {
            for (m=0; m < w->main_line_num[t]; m++)
            {
                m_ptr = w->main_line_tab[t] + m;
                if (m_ptr->sub_elm != NULL)
                {
                    free(m_ptr->sub_elm);
                    m_ptr->sub_elm = NULL;
                }
            }
            free(w->main_line_tab[t]);
            w->main_line_tab[t] = NULL;
        }
    }
}


// ==========================================================================
// make the tiles tables for each tab
void wedit_tiles_make(int ds1_idx)
{
    BITMAP        * tmp_bmp;
    BLOCK_TABLE_S * bt_ptr = glb_ds1[ds1_idx].block_table;
    WIN_EDIT_S    * w = & glb_ds1edit.win_edit;
    MAIN_LINE_S   * m_ptr;
    SUB_ELM_S     * s_ptr;

    int           numb, size, i, b, line, t, n, done, col, y, max_height, x;
    int           old_o, old_m, old_s, o, m, s, dx, bx, y0;
    char          ube;
    char          * is_keep, tmp[150];

    numb    = glb_ds1[ds1_idx].bt_num;
    size    = numb * sizeof(char);
    is_keep = (char *) malloc(size);
    if (is_keep == NULL) {
        FATAL_EXIT("(is_keep) : not enough mem (%i bytes)", size);
    }

    // for each type
    for (t = BT_NULL + 1; t < BT_MAX; t++) {
        for (i=0; i<numb; i++) {
            *(is_keep + i) = FALSE;
        }

        line  = 0;
        old_o = old_m = -1;
        for (b=1; b < numb; b++) {
            if (bt_ptr[b].type == t) {
                o   = bt_ptr[b].orientation;
                m   = bt_ptr[b].main_index;
                dx  = bt_ptr[b].dt1_idx;
                bx  = bt_ptr[b].block_idx;
                ube = bt_ptr[b].used_by_editor;
                tmp_bmp = * (glb_dt1[dx].block_zoom[ZM_11] + bx);
                if ((tmp_bmp != NULL) && ube) {
                    if ( (old_o != o) || (old_m != m) ) {
                        * (is_keep + b) = TRUE;
                        line++;
                        old_o = o;
                        old_m = m;
                    }
                }
            }
        }

        w->main_line_tab[t] = NULL;
        // ctuif( !line );
        if (line == 0) {
            continue;
        }

        // malloc of w->main_line_tab[t]
        size = line * sizeof(MAIN_LINE_S);
        w->main_line_tab[t] = (MAIN_LINE_S *) malloc(size);
        if (w->main_line_tab[t] == NULL) {
            FATAL_EXIT("(main_line_tab) : not enough mem (%i bytes), type %i, line %i", size, t, line);
        }
        for (i=0; i<line; i++) {
            w->main_line_tab[t][i].sub_elm    = NULL;
            w->main_line_tab[t][i].bt_idx_num = 0;
            w->main_line_tab[t][i].max_height = 0;
        }
        w->main_line_num[t] = line;

        b=1;
        y0=0;

        // for each line
        for (n=0; n<line; n++) {
            while ( * (is_keep + b) != TRUE) {
                b++;
            }
            old_o = bt_ptr[b].orientation;
            old_m = bt_ptr[b].main_index;
            old_s = bt_ptr[b].sub_index;
            col   = 1;
            y     = b;
            done  = FALSE;

            // # of different sub (but only 1st tile of the same set of random)
            do {
                y++;
                o   = bt_ptr[y].orientation;
                m   = bt_ptr[y].main_index;
                s   = bt_ptr[y].sub_index;
                if ((old_o == o) && (old_m == m)) {
                    // ok, same line
                    dx  = bt_ptr[y].dt1_idx;
                    bx  = bt_ptr[y].block_idx;
                    ube = bt_ptr[y].used_by_editor;
                    tmp_bmp = * (glb_dt1[dx].block_zoom[ZM_11] + bx);
                    if ((tmp_bmp != NULL) && ube) {
                        if (old_s != s) {
                            col++;
                            old_s = s;
                        } else {
                            // part of random set
                        }
                    }
                } else {
                    done = TRUE;
                }
            } while ( ! done);

            // col have the number of columns for this line

            // malloc of m_ptr->bt_idx_tab + n
            m_ptr          = w->main_line_tab[t] + n;
            size           = col * sizeof(SUB_ELM_S);
            m_ptr->sub_elm = (SUB_ELM_S *) malloc(size);
            if (m_ptr->sub_elm == NULL) {
                FATAL_EXIT("(sub_line) : not enough mem (%i bytes), type %i, line %i, col %i", size, t, n, col);
            }
            for (i=0; i<col; i++) {
                m_ptr->sub_elm[i].bt_idx_tab = 0;
                m_ptr->sub_elm[i].x1         = 0;
                m_ptr->sub_elm[i].y1         = 0;
                m_ptr->sub_elm[i].x2         = 0;
                m_ptr->sub_elm[i].y2         = 0;
                m_ptr->sub_elm[i].is_draw    = FALSE;
            }
            m_ptr->bt_idx_num = col;

            max_height = 0;

            // each col, first time
            old_o = bt_ptr[b].orientation;
            old_m = bt_ptr[b].main_index;
            old_s = -1;
            y     = b - 1;
            x     = 0;
            done  = FALSE;

            // for each col of this line
            do {
                y++;
                o = bt_ptr[y].orientation;
                m = bt_ptr[y].main_index;
                s = bt_ptr[y].sub_index;
                if ((old_o == o) && (old_m == m)) {
                    // ok, same line
                    dx      = bt_ptr[y].dt1_idx;
                    bx      = bt_ptr[y].block_idx;
                    ube     = bt_ptr[y].used_by_editor;
                    tmp_bmp = * (glb_dt1[dx].block_zoom[ZM_11] + bx);
                    if ((tmp_bmp != NULL) && ube) {
                        if (old_s != s) {
                            // fill it
                            s_ptr = m_ptr->sub_elm + x;
                            s_ptr->bt_idx_tab = y;
                            x++;
                            old_s = s;

                            // compare height
                            if (tmp_bmp->h > max_height) {
                                max_height = tmp_bmp->h;
                            }
                        } else {
                            // part of random set
                        }
                    }
                } else {
                    done = TRUE;
                }
            } while ( ! done);

            // each col, second time (we know the max height this time)
            old_o = bt_ptr[b].orientation;
            old_m = bt_ptr[b].main_index;
            old_s = -1;
            y     = b - 1;
            x     = 0;
            done  = FALSE;

            // for each col of this line
            do {
                y++;
                o = bt_ptr[y].orientation;
                m = bt_ptr[y].main_index;
                s = bt_ptr[y].sub_index;
                if ((old_o == o) && (old_m == m)) {
                    // ok, same line
                    dx  = bt_ptr[y].dt1_idx;
                    bx  = bt_ptr[y].block_idx;
                    ube = bt_ptr[y].used_by_editor;
                    tmp_bmp = * (glb_dt1[dx].block_zoom[ZM_11] + bx);
                    if ((tmp_bmp != NULL) && ube) {
                        if (old_s != s) {
                            // fill it
                            s_ptr = m_ptr->sub_elm + x;
                            s_ptr->x1 = 161 * x;
                            s_ptr->x2 = s_ptr->x1 + 159;
                            s_ptr->y1 = y0;
                            s_ptr->y2 = s_ptr->y1 + max_height + 12;
                            x++;
                            old_s = s;
                        } else {
                            // part of random set
                        }
                    }
                } else {
                    done = TRUE;
                }
            } while ( ! done);

            // fill max_height of this line
            m_ptr->max_height = max_height;
            y0 += max_height + 12;

            // this line is done
            b++;
        }
    }
    free(is_keep);
}


// ==========================================================================
// return the block table index of the cell (x, y) of 1 layer of the ds1
int wedit_search_tile(int ds1_idx, int x, int y, BUT_TYP_E but)
{
    CELL_F_S    * f_ptr;
    CELL_S_S    * s_ptr;
    CELL_W_S    * w_ptr;

    int         t;
    int         n;

    if ((but == BU_FLOOR1) || (but == BU_FLOOR2)) {
        // floor1Âíåfloor2ÈÉΩÁî®ÁöÑÊòØfloorÁöÑÁ¥†ÊùêÂ∫ì
        t     = (y * glb_ds1[ds1_idx].floor_line) + (x * glb_ds1[ds1_idx].floor_num);
        f_ptr = glb_ds1[ds1_idx].floor_buff + t;

        if ((but == BU_FLOOR1) && (glb_ds1[ds1_idx].floor_num >= 1)) {
            n = 0;
        } else if ((but == BU_FLOOR2) && (glb_ds1[ds1_idx].floor_num >= 2)) {
            n = 1;
        } else {
            return -1;
        }

        return f_ptr[n].bt_idx; // index in block table

    } else if (but == BU_SHADOW) {

        t     = (y * glb_ds1[ds1_idx].shadow_line) + (x * glb_ds1[ds1_idx].shadow_num);
        s_ptr = glb_ds1[ds1_idx].shadow_buff + t;

        //  Ê≤°ÊúâËøô‰∏™ÊåâÈíÆÁöÑ
        if ((but == BU_SHADOW) && (glb_ds1[ds1_idx].shadow_num >= 1)) {
            n = 0;
        } else {
            return -1;
        }

        return s_ptr[n].bt_idx; // index in block table
    } else if ((but == BU_WALL1) || (but == BU_WALL2) || (but == BU_WALL3) || (but == BU_WALL4)) {

        t      = (y * glb_ds1[ds1_idx].wall_line) + (x * glb_ds1[ds1_idx].wall_num);
        w_ptr  = glb_ds1[ds1_idx].wall_buff + t;
        //  w_ptrÊåáÂêë‰∫ÜËøõÂÖ•wedit_test‰πãÂâçÊâÄÂú®ÁöÑÈÇ£‰∏™tileÁöÑwall_tile

        if ((but == BU_WALL1) && (glb_ds1[ds1_idx].wall_num >= 1)) {
            n = 0;
        } else if ((but == BU_WALL2) && (glb_ds1[ds1_idx].wall_num >= 2)) {
            n = 1;
        } else if ((but == BU_WALL3) && (glb_ds1[ds1_idx].wall_num >= 3)) {
            n = 2;
        } else if ((but == BU_WALL4) && (glb_ds1[ds1_idx].wall_num >= 4)) {
            n = 3;
        } else {
            return -1;
        }

        //  ÁÑ∂ÂêéÁî±‰∫éÊØè‰∏™tileÊúâ4‰∏™wall_tile, ÊâÄ‰ª•ËøôÈáåÂÜç‰∏Ä‰∏™Âä†ÊùÉ
        //  Âπ∂‰∏îË∞ÉËØïÊó∂ÂÄôÂèëÁé∞4‰∏™ÊåâÈíÆÁöÑÂà∞ÁªìÊûú‰∏ÄÊ†∑, Âè™ËÉΩËØ¥4‰∏™wall_tileÈÉΩÁî®ÁöÑÊòØ‰∏ÄÊ†∑ÁöÑÁ¥†ÊùêÂ∫ì
        return w_ptr[n].bt_idx; // index in block table
    }
    return -1;
}


// ==========================================================================
/*
   void wedit_debug_tab_tiles(int ds1_idx, BLK_TYP_E t, int x0, int y0, int bt_sel)
   {
   WIN_EDIT_S    * w  = & glb_ds1edit.win_edit;
   WIN_ELEMENT_S * wt = & w->w_tiles;
   MAIN_LINE_S   * m_ptr;
   SUB_ELM_S     * s_ptr;
   BLOCK_TABLE_S * bt_ptr = glb_ds1[ds1_idx].block_table;
   BITMAP        * tmp_bmp;
   int           m, i, bt, dx, bx, x1, y1, x2, y2, c;

// draw the tiles
printf("\nTYPE = %3i\n", t);
for (m=0; m < w->main_line_num[t]; m++)
{
printf("\nmain_line = %i\n", m);
m_ptr = w->main_line_tab[t] + m;
for (i=0; i < m_ptr->bt_idx_num; i++)
{
printf("i=%3i ", i);
s_ptr = m_ptr->sub_elm + i;
x1 = s_ptr->x1 - x0;
x2 = s_ptr->x2 - x0;
printf("(x1, x2)=(%+5i, %+5i) ", x1, x2);
if ((x1 > -160) && (x1 < w->tmp_edit->w))
{
printf("OK ", m);
bt = s_ptr->bt_idx_tab;
dx = bt_ptr[bt].dt1_idx;
bx = bt_ptr[bt].block_idx;
tmp_bmp = * (glb_dt1[dx].block_zoom[ZM_11] + bx);
y1 = s_ptr->y1 - y0;
y2 = y1 + tmp_bmp->h - 1;
printf("(bt dx bx tmp_bmp y1 y2)=(%3i %3i %3i %p %+5i %+5i) ",
bt, dx, bx, tmp_bmp, y1, y2);
if (((y1 + m_ptr->max_height - 1) < 0) || (y1 >= w->tmp_edit->h))
{
// nothing to draw
printf("[NO draw] ", m);
}
else
{
printf("[   draw] ", m);
}
}
printf("\n");
}
}
}
*/

// ==========================================================================
// draw the tiles of 1 tab
void wedit_tab_tiles(int ds1_idx, BLK_TYP_E t, int x0, int y0, int bt_sel, int m_idx, int s_idx)
{
    WIN_EDIT_S    * w  = & glb_ds1edit.win_edit;
    WIN_ELEMENT_S * wt = & w->w_tiles;
    MAIN_LINE_S   * m_ptr;
    SUB_ELM_S     * s_ptr;
    BLOCK_TABLE_S * bt_ptr = glb_ds1[ds1_idx].block_table;
    BITMAP        * tmp_bmp;
    int           m, i, bt, dx, bx, x1, y1, x2, y2, c, len, dt1_idx;
    char          * dt1name;


    // wedit_debug_tab_tiles(ds1_idx, t, x0, y0, bt_sel);

    // clear the background
    blit(wt->inside, w->tmp_edit, 0, 0, 0, 0, wt->inside->w, wt->inside->h);

    // draw the tiles
    text_mode(-1);
    for (m=0; m < w->main_line_num[t]; m++) {
        m_ptr = w->main_line_tab[t] + m;

        // name of the dt1 for this line
        s_ptr = m_ptr->sub_elm;
        x1    = s_ptr->x1 - x0;
        y1    = s_ptr->y1 - y0 + (m_ptr->max_height / 2);
        if ((y1 >= -8) && (y1 < w->tmp_edit->h) && (x1 > 0)) {
            dt1_idx = bt_ptr[s_ptr->bt_idx_tab].dt1_idx;
            if (dt1_idx != -1) {
                dt1name = glb_dt1[dt1_idx].name;
                len = strlen(dt1name) + 2;
                x1 -= 8 * len;
                textprintf(w->tmp_edit, font, x1+1, y1+1,   0, "%s", dt1name);
                textprintf(w->tmp_edit, font, x1,   y1,   255, "%s", dt1name);
            }
        }

        // for each col of this line
        for (i=0; i < m_ptr->bt_idx_num; i++) {
            s_ptr = m_ptr->sub_elm + i;
            x1    = s_ptr->x1 - x0;
            x2    = s_ptr->x2 - x0;
            if ((x1 > -160) && (x1 < w->tmp_edit->w)) {
                bt = s_ptr->bt_idx_tab;
                dx = bt_ptr[bt].dt1_idx;
                bx = bt_ptr[bt].block_idx;
                tmp_bmp = * (glb_dt1[dx].block_zoom[ZM_11] + bx);
                if (tmp_bmp != NULL) {
                    y1 = s_ptr->y1 - y0;
                    y2 = y1 + tmp_bmp->h - 1;
                    if (((y1 + m_ptr->max_height - 1) < 0) || (y1 >= w->tmp_edit->h)) {
                        // nothing to draw
                        s_ptr->is_draw = FALSE;
                    } else {
                        s_ptr->is_draw = TRUE;
                        rect(w->tmp_edit, x1-1, y1-1, x2+1, y1+m_ptr->max_height+1+10, 255);
                        c = 22;
                        if (bt_sel == bt) {
                            c = 119;
                        }
                        if ((m == m_idx) && (i == s_idx)) {
                            c = 255;
                        }
                        if (t == BT_WALL_DOWN) {
                            rectfill(w->tmp_edit, x1, y1, x2, y2+9, c);
                            //  ËøôÈáåËøô‰∏™x1Âíåx2Ë¶ÅÁâπÂà´Ê≥®ÊÑè, Âõ†‰∏∫ËøôÊòØÂÖ≥Ê≥®ÁöÑÈáçÁÇπ
                            draw_sprite(w->tmp_edit, tmp_bmp, x1, y1);
                        } else {
                            rectfill(w->tmp_edit, x1, y1 + m_ptr->max_height - tmp_bmp->h, x2, y1 + m_ptr->max_height + 10, c);
                            //  ÁûÖÁûÖ, ËøôÈáåÂàÜÂºÄÁîª‰∫Ü
                            //  ÂæÄ‰∏äÊèê‰∫Ü‰∏Ä‰∫õ, ‰º∞ËÆ°Âõ†‰∏∫Ë¶ÅÂØπÈΩê
                            draw_sprite(w->tmp_edit, tmp_bmp, x1, y1 + m_ptr->max_height - tmp_bmp->h);
                        }

                        if (t == BT_WALL_DOWN) {
                            textprintf(w->tmp_edit, font, x1 +   2, y1 + 2,  96, "%2i", bt_ptr[bt].main_index);
                            textprintf(w->tmp_edit, font, x1 +  26, y1 + 2,  96, "%2i", bt_ptr[bt].orientation);
                            textprintf(w->tmp_edit, font, x1 +  82, y1 + 2, 158, "%2i", bt_ptr[bt].sub_index);
                            textprintf(w->tmp_edit, font, x1 + 138, y1 + 2, 134, "%2i", bt_ptr[bt].rarity);
                        } else {
                            textprintf(w->tmp_edit, font, x1 +   2, y1 + m_ptr->max_height + 2,  96, "%2i", bt_ptr[bt].main_index);
                            textprintf(w->tmp_edit, font, x1 +  26, y1 + m_ptr->max_height + 2,  96, "%2i", bt_ptr[bt].orientation);
                            textprintf(w->tmp_edit, font, x1 +  82, y1 + m_ptr->max_height + 2, 158, "%2i", bt_ptr[bt].sub_index);
                            textprintf(w->tmp_edit, font, x1 + 138, y1 + m_ptr->max_height + 2, 134, "%2i", bt_ptr[bt].rarity);
                        }
                    }
                } else {
                    // nothing to draw (tmp_bmp == NULL)
                    s_ptr->is_draw = FALSE;
                }
            }
        }
    }
}


// ==========================================================================
// scroll the tiles window of 1 tab to see the current tile
void wedit_jump(int ds1_idx, int bt_idx, int * xn, int * yn)
{
    WIN_EDIT_S    * w      = & glb_ds1edit.win_edit;
    WIN_ELEMENT_S * wt     = & w->w_tiles;
    MAIN_LINE_S   * m_ptr;
    SUB_ELM_S     * s_ptr;
    BLOCK_TABLE_S * bt_ptr = glb_ds1[ds1_idx].block_table;
    int           m, s;
    BLK_TYP_E     t;

    * xn = 0;
    * yn = 0;
    if (bt_idx <= 0) {
        // ÊàëË∞ÉËØïÁöÑËøáÁ®ã‰∏≠, Áî±‰∫éÂè™Êúâ‰∏Ä‰∏™Âú∞ÂõæÂèÇ‰∏éË∞ÉËØï
        // ÊâÄ‰ª•ËøôÈáå‰∏ÄÁõ¥‰∏∫0 ‰ª•ÂêéÁöÑÈÉΩÊ≤°ÊúâÊâßË°å
        return;
    }

    t = bt_ptr[bt_idx].type;
    for (m=0; m < w->main_line_num[t]; m++) {
        m_ptr = w->main_line_tab[t] + m;
        for (s=0; s<m_ptr->bt_idx_num; s++) {
            s_ptr = m_ptr->sub_elm + s;
            if (s_ptr->bt_idx_tab == bt_idx) {
                * xn = s_ptr->x1 - glb_config.scroll.edit.x;
                if (t == BT_WALL_DOWN) {
                    * yn = s_ptr->y1 - glb_config.scroll.edit.y;
                } else {
                    * yn = s_ptr->y2 + glb_config.scroll.edit.y - wt->inside->h;
                }
                return;
            }
        }
    }
    return;
}


// ==========================================================================
// what tile of 1 tab is under the mouse ?
void wedit_mouse_tile(int mx, int my, int x0, int y0, int t, int * m_idx, int * s_idx)
{
    WIN_EDIT_S    * w  = & glb_ds1edit.win_edit;
    WIN_ELEMENT_S * wt = & w->w_tiles;
    MAIN_LINE_S   * m_ptr;
    SUB_ELM_S     * s_ptr;
    int           m, i, x, y;

    // mouse inside the tile window ?
    x = mx - wt->i_x0;
    y = my - wt->i_y0;
    if ((x >= 0) && (x < wt->inside->w) && (y >= 0) && (y < wt->inside->h))
    {
        // yes, so search the tile which is under the mouse
        x += x0;
        y += y0;
        for (m=0; m < w->main_line_num[t]; m++)
        {
            m_ptr = w->main_line_tab[t] + m;
            for (i=0; i < m_ptr->bt_idx_num; i++)
            {
                s_ptr = m_ptr->sub_elm + i;
                if (s_ptr->is_draw)
                {
                    if ((x >= s_ptr->x1) && (x <= s_ptr->x2) &&
                            (y >= s_ptr->y1) && (y <= s_ptr->y2))
                    {
                        * m_idx = m;
                        * s_idx = i;
                        return;
                    }
                }
            }
        }
    }
    // outside, or no pointing any tile
    * m_idx = * s_idx = -1;
}


// ==========================================================================
// tile chosen in the list, update the ds1 with it
void wedit_update_tile(int ds1_idx, int x, int y, BUT_TYP_E button,
        BLK_TYP_E type, int m_idx, int s_idx)
{
    BLOCK_TABLE_S * bt_ptr = glb_ds1[ds1_idx].block_table;
    WIN_EDIT_S    * e_ptr  = & glb_ds1edit.win_edit;
    MAIN_LINE_S   * m_ptr;
    SUB_ELM_S     * s_ptr;
    CELL_W_S      * w_ptr;
    CELL_F_S      * f_ptr;
    CELL_S_S      * sh_ptr;
    int           f = -1, s = -1, w = -1, t, bt;

    switch (button)
    {
        case BU_FLOOR1 : if (glb_ds1[ds1_idx].floor_num  >= 1) f = 0; break;
        case BU_FLOOR2 : if (glb_ds1[ds1_idx].floor_num  >= 2) f = 1; break;
        case BU_SHADOW : if (glb_ds1[ds1_idx].shadow_num >= 1) s = 0; break;
        case BU_WALL1  : if (glb_ds1[ds1_idx].wall_num   >= 1) w = 0; break;
        case BU_WALL2  : if (glb_ds1[ds1_idx].wall_num   >= 2) w = 1; break;
        case BU_WALL3  : if (glb_ds1[ds1_idx].wall_num   >= 3) w = 2; break;
        case BU_WALL4  : if (glb_ds1[ds1_idx].wall_num   >= 4) w = 3; break;
    }
    if ((f == -1) && (w == -1) && (s == -1))
        return;
    m_ptr = e_ptr->main_line_tab[type] + m_idx;
    s_ptr = m_ptr->sub_elm + s_idx;
    bt    = s_ptr->bt_idx_tab;
    if (f != -1)
    {
        t = (y * glb_ds1[ds1_idx].floor_line) + (x * glb_ds1[ds1_idx].floor_num);
        f_ptr = glb_ds1[ds1_idx].floor_buff + t + f;
        if (f_ptr->prop1 == 0)
            f_ptr->prop1 = 194; // normal floor priority
        f_ptr->prop2  = bt_ptr[bt].sub_index;
        f_ptr->prop3  = (bt_ptr[bt].main_index & 0x0F) << 4;
        f_ptr->prop4  = (bt_ptr[bt].main_index & 0x30) >> 4;
        f_ptr->bt_idx = bt;
    }
    else if (s != -1)
    {
        t = (y * glb_ds1[ds1_idx].shadow_line) + (x * glb_ds1[ds1_idx].shadow_num);
        sh_ptr = glb_ds1[ds1_idx].shadow_buff + t + s;
        if (sh_ptr->prop1 == 0)
            sh_ptr->prop1 = 128; // normal shadow prop1
        sh_ptr->prop2  = bt_ptr[bt].sub_index;
        sh_ptr->prop3  = (bt_ptr[bt].main_index & 0x0F) << 4;
        sh_ptr->prop4  = ((bt_ptr[bt].main_index & 0x30) >> 4) | 0x08;
        sh_ptr->bt_idx = bt;
    }
    else if (w != -1)
    {
        t = (y * glb_ds1[ds1_idx].wall_line) + (x * glb_ds1[ds1_idx].wall_num);
        w_ptr = glb_ds1[ds1_idx].wall_buff + t + w;
        w_ptr->orientation = bt_ptr[bt].orientation;
        if (w_ptr->prop1 == 0)
            w_ptr->prop1 = 129; // normal wall priority
        w_ptr->prop2  = bt_ptr[bt].sub_index;
        w_ptr->prop3  = (bt_ptr[bt].main_index & 0x0F) << 4;
        w_ptr->prop4  = (bt_ptr[bt].main_index & 0x30) >> 4;
        w_ptr->bt_idx = bt;
    }
}


// ==========================================================================
// entering the tile window : save the tile infos (preparing cancel button)
void wedit_save_tile(int ds1_idx, int x, int y, CELL_F_S * dst_f_ptr, CELL_W_S * dst_w_ptr, CELL_S_S * dst_s_ptr)
{
    //  ‰º†ÂÖ•ÁöÑ‰∏â‰∏™ÂèÇÊï∞
    //  CELL_W_S      save_wall   [WALL_MAX_LAYER];     // 4
    //  CELL_F_S      save_floor  [FLOOR_MAX_LAYER];    // 2
    //  CELL_S_S      save_shadow [SHADOW_MAX_LAYER];   // 1

    CELL_W_S * w_ptr;
    CELL_F_S * f_ptr;
    CELL_S_S * s_ptr;
    int      i, t;


    // save floors
    t = (y * glb_ds1[ds1_idx].floor_line) + (x * glb_ds1[ds1_idx].floor_num);
    //  Ëøô‰∏™Á®ãÂ∫èÈáåÈù¢, ÊâÄÊúâÁöÑÂÆèÂÆö‰πâÁöÑ_MAX‰πãÁ±ªÁöÑÈÉΩËµãÂÄºÂà∞‰∫ÜÂèòÈáèÈáåÈù¢
    for (i=0; i<glb_ds1[ds1_idx].floor_num; i++) {
        // ÂèØËßÅÈáçË¶ÅÁöÑ‰πüÂ∞±ÂÖ≠‰∏™ÂÄº
        f_ptr = glb_ds1[ds1_idx].floor_buff + t + i;
        dst_f_ptr[i].prop1  = f_ptr->prop1;
        dst_f_ptr[i].prop2  = f_ptr->prop2;
        dst_f_ptr[i].prop3  = f_ptr->prop3;
        dst_f_ptr[i].prop4  = f_ptr->prop4;
        dst_f_ptr[i].bt_idx = f_ptr->bt_idx;
        dst_f_ptr[i].flags  = f_ptr->flags;
    }

    // save shadows
    t = (y * glb_ds1[ds1_idx].shadow_line) + (x * glb_ds1[ds1_idx].shadow_num);
    for (i=0; i<glb_ds1[ds1_idx].shadow_num; i++) {
        s_ptr = glb_ds1[ds1_idx].shadow_buff + t + i;
        dst_s_ptr[i].prop1  = s_ptr->prop1;
        dst_s_ptr[i].prop2  = s_ptr->prop2;
        dst_s_ptr[i].prop3  = s_ptr->prop3;
        dst_s_ptr[i].prop4  = s_ptr->prop4;
        dst_s_ptr[i].bt_idx = s_ptr->bt_idx;
        dst_s_ptr[i].flags  = s_ptr->flags;
    }

    // save walls
    t = (y * glb_ds1[ds1_idx].wall_line) + (x * glb_ds1[ds1_idx].wall_num);
    for (i=0; i<glb_ds1[ds1_idx].wall_num; i++) {
        w_ptr = glb_ds1[ds1_idx].wall_buff + t + i;
        dst_w_ptr[i].prop1       = w_ptr->prop1;
        dst_w_ptr[i].prop2       = w_ptr->prop2;
        dst_w_ptr[i].prop3       = w_ptr->prop3;
        dst_w_ptr[i].prop4       = w_ptr->prop4;
        // Â§ö‰∫Ü‰∏Ä‰∏™orientationÂàÜÈáè
        dst_w_ptr[i].orientation = w_ptr->orientation;
        dst_w_ptr[i].bt_idx      = w_ptr->bt_idx;
        dst_w_ptr[i].flags       = w_ptr->flags;
    }
}


// ==========================================================================
// cancel button : put back the precedently save tile infos
void wedit_cancel_tile(int ds1_idx, int x, int y,
        CELL_F_S * src_f_ptr, CELL_W_S * src_w_ptr,
        CELL_S_S * src_s_ptr)
{
    CELL_W_S * w_ptr;
    CELL_F_S * f_ptr;
    CELL_S_S * s_ptr;
    int      i, t;


    // put previous floors
    t = (y * glb_ds1[ds1_idx].floor_line) + (x * glb_ds1[ds1_idx].floor_num);
    for (i=0; i<glb_ds1[ds1_idx].floor_num; i++)
    {
        f_ptr = glb_ds1[ds1_idx].floor_buff + t;
        f_ptr[i].prop1  = src_f_ptr[i].prop1;
        f_ptr[i].prop2  = src_f_ptr[i].prop2;
        f_ptr[i].prop3  = src_f_ptr[i].prop3;
        f_ptr[i].prop4  = src_f_ptr[i].prop4;
        f_ptr[i].bt_idx = src_f_ptr[i].bt_idx;
        f_ptr[i].flags  = src_f_ptr[i].flags;
    }

    // put previous shadows
    t = (y * glb_ds1[ds1_idx].shadow_line) + (x * glb_ds1[ds1_idx].shadow_num);
    for (i=0; i<glb_ds1[ds1_idx].shadow_num; i++)
    {
        s_ptr = glb_ds1[ds1_idx].shadow_buff + t;
        s_ptr[i].prop1  = src_s_ptr[i].prop1;
        s_ptr[i].prop2  = src_s_ptr[i].prop2;
        s_ptr[i].prop3  = src_s_ptr[i].prop3;
        s_ptr[i].prop4  = src_s_ptr[i].prop4;
        s_ptr[i].bt_idx = src_s_ptr[i].bt_idx;
        s_ptr[i].flags  = src_s_ptr[i].flags;
    }

    // put previous walls
    t = (y * glb_ds1[ds1_idx].wall_line) + (x * glb_ds1[ds1_idx].wall_num);
    for (i=0; i<glb_ds1[ds1_idx].wall_num; i++)
    {
        w_ptr = glb_ds1[ds1_idx].wall_buff + t;
        w_ptr[i].prop1       = src_w_ptr[i].prop1;
        w_ptr[i].prop2       = src_w_ptr[i].prop2;
        w_ptr[i].prop3       = src_w_ptr[i].prop3;
        w_ptr[i].prop4       = src_w_ptr[i].prop4;
        w_ptr[i].orientation = src_w_ptr[i].orientation;
        w_ptr[i].bt_idx      = src_w_ptr[i].bt_idx;
        w_ptr[i].flags       = src_w_ptr[i].flags;
    }
}


// ==========================================================================
// ok button, put the old datas in undo buffer
void wedit_keep_tile(int ds1_idx, int x, int y,
        CELL_F_S * src_f_ptr, CELL_W_S * src_w_ptr,
        CELL_S_S * src_s_ptr)
{
    UNDO_S * u = & glb_ds1[ds1_idx].undo;
    int    n;

    undo_new_tile_buffer(ds1_idx);

    for (n=0; n<glb_ds1[ds1_idx].floor_num; n++)
        u->dat_flg.f[n] = DF_P1 | DF_P2 | DF_P3 | DF_P4;

    for (n=0; n<glb_ds1[ds1_idx].shadow_num; n++)
        u->dat_flg.s[n] = DF_P1 | DF_P2 | DF_P3 | DF_P4;

    for (n=0; n<glb_ds1[ds1_idx].wall_num; n++)
        u->dat_flg.w[n] = DF_P1 | DF_P2 | DF_P3 | DF_P4 | DF_OR;

    undo_add_this_tile_to_buffer(ds1_idx, x, y, src_f_ptr, src_w_ptr, src_s_ptr);
    undo_close_tile_buffer(ds1_idx);
}


// ==========================================================================
// MAIN loop of the 'tile edit window'
//    (certainly too big)
void wedit_test(int ds1_idx, int tx, int ty)
{
    WIN_ELEMENT_S * w_elm;
    WIN_EDIT_S    * w = & glb_ds1edit.win_edit;
    DS1_S         * d = & glb_ds1[ds1_idx];
    BUTTON_S      * b;
    BLOCK_TABLE_S * bt_ptr = glb_ds1[ds1_idx].block_table;
    int           i, n, done=FALSE, mx, my, mb;
    int           focus=0, focus_can_change=TRUE, bt_sel;
    int           my_border = 1, xn=0, yn=0, old_xn=0, old_yn=0;
    BUT_TYP_E     current_button = BU_NULL;
    BLK_TYP_E     current_type = BT_NULL;
    int           m_idx, s_idx;
    CELL_W_S      save_wall   [WALL_MAX_LAYER];     // 4
    CELL_F_S      save_floor  [FLOOR_MAX_LAYER];    // 2
    CELL_S_S      save_shadow [SHADOW_MAX_LAYER];   // 1
    char          tmp[80];


    //  txÂíåtyÊòØÂΩìÂâçÁÇπÂáªÁöÑtileÂùêÊ†á
    wedit_save_tile(ds1_idx, tx, ty, save_floor, save_wall, save_shadow);
    wedit_tiles_make(ds1_idx);
    //  ÊØèÊ¨°ÈÉΩ‰ºöÊääÂÖâÊ†á‰ΩçÁΩÆËÆæÂÆö‰∏Ä‰∏ãÁöÑ
    position_mouse(200, 70);

    w->button[BU_WALL1].active  = 0 < d->wall_num ? TRUE : FALSE;
    w->button[BU_WALL2].active  = 1 < d->wall_num ? TRUE : FALSE;
    w->button[BU_WALL3].active  = 2 < d->wall_num ? TRUE : FALSE;
    w->button[BU_WALL4].active  = 3 < d->wall_num ? TRUE : FALSE;

    w->button[BU_FLOOR1].active = 0 < d->floor_num ? TRUE : FALSE;
    w->button[BU_FLOOR2].active = 1 < d->floor_num ? TRUE : FALSE;

    w->button[BU_OK].active        = TRUE;
    w->button[BU_CANCEL].active    = TRUE;

    w->button[BU_VIEW_RAND].active = FALSE;
    //   w->button[BU_VIEW_RAND].active = TRUE;

    //  ‰∏äÈù¢ËÆæÂÆö‰∏Ä‰∏ãÂÖâÊ†á‰ΩçÁΩÆÁöÑÂéüÂõ†‰º∞ËÆ°Âú®ËøôÈáå?
    //  ËÆæÁΩÆÁöÑÈÇ£‰∏™Âú∞ÊñπÂàöÂ•ΩÊ≤°Êúâ‰ªª‰ΩïÈº†Ê†á
    for (i=BU_NULL + 1; i<BU_MAX; i++) {
        if (w->button[i].active) {
            w->button[i].mouse_over  = FALSE;
            w->button[i].state       = BS_OFF;
        }
    }

    if (w->button[BU_WALL1].active == TRUE) {
        current_button = BU_WALL1;
    } else if (w->button[BU_FLOOR1].active == TRUE) {
        current_button = BU_FLOOR1;
    }

    //  bt_idx of the current button: current layer
    //  ÂæóÂà∞ÁöÑÊòØÂΩìÂâçtileÁöÑÂØπÂ∫îÊåâÈíÆÁöÑÁ¥†ÊùêÂ∫ì
    bt_sel = wedit_search_tile(ds1_idx, tx, ty, current_button);
    //  ÊöÇÊó∂ÂøΩÁï•Ëøô‰∏™
    wedit_jump(ds1_idx, bt_sel, & xn, & yn);

    w_elm = & glb_ds1edit.win_edit.w_tiles;

    b = & w->tab[BT_STATIC];
    b->x0             = w_elm->i_x0;
    b->y0             = 88;
    b->active         = FALSE;
    b->state          = BS_OFF;
    b->tab_have_tiles = wedit_tab_have(ds1_idx, BT_STATIC);

    b = & w->tab[BT_ANIMATED];
    b->x0             = w->tab[BT_STATIC].x0 + w->tab[BT_STATIC].w + my_border;
    b->y0             = 88;
    b->active         = FALSE;
    b->state          = BS_OFF;
    b->tab_have_tiles = wedit_tab_have(ds1_idx, BT_ANIMATED);

    b = & w->tab[BT_SHADOW];
    b->x0             = w_elm->i_x0;
    b->y0             = 88;
    b->active         = FALSE;
    b->state          = BS_OFF;
    b->tab_have_tiles = wedit_tab_have(ds1_idx, BT_SHADOW);

    //  Ëøô‰∏äÈù¢tab_have_tilesÈÉΩË¢´Ë¶ÜÁõñ‰∫ÜÂá†Ê¨°‰∫Ü
    //  ËøôÈáåËÉΩÁúãÂà∞ÁöÑ‰πüÂ∞±ÊòØBT_SHADOW
    if (b->tab_have_tiles) {
        w->button[BU_SHADOW].active = TRUE;
    } else {
        w->button[BU_SHADOW].active = FALSE;
    }

    b = & w->tab[BT_WALL_UP];
    b->x0             = w_elm->i_x0;
    b->y0             = 88;
    b->state          = BS_OFF;
    b->tab_have_tiles = b->active = wedit_tab_have(ds1_idx, BT_WALL_UP);

    b = & w->tab[BT_WALL_DOWN];
    b->x0             = w->tab[BT_WALL_UP].x0 + w->tab[BT_WALL_UP].w + my_border;
    b->y0             = 88;
    b->state          = BS_OFF;
    b->tab_have_tiles = b->active = wedit_tab_have(ds1_idx, BT_WALL_DOWN);

    b = & w->tab[BT_ROOF];
    b->x0             = w->tab[BT_WALL_DOWN].x0 + w->tab[BT_WALL_DOWN].w + my_border;
    b->y0             = 88;
    b->state          = BS_OFF;
    b->tab_have_tiles = b->active = wedit_tab_have(ds1_idx, BT_ROOF);

    b = & w->tab[BT_SPECIAL];
    b->x0             = w->tab[BT_ROOF].x0 + w->tab[BT_ROOF].w + my_border;
    b->y0             = 88;
    b->state          = BS_OFF;
    b->tab_have_tiles = b->active = wedit_tab_have(ds1_idx, BT_SPECIAL);

    set_color_depth(8);

    w->tmp_edit = create_bitmap(w->w_tiles.inside->w, w->w_tiles.inside->h);

    set_color_depth(glb_config.screen.depth);

    if (bt_sel >= 1) {
        current_type = bt_ptr[bt_sel].type;
        w->tab[current_type].state = BS_ON;
    } else {
        if (w->tab[BT_WALL_UP].active) {
            w->tab[BT_WALL_UP].state = BS_ON;
            current_type = BT_WALL_UP;
        } else if (w->tab[BT_WALL_DOWN].active) {
            w->tab[BT_WALL_DOWN].state = BS_ON;
            current_type = BT_WALL_DOWN;
        } else if (w->tab[BT_ROOF].active) {
            w->tab[BT_ROOF].state = BS_ON;
            current_type = BT_ROOF;
        } else if (w->tab[BT_SPECIAL].active) {
            w->tab[BT_SPECIAL].state = BS_ON;
            current_type = BT_SPECIAL;
        }
    }

    //  ÂÖàÁîª‰∫Ü‰∏ÄÂº†‰∏çÁî®ÂèòÂåñÁöÑÂõæ, Âç≥‰∏∫Âè≥ËæπÊâÄÊúâÁöÑÂõæ?
    wedit_tab_tiles(ds1_idx, current_type, xn, yn, bt_sel, -1, -1);

    // main loop
    while ( ! done) {

        mx = mouse_x;
        my = mouse_y;
        mb = mouse_b;

        // always redraw whole screen

        clear_to_color(glb_ds1edit.screen_buff, 27);
        for (i = BU_NULL+1; i<BU_MAX; i++) {
            wedit_draw_button(i);
        }

        if (current_button != BU_NULL) {
            b = & glb_ds1edit.win_edit.button[current_button];
            rect(glb_ds1edit.screen_buff, b->x0-2, b->y0-2, b->x0+b->w+1, b->y0+b->h+1, 133); // medium green
        }

        w_elm = & glb_ds1edit.win_edit.w_preview;
        draw_rle_sprite(glb_ds1edit.screen_buff, w_elm->border, w_elm->b_x0, w_elm->b_y0);
        blit(w_elm->inside, glb_ds1edit.screen_buff, 0, 0, w_elm->i_x0, w_elm->i_y0, w_elm->inside->w, w_elm->inside->h);

        w_elm = & glb_ds1edit.win_edit.w_tiles;
        draw_rle_sprite(glb_ds1edit.screen_buff, w_elm->border, w_elm->b_x0, w_elm->b_y0);


        //  wpreview_draw_w(ds1_idx, x, y, mx, my, z, select, FALSE); // lower walls
        //  Ëøô‰∏™ÊòØuser_interface_handlerÁ®ãÂ∫èÈáåÈù¢ÁöÑdraw

        wedit_draw_w (ds1_idx, tx, ty, FALSE); // lower walls
        wedit_draw_f (ds1_idx, tx, ty);        // floors
        wedit_draw_s (ds1_idx, tx, ty);        // shadows
        wedit_draw_w (ds1_idx, tx, ty, TRUE);  // upper walls
        wedit_draw_r (ds1_idx, tx, ty);        // roofs
        wedit_draw_sp(ds1_idx, tx, ty);        // special tiles

        for (i=BT_NULL + 1; i<BT_MAX; i++) {
            b = & w->tab[i];
            if (b->active) {
                wedit_draw_tab(i);
            }
        }

        blit(w->tmp_edit, glb_ds1edit.screen_buff, 0, 0, w_elm->i_x0, w_elm->i_y0, w->tmp_edit->w, w->tmp_edit->h);

        misc_draw_screen(mx, my);

        // which tile is under the mouse ?
        wedit_mouse_tile(mx, my, xn, yn, current_type, & m_idx, & s_idx);

        // scroll
        if (key[KEY_UP] || my == 0) {
            yn -= glb_config.scroll.edit.y;
        }
        if (key[KEY_DOWN] || my == glb_config.screen.height - 1) {
            yn += glb_config.scroll.edit.y;
        }
        if (key[KEY_LEFT] || mx == 0) {
            xn -= glb_config.scroll.edit.x;
        }
        if (key[KEY_RIGHT] || mx == glb_config.screen.width - 1) {
            xn += glb_config.scroll.edit.x;
        }
        if (key[KEY_HOME]) {
            xn = 0;
        }
        if (key[KEY_PGUP]) {
            if (key[KEY_LCONTROL] || key[KEY_RCONTROL]) {
                xn -= w->tmp_edit->w;
            } else {
                yn -= w->tmp_edit->h;
            }
            rest(80);
        }
        if (key[KEY_PGDN]) {
            if (key[KEY_LCONTROL] || key[KEY_RCONTROL]) {
                xn += w->tmp_edit->w;
            } else {
                yn += w->tmp_edit->h;
            }
            rest(80);
        }

        // special tiles layer
        if (key[KEY_F9]) {
            while(key[KEY_F9]) {
                // nozz to do
            }
            glb_ds1[ds1_idx].special_layer_mask = 1 - glb_ds1[ds1_idx].special_layer_mask;
        }

        // shadow mode
        if (key[KEY_F11]) {
            while(key[KEY_F11]) {
            }
            if (key[KEY_LSHIFT] || key[KEY_RSHIFT]) {
                glb_ds1[ds1_idx].shadow_layer_mask[0]--;
                if (glb_ds1[ds1_idx].shadow_layer_mask[0] < 0) {
                    glb_ds1[ds1_idx].shadow_layer_mask[0] = 3;
                }
            } else {
                glb_ds1[ds1_idx].shadow_layer_mask[0]++;
                if (glb_ds1[ds1_idx].shadow_layer_mask[0] >= 4) {
                    glb_ds1[ds1_idx].shadow_layer_mask[0] = 0;
                }
            }
        }

        // gamma correction
        if (key[KEY_F12]) {
            if (key[KEY_LSHIFT] || key[KEY_RSHIFT]) {
                if (glb_ds1edit.cur_gamma > GC_060) {
                    rest(80);
                    glb_ds1edit.cur_gamma--;
                    misc_update_pal_with_gamma();
                    set_palette(glb_ds1edit.vga_pal[glb_ds1[ds1_idx].act - 1]);
                }
            } else {
                if (glb_ds1edit.cur_gamma < GC_300) {
                    rest(80);
                    glb_ds1edit.cur_gamma++;
                    misc_update_pal_with_gamma();
                    set_palette(glb_ds1edit.vga_pal[glb_ds1[ds1_idx].act - 1]);
                }
            }
        }

        // screenshot
        if (key[KEY_P]) {
            sprintf(tmp, "screenshot-%05i.pcx", glb_ds1edit.screenshot_num);
            while (file_exists(tmp, -1, NULL)) {
                glb_ds1edit.screenshot_num++;
                sprintf(tmp, "screenshot-%05i.pcx", glb_ds1edit.screenshot_num);
            }

            // draw the mouse cursor onto the buffer
            draw_sprite( glb_ds1edit.screen_buff, glb_ds1edit.mouse_cursor[glb_ds1edit.mode], mouse_x - 1, mouse_y - 1);

            // save the buffer
            save_pcx(tmp, glb_ds1edit.screen_buff, glb_ds1edit.vga_pal[glb_ds1[ds1_idx].act-1]);
            misc_pcx_put_d2_palette(tmp, glb_ds1[ds1_idx].act-1);
            glb_ds1edit.screenshot_num++;
            while (key[KEY_P]){
            }

        }

        // focus for buttons
        if (focus_can_change) {
            focus = 0;
        }

        for (i=BU_NULL + 1; i<BU_MAX; i++) {
            b = & w->button[i];
            if (b->active) {
                if ((mx >= b->x0) && (my >= b->y0) && (mx <  b->x0 + b->w) && (my <  b->y0 + b->h)) {
                    // mouse is over
                    b->mouse_over = TRUE;
                    if (mb) {
                        // mouse button is pressed
                        if ((focus_can_change) || (focus == i)) {
                            // change state if needed
                            if (b->state == BS_OFF) {
                                b->state = BS_ON;
                            }
                            if (focus_can_change) {
                                focus = i;
                                focus_can_change = FALSE;
                            }
                        }
                    } else {// no mouse button pressed
                        // change state if needed
                        if (b->state == BS_ON) {
                            b->state = BS_OFF;
                        }
                    }
                } else {// mouse NOT over
                    b->mouse_over = FALSE;
                    if (mb) {
                        // change state if needed
                        if (b->state == BS_ON) {
                            b->state = BS_OFF;
                        }
                    }
                }
            }
        }

        // focus for tabs
        for (i=BT_NULL + 1; i<BT_MAX; i++) {
            b = & w->tab[i];
            if (b->active) {
                if ((mx >= b->x0) && (my >= b->y0) && (mx <  b->x0 + b->w) && (my <  b->y0 + b->h)) {
                    // mouse is over
                    b->mouse_over = TRUE;
                    if (mb) {
                        // mouse button is pressed
                        if (focus_can_change) {
                            // all tabs are off
                            for (n=BT_NULL + 1; n<BT_MAX; n++) {
                                if (w->tab[n].active) {
                                    w->tab[n].state = BS_OFF;
                                }
                            }
                            // this tab is on
                            b->state     = BS_ON;
                            current_type = i;
                            xn = yn = 0;
                        }
                    }
                } else {// mouse NOT over
                    b->mouse_over = FALSE;
                }
            }
        }

        // anti-bug
        if ((focus == 0) && (mb)) {
            focus_can_change = FALSE;
        }

        // when no mouse button
        if (mb == 0) {
            if (key[KEY_ENTER] || key[KEY_ENTER_PAD]) {
                // keep changes
                done = TRUE;
                wedit_keep_tile(ds1_idx, tx, ty, save_floor, save_wall, save_shadow);
                while (key[KEY_ENTER] || key[KEY_ENTER_PAD]) {
                    // nozz to do
                }
                focus_can_change = TRUE;
            }

            // releasing the focus button ?
            if (focus_can_change == FALSE) {
                if (w->button[focus].mouse_over == TRUE) {
                    // action
                    switch(focus) {
                        case BU_OK :
                            // keep changes
                            done = TRUE;
                            wedit_keep_tile(ds1_idx, tx, ty, save_floor, save_wall, save_shadow);
                            break;

                        case BU_CANCEL :
                            // restore original state
                            wedit_cancel_tile(ds1_idx, tx, ty, save_floor, save_wall, save_shadow);
                            done = TRUE;
                            break;

                        case BU_FLOOR1 :
                        case BU_FLOOR2 :
                            for (n=BT_NULL + 1; n<BT_MAX; n++) {
                                w->tab[n].active = FALSE;
                                w->tab[n].state  = BS_OFF;
                            }
                            w->tab[BT_STATIC].active   = w->tab[BT_STATIC].tab_have_tiles;
                            w->tab[BT_ANIMATED].active = w->tab[BT_ANIMATED].tab_have_tiles;
                            current_button = focus;
                            bt_sel = wedit_search_tile(ds1_idx, tx, ty, current_button);
                            wedit_jump(ds1_idx, bt_sel, & xn, & yn);
                            if (bt_sel >= 1) {
                                current_type = bt_ptr[bt_sel].type;
                                w->tab[current_type].state = BS_ON;
                            } else {
                                if (w->tab[BT_STATIC].active) {
                                    w->tab[BT_STATIC].state = BS_ON;
                                    current_type = BT_STATIC;
                                } else if (w->tab[BT_ANIMATED].active) {
                                    w->tab[BT_ANIMATED].state = BS_ON;
                                    current_type = BT_ANIMATED;
                                }
                            }
                            break;

                        case BU_SHADOW :
                            for (n=BT_NULL + 1; n<BT_MAX; n++) {
                                w->tab[n].active = FALSE;
                                w->tab[n].state  = BS_OFF;
                            }
                            w->tab[BT_SHADOW].active = w->tab[BT_SHADOW].tab_have_tiles;
                            current_button = focus;
                            bt_sel = wedit_search_tile(ds1_idx, tx, ty, current_button);
                            wedit_jump(ds1_idx, bt_sel, & xn, & yn);
                            if (bt_sel >= 1) {
                                current_type = bt_ptr[bt_sel].type;
                                w->tab[current_type].state = BS_ON;
                            } else {
                                if (w->tab[BT_SHADOW].active) {
                                    w->tab[BT_SHADOW].state = BS_ON;
                                    current_type = BT_SHADOW;
                                }
                            }
                            break;

                        case BU_WALL1 :
                        case BU_WALL2 :
                        case BU_WALL3 :
                        case BU_WALL4 :
                            for (n=BT_NULL + 1; n<BT_MAX; n++) {
                                w->tab[n].active = FALSE;
                                w->tab[n].state  = BS_OFF;
                            }
                            w->tab[BT_WALL_UP].active   = w->tab[BT_WALL_UP].tab_have_tiles;
                            w->tab[BT_WALL_DOWN].active = w->tab[BT_WALL_DOWN].tab_have_tiles;
                            w->tab[BT_ROOF].active      = w->tab[BT_ROOF].tab_have_tiles;
                            w->tab[BT_SPECIAL].active   = w->tab[BT_SPECIAL].tab_have_tiles;
                            current_button = focus;
                            bt_sel = wedit_search_tile(ds1_idx, tx, ty, current_button);
                            wedit_jump(ds1_idx, bt_sel, & xn, & yn);
                            if (bt_sel >= 1) {
                                current_type = bt_ptr[bt_sel].type;
                                w->tab[current_type].state = BS_ON;
                            } else {
                                if (w->tab[BT_WALL_UP].active) {
                                    w->tab[BT_WALL_UP].state = BS_ON;
                                    current_type = BT_WALL_UP;
                                } else if (w->tab[BT_WALL_DOWN].active) {
                                    w->tab[BT_WALL_DOWN].state = BS_ON;
                                    current_type = BT_WALL_DOWN;
                                } else if (w->tab[BT_ROOF].active) {
                                    w->tab[BT_ROOF].state = BS_ON;
                                    current_type = BT_ROOF;
                                } else if (w->tab[BT_SPECIAL].active) {
                                    w->tab[BT_SPECIAL].state = BS_ON;
                                    current_type = BT_SPECIAL;
                                }
                            }
                            break;
                    }
                }
                focus_can_change = TRUE;

                // over a tile ?
                if ((m_idx != -1) && (s_idx != -1)) {
                    // yes, change to this one
                    wedit_update_tile(ds1_idx, tx, ty, current_button, current_type, m_idx, s_idx);
                    bt_sel = wedit_search_tile(ds1_idx, tx, ty, current_button);
                }
            }
        }

        // redraw tiles
        wedit_tab_tiles(ds1_idx, current_type, xn, yn, bt_sel, m_idx, s_idx);
        old_xn = xn;
        old_yn = yn;
    }

    destroy_bitmap(w->tmp_edit);
    w->tmp_edit = NULL;
    wedit_tiles_free();
}
#include <string.h>
#include "structs.h"
#include "error.h"
#include "wmsg.h"
#include "misc.h"


// ==========================================================================
int wmsg_main(WMSG_S * wmsg)
{
   int  mx, my, mb, done = FALSE;
   int  wx0, wy0, wx1, wy1; // main message window base
   int  i, n, curr_length = 0, max_length = 0;
   int  curr_width, max_width, curr_height;
   int  text_lines = 0, line_height, x, y, x2, y2;
   int  ret = -1, bx0, by0, but_maxwidth = 0, bg, fg, border;
   int  s, k, all_keys;
   char tmp[512];

   // for safety
   if (wmsg == NULL)
      return -1;
   if (wmsg->text == NULL)
      return -1;
   if (wmsg->button == NULL)
      return -1;

   // max width of the text
   n = strlen(wmsg->text) + 1;
   for (i=0; i < n; i++)
   {
      if ( (wmsg->text[i] != 0x0A) &&
           (wmsg->text[i] != 0x0D) &&
           (wmsg->text[i] != 0x00)
         )
         curr_length++;
      else
      {
         if (curr_length > max_length)
            max_length = curr_length;
         curr_length = 0;
         text_lines++;
      }
   }
   max_width    = (max_length + 2) * wmsg->font_width;
   line_height  = wmsg->font_height + 2;
   curr_height  = text_lines * line_height;
   curr_height += line_height;

   // title width and height
   if (wmsg->title != NULL)
   {
      curr_height += line_height * 2;
      curr_width = wmsg->font_width * strlen(wmsg->title);
      if (curr_width > max_width)
         max_width = curr_width;
   }

   // buttons starting positions and width
   but_maxwidth = 0;
   i = 0;
   while (wmsg->button[i].text != NULL)
   {
      n = strlen(wmsg->button[i].text);
      but_maxwidth += (2 + n + wmsg->button[i].right_spaces) *
                      wmsg->font_width;

      // next buttton
      i++;
   }
   but_maxwidth += 2 * wmsg->font_width;
   if (but_maxwidth > max_width)
      max_width = but_maxwidth;
   curr_height += line_height * 5;


   // draw message window, without buttons
   wx0 = (glb_config.screen.width  - max_width)  / 2;
   bx0 = wx0 + wmsg->font_width + ((max_width - but_maxwidth) / 2);
   wy0 = (glb_config.screen.height - curr_height) / 2;
   wx1 = wx0 + max_width;
   wy1 = wy0 + curr_height;
   by0 = wy1 - line_height * 4;
   rectfill(glb_ds1edit.screen_buff, wx0, wy0, wx1, wy1, wmsg->col_win.bg);
   x = wx0 + wmsg->font_width;
   y = wy0 + wmsg->font_height;

   // title
   if (wmsg->title != NULL)
   {
      rectfill(glb_ds1edit.screen_buff, wx0, wy0, wx1, wy0 + line_height*2, wmsg->col_title.bg);
      rect(glb_ds1edit.screen_buff, wx0, wy0, wx1, wy0 + line_height*2, wmsg->col_title.fg);
      hline(glb_ds1edit.screen_buff, wx0, wy0 + line_height*2, wx1, wmsg->col_win.fg);

      text_mode(wmsg->col_title.bg);
      textout(glb_ds1edit.screen_buff, font, wmsg->title, x, y, wmsg->col_title.fg);
      y += line_height * 2;
   }

   // text
   tmp[1] = 0x00;
   n = strlen(wmsg->text) + 1;
   text_mode(wmsg->col_text.bg);
   for (i=0; i < n; i++)
   {
      if ( (wmsg->text[i] != 0x0A) &&
           (wmsg->text[i] != 0x0D) &&
           (wmsg->text[i] != 0x00)
         )
      {
         // draw char
         tmp[0] = wmsg->text[i];
         textout(glb_ds1edit.screen_buff, font, tmp, x, y, wmsg->col_text.fg);
         x += wmsg->font_width;
      }
      else
      {
         x  = wx0 + wmsg->font_width;
         y += line_height;
      }
   }

   // border of main window
   rect(glb_ds1edit.screen_buff, wx0, wy0, wx1, wy1, wmsg->col_win.fg);


   // mouse background
   // show_mouse(NULL);
   mx = mouse_x;
   my = mouse_y;
   mb = mouse_b;

   // main loop
   text_mode(-1);
   while ( ! done)
   {
      // handle keyboard shortcuts
      i = 0;
      while ((wmsg->button[i].text != NULL) && ( ! done) )
      {
         for (s=0; s < MW_SHORTCUT_NUM; s++)
         {
            // is this shortcut is pressed ?
            // check all keys of that combination
            all_keys = TRUE;
            if (wmsg->button[i].shortcut[s].key[0] != 0)
            {
               for (k=0; k < MW_COMBINATION_KEY_NUM; k++)
               {
                  if (wmsg->button[i].shortcut[s].key[k])
                  {
                     if ( ! key[ wmsg->button[i].shortcut[s].key[k] ])
                        all_keys = FALSE;
                  }
               }
            }
            else
               all_keys = FALSE;
            if (all_keys == TRUE)
            {
               done = TRUE;
               ret  = i;

               // wait for all keys of the shortcut to not be pressed
               while (all_keys == TRUE)
               {
                  all_keys = FALSE;
                  for (k=0; k < MW_COMBINATION_KEY_NUM; k++)
                  {
                     if (wmsg->button[i].shortcut[s].key[k])
                     {
                        if (key[ wmsg->button[i].shortcut[s].key[k] ])
                           all_keys = TRUE;
                     }
                  }
               }
            }
         }

         // next button
         i++;
      }

      // draw all buttons
      i  = 0;
      x  = bx0;
      y  = by0;
      y2 = y + (3 * line_height);
      while (wmsg->button[i].text != NULL)
      {
         n  = strlen(wmsg->button[i].text);
         x2 = x + ((n + 2) * wmsg->font_width);

         // mouse over the button ?
         if ((mx >= x) && (mx <= x2) && (my >= y) && (my <= y2))
         {
            // over the button
            bg     = wmsg->button[i].on.bg;
            fg     = wmsg->button[i].on.fg;
            border = wmsg->button[i].on.border;

            // mouse button pressed
            if (mb)
            {
               while (mb)
                  mb = mouse_b;
               done = TRUE;
               ret  = i;
            }
         }
         else
         {
            // not over this button
            bg     = wmsg->button[i].off.bg;
            fg     = wmsg->button[i].off.fg;
            border = wmsg->button[i].off.border;
         }

         // draw current button
         rectfill(glb_ds1edit.screen_buff, x, y, x2, y2, bg);
         textprintf(
            glb_ds1edit.screen_buff,
            font,
            x + wmsg->font_width,
            y + line_height + 2,
            fg,
            "%s", wmsg->button[i].text
         );
         rect(glb_ds1edit.screen_buff, x, y, x2, y2, border);
         
         // next button
         x = x2 + (wmsg->font_width * wmsg->button[i].right_spaces);
         i++;
      }

      misc_draw_screen(mx, my);

      // new mouse state
      mx = mouse_x;
      my = mouse_y;
      mb = mouse_b;
   }

   text_mode(-1);

   return ret;
}
#include <math.h>
#include <string.h>
#include "structs.h"
#include "gfx_custom.h"
#include "misc.h"
#include "editobj.h"
#include "error.h"
#include "editpath.h"
#include "wpreview.h"

#ifdef WIN32
#pragma warning (push)
#pragma warning (disable  : 4244 4267 )
#endif

// ==========================================================================
// draw a sprite with a tint
void wpreview_shape(BITMAP * tmp_bmp, int x0, int y0, int ds1_idx, COL_E col_idx)
{
    if (glb_ds1edit.cmd_line.force_pal_num == -1) {
        color_map = & glb_ds1edit.cmap[CM_SELECT][glb_ds1[ds1_idx].act - 1];
    } else {
        color_map = & glb_ds1edit.cmap[CM_SELECT][glb_ds1edit.cmd_line.force_pal_num - 1];
    }
    draw_lit_sprite(glb_ds1edit.screen_buff, tmp_bmp, x0, y0, col_idx);
}


// ==========================================================================
// draw a gouraud floor sprite
void wpreview_gouraud_f(BITMAP * tmp_bmp, int x0, int y0, int ds1_idx, int c1, int c2, int c3, int c4)
{
    if ((c1 == c2) && (c2 == c3) && (c3 == c4)) {
        if (c1 <= 7) {
            return;
        }
        if (c1 >= 248) {
            draw_sprite(glb_ds1edit.screen_buff, tmp_bmp, x0, y0);
        } else {
            if (glb_ds1edit.cmd_line.force_pal_num == -1) {
                color_map = & glb_ds1edit.cmap[CM_SHADOW][glb_ds1[ds1_idx].act - 1];
            } else {
                color_map = & glb_ds1edit.cmap[CM_SHADOW][glb_ds1edit.cmd_line.force_pal_num - 1];
            }
            draw_lit_sprite(glb_ds1edit.screen_buff, tmp_bmp, x0, y0, c1);
        }
    } else {
        if (glb_ds1edit.cmd_line.force_pal_num == -1) {
            color_map = & glb_ds1edit.cmap[CM_SHADOW][glb_ds1[ds1_idx].act - 1];
        } else {
            color_map = & glb_ds1edit.cmap[CM_SHADOW][glb_ds1edit.cmd_line.force_pal_num - 1];
        }
        if (glb_ds1edit.night_mode == 1) {
            draw_gouraud_sprite(glb_ds1edit.screen_buff, tmp_bmp, x0, y0, c1, c2, c3, c4);
        } else {
            draw_lit_sprite(glb_ds1edit.screen_buff, tmp_bmp, x0, y0, (c1 + c2 + c3 + c4) / 4);
        }
    }
}


// ==========================================================================
// draw a gouraud wall sprite
void wpreview_gouraud_w(BITMAP * tmp_bmp, int x0, int y0, int ds1_idx, int c1, int c2, int c3, int c4)
{
    if (glb_ds1edit.cmd_line.force_pal_num == -1) {
        color_map = & glb_ds1edit.cmap[CM_SHADOW][glb_ds1[ds1_idx].act - 1];
    } else {
        color_map = & glb_ds1edit.cmap[CM_SHADOW][glb_ds1edit.cmd_line.force_pal_num - 1];
    }

    if ((c1 == c2) && (c2 == c3) && (c3 == c4)) {
        if (c1 >= 248) {
            draw_sprite(glb_ds1edit.screen_buff, tmp_bmp, x0, y0);
        } else {
            if (glb_ds1edit.cmd_line.force_pal_num == -1) {
                color_map = & glb_ds1edit.cmap[CM_SHADOW][glb_ds1[ds1_idx].act - 1];
            } else {
                color_map = & glb_ds1edit.cmap[CM_SHADOW][glb_ds1edit.cmd_line.force_pal_num - 1];
            }
            draw_lit_sprite(glb_ds1edit.screen_buff, tmp_bmp, x0, y0, c1);
        }
    } else {
        if (glb_ds1edit.night_mode == 1) {
            draw_gouraud_sprite(glb_ds1edit.screen_buff, tmp_bmp, x0, y0, c1, c2, c3, c4);
        } else {
            draw_lit_sprite(glb_ds1edit.screen_buff, tmp_bmp, x0, y0, (c1 + c2 + c3 + c4) / 4);
        }
    }
}


// ==========================================================================
// compute the distance between 2 points
int wpreview_light_dist(int x0, int y0, int mx, int my)
{
    double dx, dy;

    dx = mx - x0;
    dx *= dx;

    dy = (my - y0) * 2;
    dy *= dy;

    //ceil(x):∑µªÿ¥Û”⁄ªÚµ»”⁄xµƒ◊Ó–°’˚ ˝
    return ceil(sqrt(dx + dy));
}


// ==========================================================================
// helper of qsort, for tile drawing priority
int qsort_helper_order_data(const void *e1, const void *e2)
{
    ORDER_DATA_S * o1, * o2;

    o1 = (ORDER_DATA_S *) e1;
    o2 = (ORDER_DATA_S *) e2;

    // damn microsoft vc6 implementation of qsort() #=?*@!!
    if (o1->height == o2->height) {
        return o1->idx - o2->idx; // else it reverse the original order !
    }

    return o1->height - o2->height;
}


// ==========================================================================
// draw shadow layer
void wpreview_draw_s(int ds1_idx, int x, int y, int mx, int my, int z, int selected)
{
    BLOCK_TABLE_S * bt_ptr;
    BITMAP        * tmp_bmp;
    CELL_S_S      * s_ptr;
    int           n, t, bt_idx, dt1_idx, block_idx, y1, color;
    int           ux1, ux2, ux3, ux4, uy1, uy2, uy3;


    t     = (y * glb_ds1[ds1_idx].shadow_line) + (x * glb_ds1[ds1_idx].shadow_num);
    s_ptr = glb_ds1[ds1_idx].shadow_buff + t;

    for (n=0; n<glb_ds1[ds1_idx].shadow_num; n++) {
        color = -1;
        if (glb_ds1[ds1_idx].shadow_layer_mask[n] == 0) {
            continue;
        }

        if (IS_HIDE(s_ptr[n].flags)) {
            continue;
        }

        bt_idx = s_ptr[n].bt_idx; // index in block table

        if (s_ptr[n].prop4 & 0x80) {
            // binary : 1000-0000
            bt_idx = -1; // consider that tile as "unknown"
        }

        if (bt_idx == -1) {
            ux1 = mx - glb_ds1edit.win_preview.x0;
            ux2 = ux1 + glb_ds1[ds1_idx].tile_w / 2 - 1;
            ux3 = ux1 + glb_ds1[ds1_idx].tile_w / 2;
            ux4 = ux1 + glb_ds1[ds1_idx].tile_w - 1;

            uy1 = my - glb_ds1edit.win_preview.y0;
            uy2 = uy1 + glb_ds1[ds1_idx].tile_h / 2 - 1;
            uy3 = uy1 + glb_ds1[ds1_idx].tile_h - 2;

            line(glb_ds1edit.screen_buff, ux1, uy2, ux2, uy1, 168);
            line(glb_ds1edit.screen_buff, ux3, uy1, ux4, uy2, 168);
            line(glb_ds1edit.screen_buff, ux3, uy3, ux4, uy2, 168);
            line(glb_ds1edit.screen_buff, ux1, uy2, ux2, uy3, 168);

            if (glb_ds1[ds1_idx].cur_zoom == ZM_11) {
                textprintf(glb_ds1edit.screen_buff, font, ux1+8, uy2-2, 0, "%u %u %u %u", s_ptr[n].prop1, s_ptr[n].prop2, s_ptr[n].prop3, s_ptr[n].prop4);
                textprintf(glb_ds1edit.screen_buff, font, ux1+7, uy2-3, 255, "%u %u %u %u", s_ptr[n].prop1, s_ptr[n].prop2, s_ptr[n].prop3, s_ptr[n].prop4);
            }
        }
        if (bt_idx <= 0) {
            continue;
        }

        bt_ptr = glb_ds1[ds1_idx].block_table + bt_idx; // pointer in block table

        if (bt_ptr->type != BT_SHADOW) {
            continue; // only shadows
        }

        dt1_idx   = bt_ptr->dt1_idx;
        block_idx = bt_ptr->block_idx;

        tmp_bmp = * (glb_dt1[dt1_idx].block_zoom[z] + block_idx);

        if (tmp_bmp == NULL) {
            continue;
        }

        y1 = my - glb_ds1edit.win_preview.y0 - bt_ptr->zero_line * glb_ds1[ds1_idx].height_mul / glb_ds1[ds1_idx].height_div;
        y1 += glb_ds1[ds1_idx].tile_h; // shadow, like walls, are lower than floors
        //    (and than roofs) by 80 pixels

        if ( (y1 + tmp_bmp->h) < 0) {
            continue;
        }
        if (y1 >= glb_ds1edit.win_preview.h) {
            continue;
        }

        if (selected) {
            if (IS_COPY_INFO(s_ptr[n].flags)) {
                color = COL_PASTE_OK;
                if (IS_COPY_STATE(s_ptr[n].flags)) {
                    color = COL_PASTE_KO;
                }
            } else if (IS_TMP_SELECT(s_ptr[n].flags)) {
                color = COL_TMPSEL_M;
            } else if (IS_SELECTED(s_ptr[n].flags)) {
                color = COL_FLOOR_M;
            } else {
                color = COL_MOUSE;
            }
        } else {
            if (IS_COPY_INFO(s_ptr[n].flags)) {
                color = COL_PASTE_OK;
                if (IS_COPY_STATE(s_ptr[n].flags)) {
                    color = COL_PASTE_KO;
                }
            } else if (IS_TMP_SELECT(s_ptr[n].flags)) {
                color = COL_TMPSEL;
            } else if (IS_SELECTED(s_ptr[n].flags)) {
                color = COL_FLOOR;
            }
        }
        if ((color != -1) && (glb_ds1edit.mode != MOD_L)) {
            wpreview_shape(tmp_bmp, mx - glb_ds1edit.win_preview.x0, y1, ds1_idx, color);
        } else {
            switch(glb_ds1[ds1_idx].shadow_layer_mask[0]) {
                case 0 : // nothing to draw
                    break;

                case 1 : // normal sprite
                    draw_sprite(glb_ds1edit.screen_buff, tmp_bmp, mx - glb_ds1edit.win_preview.x0, y1);
                    break;

                case 2 : // only 1 color, full white sprite
                    wpreview_shape(tmp_bmp, mx - glb_ds1edit.win_preview.x0, y1, ds1_idx, COL_SHADOW);
                    break;

                case 3 : // transparent
                    if (glb_ds1edit.cmd_line.force_pal_num == -1) {
                        color_map = & glb_ds1edit.cmap[CM_TRANS][glb_ds1[ds1_idx].act - 1];
                    } else {
                        color_map = & glb_ds1edit.cmap[CM_TRANS][glb_ds1edit.cmd_line.force_pal_num - 1];
                    }
                    draw_trans_sprite( glb_ds1edit.screen_buff, tmp_bmp, mx - glb_ds1edit.win_preview.x0, y1);
                    break;
            }
        }
    }
}


// ==========================================================================
// prepare animated floor for a frame to draw
void wpreview_reiinit_animated_floor(int ds1_idx)
{
    BLOCK_TABLE_S * bt_ptr;
    int i;

    bt_ptr = glb_ds1[ds1_idx].block_table;
    for (i=0; i < glb_ds1[ds1_idx].bt_num; i++) {
        if (bt_ptr->type == BT_ANIMATED) {
            bt_ptr->updated = FALSE;
        }
        bt_ptr++;
    }
}


// ==========================================================================
// draw floor layer
void wpreview_draw_f(int ds1_idx, int x, int y, int mx, int my, int z, int selected)
{
    BLOCK_TABLE_S * bt_ptr;
    BITMAP        * tmp_bmp;
    CELL_F_S      * f_ptr;
    int           n, t, bt_idx, dt1_idx, block_idx, y1, color;
    ORDER_DATA_S  order_data[4];
    int           dist, c1, c2, c3, c4;
    int           ux1, ux2, ux3, ux4, uy1, uy2, uy3;


    t     = (y * glb_ds1[ds1_idx].floor_line) + (x * glb_ds1[ds1_idx].floor_num);
    f_ptr = glb_ds1[ds1_idx].floor_buff + t;

    // search the order in which to draw the 4 floor layers of this tile
    for (n=0; n<glb_ds1[ds1_idx].floor_num; n++) {
        order_data[n].idx    = n;
        order_data[n].height = f_ptr[n].prop1;
    }
    qsort(order_data, glb_ds1[ds1_idx].floor_num, sizeof(ORDER_DATA_S), qsort_helper_order_data);

    for (n=0; n<glb_ds1[ds1_idx].floor_num; n++) {
        color = -1;
        if (glb_ds1[ds1_idx].floor_layer_mask[order_data[n].idx] == 0) {
            continue;
        }

        if (IS_HIDE(f_ptr[order_data[n].idx].flags)) {
            continue;
        }

        bt_idx = f_ptr[order_data[n].idx].bt_idx; // index in block table

        if (bt_idx == 0) {
            // no tiles here
            continue;
        }

        if (f_ptr[order_data[n].idx].prop4 & 0x80) {
            // binary : 1000-0000
            bt_idx = -1; // consider that tile as "unknown"
        }

        if (bt_idx == -1) {
            ux1 = mx - glb_ds1edit.win_preview.x0;
            ux2 = ux1 + glb_ds1[ds1_idx].tile_w / 2 - 1;
            ux3 = ux1 + glb_ds1[ds1_idx].tile_w / 2;
            ux4 = ux1 + glb_ds1[ds1_idx].tile_w - 1;

            uy1 = my - glb_ds1edit.win_preview.y0;
            uy2 = uy1 + glb_ds1[ds1_idx].tile_h / 2 - 1;
            uy3 = uy1 + glb_ds1[ds1_idx].tile_h - 2;

            line(glb_ds1edit.screen_buff, ux1, uy2, ux2, uy1, 168);
            line(glb_ds1edit.screen_buff, ux3, uy1, ux4, uy2, 168);
            line(glb_ds1edit.screen_buff, ux3, uy3, ux4, uy2, 168);
            line(glb_ds1edit.screen_buff, ux1, uy2, ux2, uy3, 168);

            if (glb_ds1[ds1_idx].cur_zoom == ZM_11) {
                textprintf(glb_ds1edit.screen_buff, font, ux1+8, uy2-2, 0, "%u %u %u %u", f_ptr[order_data[n].idx].prop1, f_ptr[order_data[n].idx].prop2, f_ptr[order_data[n].idx].prop3, f_ptr[order_data[n].idx].prop4);
                textprintf(glb_ds1edit.screen_buff, font, ux1+7, uy2-3, 255, "%u %u %u %u", f_ptr[order_data[n].idx].prop1, f_ptr[order_data[n].idx].prop2, f_ptr[order_data[n].idx].prop3, f_ptr[order_data[n].idx].prop4);
            }
        }
        if (bt_idx <= 0) {
            continue;
        }

        bt_ptr = glb_ds1[ds1_idx].block_table + bt_idx; // pointer in block table

        if ( (bt_ptr->type != BT_STATIC) && (bt_ptr->type != BT_ANIMATED) ) {
            continue; // only floors
        }

        if (bt_ptr->type == BT_ANIMATED) {
            // find the frame of an animated floor to draw
            if (bt_ptr->updated == FALSE) {
                bt_ptr->curr_frame = (glb_ds1[ds1_idx].cur_anim_floor_frame / 5) % (bt_ptr->rarity + 1);
                bt_ptr->updated = TRUE;
            }
            bt_ptr += bt_ptr->curr_frame - bt_ptr->rarity;
        }

        dt1_idx   = bt_ptr->dt1_idx;
        block_idx = bt_ptr->block_idx;

        tmp_bmp = * (glb_dt1[dt1_idx].block_zoom[z] + block_idx);

        if (tmp_bmp == NULL) {
            continue;
        }

        y1 = my - glb_ds1edit.win_preview.y0 - bt_ptr->zero_line * glb_ds1[ds1_idx].height_mul / glb_ds1[ds1_idx].height_div;
        if ( (y1 + tmp_bmp->h) < 0) {
            continue;
        }
        if (y1 >= glb_ds1edit.win_preview.h) {
            continue;
        }

        if (glb_ds1edit.mode == MOD_L) {
            // c1
            dist = wpreview_light_dist( mx, my, glb_ds1edit.win_preview.x0 + mouse_x, glb_ds1edit.win_preview.y0 + mouse_y);
            if (dist < 200) {
                c1 = 255;
            } else if (dist > 500) {
                c1 = 0;
            } else {
                c1 = 255 - ((dist - 200) * 255 / (500 - 200));
            }

            // c2
            dist = wpreview_light_dist( mx + tmp_bmp->w, my, glb_ds1edit.win_preview.x0 + mouse_x, glb_ds1edit.win_preview.y0 + mouse_y);
            if (dist < 200) {
                c2 = 255;
            } else if (dist > 500) {
                c2 = 0;
            } else {
                c2 = 255 - ((dist - 200) * 255 / (500 - 200));
            }

            // c3
            dist = wpreview_light_dist( mx + tmp_bmp->w, my + glb_ds1[ds1_idx].tile_h, glb_ds1edit.win_preview.x0 + mouse_x, glb_ds1edit.win_preview.y0 + mouse_y);
            if (dist < 200) {
                c3 = 255;
            } else if (dist > 500) {
                c3 = 0;
            } else {
                c3 = 255 - ((dist - 200) * 255 / (500 - 200));
            }

            // c4
            dist = wpreview_light_dist( mx, my + glb_ds1[ds1_idx].tile_h, glb_ds1edit.win_preview.x0 + mouse_x, glb_ds1edit.win_preview.y0 + mouse_y);
            if (dist < 200) {
                c4 = 255;
            } else if (dist > 500) {
                c4 = 0;
            } else {
                c4 = 255 - ((dist - 200) * 255 / (500 - 200));
            }

            // draw it
            wpreview_gouraud_f(tmp_bmp, mx - glb_ds1edit.win_preview.x0, y1, ds1_idx, c1, c2, c3, c4);
        } else {
            if (selected) {
                if (IS_COPY_INFO(f_ptr[order_data[n].idx].flags)) {
                    color = COL_PASTE_OK;
                    if (IS_COPY_STATE(f_ptr[order_data[n].idx].flags)) {
                        color = COL_PASTE_KO;
                    }
                } else if (IS_TMP_SELECT(f_ptr[order_data[n].idx].flags)) {
                    color = COL_TMPSEL_M;
                } else if (IS_SELECTED(f_ptr[order_data[n].idx].flags)) {
                    color = COL_FLOOR_M;
                } else {
                    color = COL_MOUSE;
                }
            } else {
                if (IS_COPY_INFO(f_ptr[order_data[n].idx].flags)) {
                    color = COL_PASTE_OK;
                    if (IS_COPY_STATE(f_ptr[order_data[n].idx].flags)) {
                        color = COL_PASTE_KO;
                    }
                } else if (IS_TMP_SELECT(f_ptr[order_data[n].idx].flags)) {
                    color = COL_TMPSEL;
                } else if (IS_SELECTED(f_ptr[order_data[n].idx].flags)) {
                    color = COL_FLOOR;
                }
            }

            if (color != -1) {
                wpreview_shape(tmp_bmp, mx - glb_ds1edit.win_preview.x0, y1, ds1_idx, color);
            } else {
                draw_sprite(glb_ds1edit.screen_buff, tmp_bmp, mx - glb_ds1edit.win_preview.x0, y1);
            }
        }
    }
}


// ==========================================================================
// draw wall layer
void wpreview_draw_w(int ds1_idx, int x, int y, int mx, int my, int z, int selected, int upper)
{
    BLOCK_TABLE_S * bt_ptr;
    BITMAP        * tmp_bmp;
    CELL_W_S      * w_ptr;
    int           n, t, bt_idx, dt1_idx, block_idx, m, s, y1;
    int           done, found, o, color;
    ORDER_DATA_S  order_data[4];
    int           dist, c1=0, c2=0;
    int           ux1, ux2, ux3, ux4, uy1, uy2, uy3;


    t     = (y * glb_ds1[ds1_idx].wall_line) + (x * glb_ds1[ds1_idx].wall_num);
    w_ptr = glb_ds1[ds1_idx].wall_buff + t;

    for (n=0; n<glb_ds1[ds1_idx].wall_num; n++) {
        order_data[n].idx    = n;
        order_data[n].height = w_ptr[n].prop1;

        //typedef struct ORDER_DATA_S
        //{
        //   int idx;
        //   int height;
        //} ORDER_DATA_S;
        //ø…º˚255“≤≤ª «heightµƒ◊Ó¥Û÷µµƒ~∏„≤ª√˜∞◊¡À

        if (w_ptr[n].orientation == 10) {
            order_data[n].height = 255;
        }
    }
    // qsort_helper_order_data÷–:
    // return o1->height - o2->height;
    // ø…º˚≈≈–Úªπ «“ªæ‰height¿¥µƒ
    // ªπ”–“ª∏ˆ, ∞¥¿ÌÀµwall¿‡–Õ“≤æÕ÷ª–Ë“™≈≈“ª¥Œ µ´ «’‚¿Ôø¥¿¥ «√ø¥Œµ˜”√’‚∏ˆ∫Ø ˝∂ºª·±ª≈≈¡–“ª¥Œ
    //  «≤ª «”–Œﬁ”√π¶¡À..ªπ «≈¬÷–Õæ”–∏¸–¬???
    qsort(order_data, glb_ds1[ds1_idx].wall_num, sizeof(ORDER_DATA_S), qsort_helper_order_data);

    for (n=0; n<glb_ds1[ds1_idx].wall_num; n++) {
        color = -1;
        if (glb_ds1[ds1_idx].wall_layer_mask[order_data[n].idx] == 0){
            continue;
        }

        //#define FLG_HIDE          2
        //#define IS_HIDE(x)        ((x) & FLG_HIDE)

        if (IS_HIDE(w_ptr[order_data[n].idx].flags)){
            continue;
        }

        // draw only lower or upper wall, according to 'upper' param

        //      orientation == 0    :   floor
        //      orientation == 13   :   shadow
        //      ∆‰À˚∂º «wall,’‚∆‰÷–:
        //          orientation == 10 || 11 :   special
        //          orientation == 15       :   roof
        //              ≤ª Ù”⁄“‘…œ∏˜¿‡, µ´ «:
        //                  orientation < 15    :   wall up
        //                  orientation > 15    :   wall down

        o = w_ptr[order_data[n].idx].orientation;
        //’‚¡Ω∏ˆæÕ «ºÏ≤‚“ªœ¬, »Áπ˚>=15 ±ÿ»ªŒ™downwall,’‚ ±∫Ú»Áπ˚ «upper
        //æÕ√ª”–±ÿ“™ª≠¡À..œ¬“ª∏ˆÕ¨¿Ì
        if ((upper == TRUE) && (o >= 15)) {
            continue;
        }
        if ((upper == FALSE) && (o <= 15)) {
            continue;
        }

        //w_ptr = glb_ds1[ds1_idx].wall_buff + t;
        //¥”’‚¿Ôø…“‘ø¥≥ˆwall_buffµƒ≈≈¡–∑Ω Ω
        //4∏ˆwall_num
        //∞¥’’[0][1][2][3][0][1][2][3][0][1][2][3][0][1][2][3]....’‚—˘¬÷¥Œ≈≈◊≈µƒ..’‚—˘≤≈ƒ‹œÒœ¬√Ê“ª––’‚—˘—∞÷∑
        bt_idx = w_ptr[order_data[n].idx].bt_idx; // index in block table

        // no tiles here
        if (bt_idx == 0){
            continue;
        }

        // special tile asked to draw later
        if (glb_ds1[ds1_idx].special_layer_mask && ((o == 10) || (o == 11))) {
            continue;
        }

        //prop4÷∏ æµƒ «visiablity√¥?
        // binary : 0b1000,0000
        if (w_ptr[order_data[n].idx].prop4 & 0x80) {
            // hidden
            if ((o != 10) && (o != 11)) {
                bt_idx = -1; // a hidden floor --> "unknown"
            }
        }

        if (bt_idx == -1) {
            ux1 = mx - glb_ds1edit.win_preview.x0;
            ux2 = ux1 + glb_ds1[ds1_idx].tile_w / 2 - 1;
            ux3 = ux1 + glb_ds1[ds1_idx].tile_w / 2;
            ux4 = ux1 + glb_ds1[ds1_idx].tile_w - 1;

            uy1 = my - glb_ds1edit.win_preview.y0;
            uy2 = uy1 + glb_ds1[ds1_idx].tile_h / 2 - 1;
            uy3 = uy1 + glb_ds1[ds1_idx].tile_h - 2;

            line(glb_ds1edit.screen_buff, ux1, uy2, ux2, uy1, 168);
            line(glb_ds1edit.screen_buff, ux3, uy1, ux4, uy2, 168);
            line(glb_ds1edit.screen_buff, ux3, uy3, ux4, uy2, 168);
            line(glb_ds1edit.screen_buff, ux1, uy2, ux2, uy3, 168);

            if (glb_ds1[ds1_idx].cur_zoom == ZM_11) {
                textprintf(glb_ds1edit.screen_buff, font, ux1+8, uy2-2, 0, "(%u) %u %u %u %u", w_ptr[order_data[n].idx].orientation, w_ptr[order_data[n].idx].prop1, w_ptr[order_data[n].idx].prop2, w_ptr[order_data[n].idx].prop3, w_ptr[order_data[n].idx].prop4);
                textprintf(glb_ds1edit.screen_buff, font, ux1+7, uy2-3, 255, "(%u) %u %u %u %u", w_ptr[order_data[n].idx].orientation, w_ptr[order_data[n].idx].prop1, w_ptr[order_data[n].idx].prop2, w_ptr[order_data[n].idx].prop3, w_ptr[order_data[n].idx].prop4);
            }
            continue;
        }

        //≤È±Ì≤È±Ì..æÕÀ˚ƒÔµƒ≤È±Ì
        bt_ptr = glb_ds1[ds1_idx].block_table + bt_idx; // pointer in block table
        // only walls or special tiles, but no roof
        if ( (bt_ptr->type != BT_WALL_UP)  && (bt_ptr->type != BT_WALL_DOWN) && (bt_ptr->type != BT_SPECIAL)){
            continue;
        }

        dt1_idx   = bt_ptr->dt1_idx;
        block_idx = bt_ptr->block_idx;

        //’‚∏ˆµÿ∑Ωµƒblock“—æ≠¥¶¿Ìπ˝¡À..≥…¡À“ª’≈Õº¡À...
        tmp_bmp = * (glb_dt1[dt1_idx].block_zoom[z] + block_idx);

        if (tmp_bmp == NULL) {
            continue;
        }

        y1 = my - glb_ds1edit.win_preview.y0 - bt_ptr->zero_line * glb_ds1[ds1_idx].height_mul / glb_ds1[ds1_idx].height_div;
        // walls are lower than floors (and than roofs) by 80 pixels
        // ◊˜’ﬂÀµµƒ¥Û∏≈ «’‚∏ˆ“‚Àº

        //                                      +---------------------+
        //                                      |                     |
        //                                      |      WALL           |
        //                                      |                     |
        //                                      |                     |
        //           +----------------+-------->+-   -   -   -/\      |
        //           | begin of tile  |   |     |           /    \    |
        //           +----------------+   |     |         /        \  |
        //                                |     |       /            \|
        //                              80px    |     /               |\
        //           +----------------+   |     |   /                 |  \
        //           | begin of wall  |   |     | /                   |    \
        //           +----------------+-------> *---------------------+     *
        //                                        \                        /
        //                                          \     FLOOR          /
        //                                            \                /
        //                                              \            /
        //                                                \        /
        //                                                  \    /
        //                                                    \/

        y1 += glb_ds1[ds1_idx].tile_h; 
        if ( (y1 + tmp_bmp->h) < 0) {
            continue;
        }
        if (y1 >= glb_ds1edit.win_preview.h) {
            continue;
        }

        if (glb_ds1edit.mode == MOD_L) {
            //MOD_L «‘⁄∞¥œ¬nµƒ ±∫Úµƒ◊¥Ã¨
            //æÕ «ƒ«∏ˆ’˚∏ˆª≠√ÊœÒ“ª∏ˆ ÷µÁÕ≤’’µΩ∫⁄Œ›◊”¿Ô√Êµƒ∏œΩ≈
            // c1
            //√ª”–Ω¯»Î’‚“ªøÈπ˛
            dist = wpreview_light_dist( mx, my + (glb_ds1[ds1_idx].tile_h / 2), glb_ds1edit.win_preview.x0 + mouse_x, glb_ds1edit.win_preview.y0 + mouse_y);
            //’‚ «∏ˆ…œœ¬Ωÿ∂œ∂¯“—
            if (dist < 200) {
                c1 = 255;
            } else if (dist > 500) {
                c1 = 0;
            } else {
                c1 = 255 - ((dist - 200) * 255 / (500 - 200));
            }

            // c2
            dist = wpreview_light_dist( mx + tmp_bmp->w, my + (glb_ds1[ds1_idx].tile_h / 2), glb_ds1edit.win_preview.x0 + mouse_x, glb_ds1edit.win_preview.y0 + mouse_y);
            if (dist < 200) {
                c2 = 255;
            } else if (dist > 500) {
                c2 = 0;
            } else {
                c2 = 255 - ((dist - 200) * 255 / (500 - 200));
            }

            // draw it
            wpreview_gouraud_w(tmp_bmp, mx - glb_ds1edit.win_preview.x0, y1, ds1_idx, c1, c2, c2, c1);
        }else{
            //Ω¯»Îµƒ «’‚“ªøÈ
            if (selected) {
                if (IS_COPY_INFO(w_ptr[order_data[n].idx].flags)) {
                    color = COL_PASTE_OK;
                    if (IS_COPY_STATE(w_ptr[order_data[n].idx].flags)) {
                        color = COL_PASTE_KO;
                    }
                } else if (IS_TMP_SELECT(w_ptr[order_data[n].idx].flags)) {
                    color = COL_TMPSEL_M;
                } else if (IS_SELECTED(w_ptr[order_data[n].idx].flags)) {
                    color = COL_WALL_M;
                } else {
                    color = COL_MOUSE;
                }
            } else {
                //“ª∞„Ω¯»Î’‚¿Ôπ˛


                //typedef enum COL_E
                //{
                //    COL_FLOOR    =  29, // dark  grey,   selected without mouse
                //    COL_FLOOR_M  =  32, // light grey,   selected with mouse
                //    COL_WALL     = 151, // dark  blue,   selected without mouse
                //    COL_WALL_M   = 162, // light blue,   selected with mouse
                //    COL_MOUSE    = 255, // white,        not selected, with mouse
                //    COL_TMPSEL   =  92, // orange,       left-click selection, without mouse
                //    COL_TMPSEL_M = 108, // orange,       left-click selection, with mouse
                //    COL_PASTE_OK = 132, // green,        no conflicts when pasting
                //    COL_PASTE_KO =  98, // red,          conflicts when pasting
                //    COL_SHADOW   = 168  // yellow        shadow easy to view
                //} COL_E; // tile's color index in color map

                if (IS_COPY_INFO(w_ptr[order_data[n].idx].flags)) {
                    color = COL_PASTE_OK;
                    if (IS_COPY_STATE(w_ptr[order_data[n].idx].flags)) {
                        color = COL_PASTE_KO;
                    }
                } else if (IS_TMP_SELECT(w_ptr[order_data[n].idx].flags)) {
                    color = COL_TMPSEL;
                } else if (IS_SELECTED(w_ptr[order_data[n].idx].flags)) {
                    color = COL_WALL;
                }
            }
            if (color != -1) {
                wpreview_shape(tmp_bmp, mx - glb_ds1edit.win_preview.x0, y1, ds1_idx, color);
            } else {
                draw_sprite(glb_ds1edit.screen_buff, tmp_bmp, mx - glb_ds1edit.win_preview.x0, y1);
            }
        }

        // upper-left corner
        // block∫Õwall∂º”–“ª∏ˆorientationµƒŒ Ã‚..≤ª÷™µ¿’‚¡Ω∏ˆ «∏ˆ ≤√¥πÿœµ
        // ’‚“ªøÈø¥≤ª∂Æ
        if (bt_ptr->orientation == 3) {
            // ƒ«∏ˆ¡‚–Œ
            // ◊Ûœ¬Œ™4, ”“œ¬Œ™3..ª˘±æ…œ
            // ’‚¡Ω∏ˆŒ™…∂“™Ãÿ±∂‘¥˝??????????????
            //  «ƒ«∏ˆ∏ﬂ¡¡—°÷–µƒ‘≠“Ú√¥?
            // search the o=4 m=m s=s
            m = bt_ptr->main_index;
            s = bt_ptr->sub_index;
            done = FALSE;
            found = FALSE;
            while( ! done) {
                // »Ù «‘ΩΩÁ∂¯√ª’“µΩ, ß∞‹
                // »Ù «…–Œ¥‘ΩΩÁ≤¢«“ orientation–°”⁄4, bt_idx÷∏œÚœ¬“ª∏ˆ
                // »Ù «µ»”⁄4,≤¢«“∆‰À˚–≈œ¢Œ«∫œ, nice, æÕ «À˚


                // ‘ΩΩÁ√ª
                if (bt_idx >= glb_ds1[ds1_idx].bt_num){
                    done = TRUE;
                }else{
                    bt_ptr++;
                    if (bt_ptr->orientation < 4){
                        //≤Èø¥œ¬“ª∏ˆ?why
                        bt_idx++;
                    }else{
                        //ƒ·¬Í’‚“ªøÈ «Œ™…Ò¬Ì∞°
                        if (bt_ptr->orientation == 4)
                            if ((bt_ptr->main_index == m) && (bt_ptr->sub_index == s))
                                done = found = TRUE;
                    }
                }
            }

            if (found == TRUE) {
                dt1_idx   = bt_ptr->dt1_idx;
                block_idx = bt_ptr->block_idx;
                tmp_bmp   = * (glb_dt1[dt1_idx].block_zoom[z] + block_idx);

                if (tmp_bmp == NULL) continue;

                y1 = my - glb_ds1edit.win_preview.y0 - bt_ptr->zero_line * glb_ds1[ds1_idx].height_mul / glb_ds1[ds1_idx].height_div;
                y1 += glb_ds1[ds1_idx].tile_h; // walls are lower than floors (and than roofs) by 80 pixels
                if ( (y1 + tmp_bmp->h) < 0)
                    continue;
                if (y1 >= glb_ds1edit.win_preview.h)
                    continue;

                if (glb_ds1edit.mode == MOD_L)
                {
                    wpreview_gouraud_w(tmp_bmp, mx - glb_ds1edit.win_preview.x0, y1, ds1_idx, c1, c2, c2, c1);
                }else{
                    if (color != -1){
                        wpreview_shape(tmp_bmp, mx - glb_ds1edit.win_preview.x0, y1, ds1_idx, color);
                    }else{
                        //¿¥π˝’‚¿Ô
                        draw_sprite(glb_ds1edit.screen_buff, tmp_bmp, mx - glb_ds1edit.win_preview.x0, y1);
                    }
                }
            }
        }
    }
}


// ==========================================================================
// draw roof layer
void wpreview_draw_r(int ds1_idx, int x, int y, int mx, int my, int z, int selected)
{
    BLOCK_TABLE_S * bt_ptr;
    BITMAP        * tmp_bmp;
    CELL_W_S      * r_ptr;
    int           n, t, bt_idx, dt1_idx, block_idx, y1, color;
    ORDER_DATA_S  order_data[4];


    t     = (y * glb_ds1[ds1_idx].wall_line) + (x * glb_ds1[ds1_idx].wall_num);
    // ø¥µΩ√ª”–, roof“≤‘⁄wall¿Ô√Ê∞¢
    r_ptr = glb_ds1[ds1_idx].wall_buff + t;

    for (n=0; n<glb_ds1[ds1_idx].wall_num; n++) {
        order_data[n].idx    = n;
        order_data[n].height = r_ptr[n].prop1;
    }
    qsort(order_data, glb_ds1[ds1_idx].wall_num, sizeof(ORDER_DATA_S), qsort_helper_order_data);

    for (n=0; n<glb_ds1[ds1_idx].wall_num; n++) {
        color = -1;
        if (glb_ds1[ds1_idx].wall_layer_mask[order_data[n].idx] == 0) {
            continue;
        }

        if (IS_HIDE(r_ptr[order_data[n].idx].flags)) {
            continue;
        }

        bt_idx = r_ptr[order_data[n].idx].bt_idx; // index in block table

        if (bt_idx <= 0) {
            // no tiles here
            continue;
        }

        if (r_ptr[order_data[n].idx].prop4 & 0x80) {
            // binary : 1000-0000
            bt_idx = -1; // consider this tile as "unknown"
        }

        if (bt_idx <= 0) {
            continue;
        }

        bt_ptr = glb_ds1[ds1_idx].block_table + bt_idx; // pointer in block table

        if (bt_ptr->type != BT_ROOF) {
            continue; // only roof
        }

        dt1_idx   = bt_ptr->dt1_idx;
        block_idx = bt_ptr->block_idx;

        tmp_bmp = * (glb_dt1[dt1_idx].block_zoom[z] + block_idx);

        if (tmp_bmp == NULL) {
            continue;
        }

        y1 = my - glb_ds1edit.win_preview.y0 - bt_ptr->zero_line * glb_ds1[ds1_idx].height_mul / glb_ds1[ds1_idx].height_div;

        // roof height
        y1 -= bt_ptr->roof_y * glb_ds1[ds1_idx].height_mul / glb_ds1[ds1_idx].height_div;

        if ( (y1 + tmp_bmp->h) < 0) {
            continue;
        }
        if (y1 >= glb_ds1edit.win_preview.h) {
            continue;
        }

        if (glb_ds1edit.mode == MOD_L) {
            // draw it
            if (glb_ds1edit.cmd_line.force_pal_num == -1) {
                color_map = & glb_ds1edit.cmap[CM_SHADOW][glb_ds1[ds1_idx].act - 1];
            } else {
                color_map = & glb_ds1edit.cmap[CM_SHADOW][glb_ds1edit.cmd_line.force_pal_num - 1];
            }
            draw_lit_sprite(glb_ds1edit.screen_buff, tmp_bmp, mx - glb_ds1edit.win_preview.x0, y1, 0);
        } else {
            if (selected) {
                if (IS_COPY_INFO(r_ptr[order_data[n].idx].flags)) {
                    color = COL_PASTE_OK;
                    if (IS_COPY_STATE(r_ptr[order_data[n].idx].flags)) {
                        color = COL_PASTE_KO;
                    }
                } else if (IS_TMP_SELECT(r_ptr[order_data[n].idx].flags)) {
                    color = COL_TMPSEL_M;
                } else if (IS_SELECTED(r_ptr[order_data[n].idx].flags)) {
                    color = COL_WALL_M;
                } else {
                    color = COL_MOUSE;
                }
            } else {
                if (IS_COPY_INFO(r_ptr[order_data[n].idx].flags)) {
                    color = COL_PASTE_OK;
                    if (IS_COPY_STATE(r_ptr[order_data[n].idx].flags)) {
                        color = COL_PASTE_KO;
                    }
                } else if (IS_TMP_SELECT(r_ptr[order_data[n].idx].flags)) {
                    color = COL_TMPSEL;
                } else if (IS_SELECTED(r_ptr[order_data[n].idx].flags)) {
                    color = COL_WALL;
                }
            }
            if (color != -1) {
                wpreview_shape(tmp_bmp, mx - glb_ds1edit.win_preview.x0, y1, ds1_idx, color);
            } else {
                draw_sprite(glb_ds1edit.screen_buff, tmp_bmp, mx - glb_ds1edit.win_preview.x0, y1);
            }
        }
    }
}


// ==========================================================================
// draw special tiles
void wpreview_draw_sp(int ds1_idx, int x, int y, int mx, int my, int z, int selected)
{
    BLOCK_TABLE_S * bt_ptr;
    BITMAP        * tmp_bmp;
    CELL_W_S      * w_ptr;
    int           n, t, bt_idx, dt1_idx, block_idx, y1, o;
    int           color;
    ORDER_DATA_S  order_data[4];
    int           dist, c1, c2;
    int           ux1, ux2, ux3, ux4, uy1, uy2, uy3;


    t     = (y * glb_ds1[ds1_idx].wall_line) + (x * glb_ds1[ds1_idx].wall_num);
    w_ptr = glb_ds1[ds1_idx].wall_buff + t;

    for (n=0; n<glb_ds1[ds1_idx].wall_num; n++) {
        order_data[n].idx    = n;
        order_data[n].height = w_ptr[n].prop1;
        if (w_ptr[n].orientation == 10) {
            order_data[n].height = 255;
        }
    }
    qsort(order_data, glb_ds1[ds1_idx].wall_num, sizeof(ORDER_DATA_S), qsort_helper_order_data);

    for (n=0; n<glb_ds1[ds1_idx].wall_num; n++) {
        color = -1;
        if (glb_ds1[ds1_idx].wall_layer_mask[order_data[n].idx] == 0) {
            continue;
        }

        if (IS_HIDE(w_ptr[order_data[n].idx].flags)) {
            continue;
        }

        bt_idx = w_ptr[order_data[n].idx].bt_idx; // index in block table

        if (bt_idx == 0) {
            // no tile here
            continue;
        }

        o = w_ptr[order_data[n].idx].orientation;

        if ((o != 10) && (o != 11)) {
            // not a special tile
            continue;
        } else {
            // special tile

            if (bt_idx <= 0) {
                // unknown special tile
                ux1 = mx - glb_ds1edit.win_preview.x0;
                ux2 = ux1 + glb_ds1[ds1_idx].tile_w / 2 - 1;
                ux3 = ux1 + glb_ds1[ds1_idx].tile_w / 2;
                ux4 = ux1 + glb_ds1[ds1_idx].tile_w - 1;

                uy1 = my - glb_ds1edit.win_preview.y0;
                uy2 = uy1 + glb_ds1[ds1_idx].tile_h / 2 - 1;
                uy3 = uy1 + glb_ds1[ds1_idx].tile_h - 2;

                line(glb_ds1edit.screen_buff, ux1, uy2, ux2, uy1, 168);
                line(glb_ds1edit.screen_buff, ux3, uy1, ux4, uy2, 168);
                line(glb_ds1edit.screen_buff, ux3, uy3, ux4, uy2, 168);
                line(glb_ds1edit.screen_buff, ux1, uy2, ux2, uy3, 168);

                if (glb_ds1[ds1_idx].cur_zoom == ZM_11) {
                    textprintf(glb_ds1edit.screen_buff, font, ux1+8, uy2-2, 0, "(%u) %u %u %u %u", w_ptr[order_data[n].idx].orientation, w_ptr[order_data[n].idx].prop1, w_ptr[order_data[n].idx].prop2, w_ptr[order_data[n].idx].prop3, w_ptr[order_data[n].idx].prop4);
                    textprintf(glb_ds1edit.screen_buff, font, ux1+7, uy2-3, 255, "(%u) %u %u %u %u", w_ptr[order_data[n].idx].orientation, w_ptr[order_data[n].idx].prop1, w_ptr[order_data[n].idx].prop2, w_ptr[order_data[n].idx].prop3, w_ptr[order_data[n].idx].prop4);
                }
                continue;
            }
        }

        bt_ptr    = glb_ds1[ds1_idx].block_table + bt_idx; // pointer in block table
        dt1_idx   = bt_ptr->dt1_idx;
        block_idx = bt_ptr->block_idx;

        tmp_bmp = * (glb_dt1[dt1_idx].block_zoom[z] + block_idx);

        if (tmp_bmp == NULL) {
            continue;
        }

        y1 = my - glb_ds1edit.win_preview.y0 - bt_ptr->zero_line * glb_ds1[ds1_idx].height_mul / glb_ds1[ds1_idx].height_div;
        y1 += glb_ds1[ds1_idx].tile_h; // walls are lower than floors (and than roofs) by 80 pixels
        if ( (y1 + tmp_bmp->h) < 0) {
            continue;
        }
        if (y1 >= glb_ds1edit.win_preview.h) {
            continue;
        }

        if (glb_ds1edit.mode == MOD_L) {
            // c1
            dist = wpreview_light_dist( mx, my + (glb_ds1[ds1_idx].tile_h / 2), glb_ds1edit.win_preview.x0 + mouse_x, glb_ds1edit.win_preview.y0 + mouse_y);
            if (dist < 200) {
                c1 = 255;
            } else if (dist > 500) {
                c1 = 0;
            } else {
                c1 = 255 - ((dist - 200) * 255 / (500 - 200));
            }

            // c2
            dist = wpreview_light_dist( mx + tmp_bmp->w, my + (glb_ds1[ds1_idx].tile_h / 2), glb_ds1edit.win_preview.x0 + mouse_x, glb_ds1edit.win_preview.y0 + mouse_y);
            if (dist < 200) {
                c2 = 255;
            } else if (dist > 500) {
                c2 = 0;
            } else {
                c2 = 255 - ((dist - 200) * 255 / (500 - 200));
            }

            // draw it
            wpreview_gouraud_w(tmp_bmp, mx - glb_ds1edit.win_preview.x0, y1, ds1_idx, c1, c2, c2, c1);
        } else {
            if (selected) {
                if (IS_COPY_INFO(w_ptr[order_data[n].idx].flags)) {
                    color = COL_PASTE_OK;
                    if (IS_COPY_STATE(w_ptr[order_data[n].idx].flags)) {
                        color = COL_PASTE_KO;
                    }
                } else if (IS_TMP_SELECT(w_ptr[order_data[n].idx].flags)) {
                    color = COL_TMPSEL_M;
                } else if (IS_SELECTED(w_ptr[order_data[n].idx].flags)) {
                    color = COL_WALL_M;
                } else {
                    color = COL_MOUSE;
                }
            } else {
                if (IS_COPY_INFO(w_ptr[order_data[n].idx].flags)) {
                    color = COL_PASTE_OK;
                    if (IS_COPY_STATE(w_ptr[order_data[n].idx].flags)) {
                        color = COL_PASTE_KO;
                    }
                } else if (IS_TMP_SELECT(w_ptr[order_data[n].idx].flags)) {
                    color = COL_TMPSEL;
                } else if (IS_SELECTED(w_ptr[order_data[n].idx].flags)) {
                    color = COL_WALL;
                }
            }
            if (color != -1) {
                wpreview_shape(tmp_bmp, mx - glb_ds1edit.win_preview.x0, y1, ds1_idx, color);
            } else {
                draw_sprite(glb_ds1edit.screen_buff, tmp_bmp, mx - glb_ds1edit.win_preview.x0, y1);
            }
        }
    }
}


// ==========================================================================
// which tile (or sub-tile) is at this coordinates ?
void coord_to_tile(int ds1_idx, int ax, int ay, int * layer_x, int * layer_y)
{
    int bx, by, cx, cy, rx, ry;

    // ax & ay adjustement, depending of the current mode
    if ( (glb_ds1edit.mode == MOD_O) || (glb_ds1edit.mode == MOD_P) || (glb_ds1edit.mode == MOD_L) ) {
        ax *= 5;
        ay *= 5;
    }

    // negative tile coordinates adjustment
    if (ax < 0) {
        ax -= glb_ds1[ds1_idx].tile_w;
    }
    if (ay < 0) {
        ay -= glb_ds1[ds1_idx].tile_h;
    }

    // search the Major tile's Coordinates
    bx = ax / glb_ds1[ds1_idx].tile_w;
    by = ay / glb_ds1[ds1_idx].tile_h;
    cx = bx  + by;
    cy = -bx + by;

    // fine adjustements (Minor tile's Coordinates)
    rx = ax % glb_ds1[ds1_idx].tile_w;
    ry = ay % glb_ds1[ds1_idx].tile_h;
    if (ax < 0){
        rx = glb_ds1[ds1_idx].tile_w + rx;
    }
    if (ay < 0){
        ry = glb_ds1[ds1_idx].tile_h + ry;
    }

    if (ry >= -rx / 2 + glb_ds1[ds1_idx].tile_w/2 + glb_ds1[ds1_idx].tile_h/2){
        cx++;
    } else if (ry < -rx / 2 + glb_ds1[ds1_idx].tile_h/2) {
        cx--;
    } else if (glb_ds1[ds1_idx].tile_w/2 - ry >= -rx / 2 + glb_ds1[ds1_idx].tile_w/2 + glb_ds1[ds1_idx].tile_h/2){
        cy--;
    } else if (glb_ds1[ds1_idx].tile_w/2 - ry < -rx / 2 + glb_ds1[ds1_idx].tile_h/2) {
        cy++;
    }

    // end
    * layer_x = cx;
    * layer_y = cy;
}


// ==========================================================================
// which tile (or sub-tile) is under the mouse ?
void mouse_to_tile(int ds1_idx, int * layer_x, int * layer_y)
{
    int ax, ay;

    // tile under mouse
    ax = glb_ds1edit.win_preview.x0 + mouse_x;
    ay = glb_ds1edit.win_preview.y0 + mouse_y;

    coord_to_tile(ds1_idx, ax, ay, layer_x, layer_y);
}


// ==========================================================================
// as expected, change zoom of 1 ds1
void change_zoom(int ds1_idx, ZOOM_E z)
{
    int mul, div, dx, dy, cx, cy;

    if (z < ZM_11){
        z = ZM_11;
    }else if (z > ZM_116){
        z = ZM_116;
    }

    dx = glb_ds1[ds1_idx].own_wpreview.x0 + glb_ds1[ds1_idx].own_wpreview.w / 2;
    dy = glb_ds1[ds1_idx].own_wpreview.y0 + glb_ds1[ds1_idx].own_wpreview.h / 2;

    // which tile (or sub-tile) is at this coordinates ?
    coord_to_tile(ds1_idx, dx, dy, &cx, &cy);
    cx++; // don't know why, but it is needed to keep the zoom centered

    switch(z){
        case ZM_11  : mul = 1, div =  1;  break;
        case ZM_12  : mul = 1, div =  2;  break;
        case ZM_14  : mul = 1, div =  4;  break;
        case ZM_18  : mul = 1, div =  8;  break;
        case ZM_116 : mul = 1, div = 16;  break;
        default     : mul = 1, div =  1;  break;
    }

    glb_ds1[ds1_idx].cur_zoom   = z;
    glb_ds1[ds1_idx].height_mul = mul;
    glb_ds1[ds1_idx].height_div = div;
    glb_ds1[ds1_idx].tile_w     = 160 * mul / div;
    glb_ds1[ds1_idx].tile_h     = 80 * mul / div;
    if (glb_config.lower_speed_zoom_out){
        glb_ds1[ds1_idx].cur_scroll.keyb.x = glb_config.scroll.keyb.x * mul / div;
        glb_ds1[ds1_idx].cur_scroll.keyb.y = glb_config.scroll.keyb.y * mul / div;
        glb_ds1[ds1_idx].cur_scroll.mouse.x = glb_config.scroll.mouse.x * mul / div;
        glb_ds1[ds1_idx].cur_scroll.mouse.y = glb_config.scroll.mouse.y * mul / div;
    }

    if (glb_ds1edit.mode == MOD_T){
        //’‚ÕÊ“‚∂˘æÕ «“ª∏ˆ–±±‰ªª, ∞—tileµƒ–™◊≈º∆ ˝∑Ω Ω±‰ªªµΩ’˝≥£º∆À„∑Ω Ω
        dx = (cy * -glb_ds1[ds1_idx].tile_w / 2) + (cx * glb_ds1[ds1_idx].tile_w / 2);
        dy = (cy *  glb_ds1[ds1_idx].tile_h / 2) + (cx * glb_ds1[ds1_idx].tile_h / 2);
    }
    else
    {
        dx = (cy * -glb_ds1[ds1_idx].tile_w / 10) + (cx * glb_ds1[ds1_idx].tile_w / 10);
        dy = (cy *  glb_ds1[ds1_idx].tile_h / 10) + (cx * glb_ds1[ds1_idx].tile_h / 10);
    }

    glb_ds1[ds1_idx].own_wpreview.x0 = dx - glb_ds1[ds1_idx].own_wpreview.w / 2;
    glb_ds1[ds1_idx].own_wpreview.y0 = dy - glb_ds1[ds1_idx].own_wpreview.h / 2;
}


// ==========================================================================
// draw paths lines
void wpreview_draw_paths(int ds1_idx)
{
    int x, y, dx, dy, o, p, x1, y1, x2, y2, color1, color2;

    for (o=0; o < glb_ds1[ds1_idx].obj_num; o++) {
        if (glb_ds1[ds1_idx].obj[o].path_num == 0) {
            continue;
        }

        // color of path lines
        if (IS_SELECTED(glb_ds1[ds1_idx].obj[o].flags) || IS_SELECTED(glb_ds1[ds1_idx].obj[o].label.flags)) {
            color1 = 255; // white
            color2 =  10; // dark red
        } else {
            color1 = 219; // gray
            color2 = 155; // dark magenta
        }

        // npc position to 1st path
        if (glb_ds1[ds1_idx].obj[o].path_num) {
            // 1st point
            x = glb_ds1[ds1_idx].obj[o].x;
            y = glb_ds1[ds1_idx].obj[o].y;

            dx = ((y-2) * -glb_ds1[ds1_idx].tile_w / 10) + ((x+3) * glb_ds1[ds1_idx].tile_w / 10);
            dy = ((y-2) *  glb_ds1[ds1_idx].tile_h / 10) + ((x+3) * glb_ds1[ds1_idx].tile_h / 10);

            x1 = dx - glb_ds1edit.win_preview.x0;
            y1 = dy - glb_ds1edit.win_preview.y0 - 1;

            // 2nd point
            x = glb_ds1[ds1_idx].obj[o].path[0].x;
            y = glb_ds1[ds1_idx].obj[o].path[0].y;

            dx = ((y-2) * -glb_ds1[ds1_idx].tile_w / 10) + ((x+3) * glb_ds1[ds1_idx].tile_w / 10);
            dy = ((y-2) *  glb_ds1[ds1_idx].tile_h / 10) + ((x+3) * glb_ds1[ds1_idx].tile_h / 10);

            x2 = dx - glb_ds1edit.win_preview.x0;
            y2 = dy - glb_ds1edit.win_preview.y0 - 1;

            // line
            line(glb_ds1edit.screen_buff, x1+1, y1+1, x2+1, y2+1, 0);
            line(glb_ds1edit.screen_buff, x1, y1, x2, y2, color1);
        }

        // paths
        for (p=0; p < glb_ds1[ds1_idx].obj[o].path_num; p++) {
            // 1st point
            x = glb_ds1[ds1_idx].obj[o].path[p].x;
            y = glb_ds1[ds1_idx].obj[o].path[p].y;

            dx = ((y-2) * -glb_ds1[ds1_idx].tile_w / 10) + ((x+3) * glb_ds1[ds1_idx].tile_w / 10);
            dy = ((y-2) *  glb_ds1[ds1_idx].tile_h / 10) + ((x+3) * glb_ds1[ds1_idx].tile_h / 10);

            x1 = dx - glb_ds1edit.win_preview.x0;
            y1 = dy - glb_ds1edit.win_preview.y0 - 1;

            // 2nd point
            if (p == glb_ds1[ds1_idx].obj[o].path_num - 1) {
                x = glb_ds1[ds1_idx].obj[o].path[0].x;
                y = glb_ds1[ds1_idx].obj[o].path[0].y;
            } else {
                x = glb_ds1[ds1_idx].obj[o].path[p + 1].x;
                y = glb_ds1[ds1_idx].obj[o].path[p + 1].y;
            }

            dx = ((y-2) * -glb_ds1[ds1_idx].tile_w / 10) + ((x+3) * glb_ds1[ds1_idx].tile_w / 10);
            dy = ((y-2) *  glb_ds1[ds1_idx].tile_h / 10) + ((x+3) * glb_ds1[ds1_idx].tile_h / 10);

            x2 = dx - glb_ds1edit.win_preview.x0;
            y2 = dy - glb_ds1edit.win_preview.y0 - 1;

            // line
            line(glb_ds1edit.screen_buff, x1+1, y1+1, x2+1, y2+1, 0);
            line(glb_ds1edit.screen_buff, x1, y1, x2, y2, color2);

            // big point
            rectfill(glb_ds1edit.screen_buff, x1, y1, x1+2, y1+2, 0);
            rectfill(glb_ds1edit.screen_buff, x1-1, y1-1, x1+1, y1+1, 157);
        }
    }
}


// ==========================================================================
// draw paths lines of 1 object
void wpreview_draw_paths_1obj(int ds1_idx, int o)
{
    int x, y, dx, dy, p, x1, y1, x2, y2, color;


    if ((o < 0) || (o >= glb_ds1[ds1_idx].current_obj_max)) {
        return;
    }

    if (glb_ds1[ds1_idx].obj[o].path_num == 0) {
        return;
    }

    // npc position to 1st path
    if (glb_ds1[ds1_idx].obj[o].path_num) {
        // 1st point
        x = glb_ds1[ds1_idx].obj[o].x;
        y = glb_ds1[ds1_idx].obj[o].y;

        dx = ((y-2) * -glb_ds1[ds1_idx].tile_w / 10) + ((x+3) * glb_ds1[ds1_idx].tile_w / 10);
        dy = ((y-2) *  glb_ds1[ds1_idx].tile_h / 10) + ((x+3) * glb_ds1[ds1_idx].tile_h / 10);

        x1 = dx - glb_ds1edit.win_preview.x0;
        y1 = dy - glb_ds1edit.win_preview.y0 - 1;

        // 2nd point
        x = glb_ds1[ds1_idx].obj[o].path[0].x;
        y = glb_ds1[ds1_idx].obj[o].path[0].y;

        dx = ((y-2) * -glb_ds1[ds1_idx].tile_w / 10) + ((x+3) * glb_ds1[ds1_idx].tile_w / 10);
        dy = ((y-2) *  glb_ds1[ds1_idx].tile_h / 10) + ((x+3) * glb_ds1[ds1_idx].tile_h / 10);

        x2 = dx - glb_ds1edit.win_preview.x0;
        y2 = dy - glb_ds1edit.win_preview.y0 - 1;

        // line
        color = 219; // grey
        line(glb_ds1edit.screen_buff, x1+1, y1+1, x2+1, y2+1, 0);
        line(glb_ds1edit.screen_buff, x1, y1, x2, y2, color);
    }

    // paths
    for (p=0; p < glb_ds1[ds1_idx].obj[o].path_num; p++) {
        // 1st point
        x = glb_ds1[ds1_idx].obj[o].path[p].x;
        y = glb_ds1[ds1_idx].obj[o].path[p].y;

        dx = ((y-2) * -glb_ds1[ds1_idx].tile_w / 10) + ((x+3) * glb_ds1[ds1_idx].tile_w / 10);
        dy = ((y-2) *  glb_ds1[ds1_idx].tile_h / 10) + ((x+3) * glb_ds1[ds1_idx].tile_h / 10);

        x1 = dx - glb_ds1edit.win_preview.x0;
        y1 = dy - glb_ds1edit.win_preview.y0 - 1;

        // 2nd point
        if (p == glb_ds1[ds1_idx].obj[o].path_num - 1) {
            x = glb_ds1[ds1_idx].obj[o].path[0].x;
            y = glb_ds1[ds1_idx].obj[o].path[0].y;
        } else {
            x = glb_ds1[ds1_idx].obj[o].path[p + 1].x;
            y = glb_ds1[ds1_idx].obj[o].path[p + 1].y;
        }

        dx = ((y-2) * -glb_ds1[ds1_idx].tile_w / 10) + ((x+3) * glb_ds1[ds1_idx].tile_w / 10);
        dy = ((y-2) *  glb_ds1[ds1_idx].tile_h / 10) + ((x+3) * glb_ds1[ds1_idx].tile_h / 10);

        x2 = dx - glb_ds1edit.win_preview.x0;
        y2 = dy - glb_ds1edit.win_preview.y0 - 1;

        // line
        color = 155; // dark magenta
        line(glb_ds1edit.screen_buff, x1+1, y1+1, x2+1, y2+1, 0);
        line(glb_ds1edit.screen_buff, x1, y1, x2, y2, color);

        // big point
        rectfill(glb_ds1edit.screen_buff, x1, y1, x1+2, y1+2, 0);
        rectfill(glb_ds1edit.screen_buff, x1-1, y1-1, x1+1, y1+1, 157);
    }
}


// ==========================================================================
void wpreview_obj_animate(void)
{
    TXT_S     * txt = glb_ds1edit.obj_buff;
    COF_S     * cof;
    int       o;
    long      n, nb_ticks = glb_ds1edit.ticks_elapsed;


    glb_ds1edit.ticks_elapsed = 0;

    if (txt == NULL) {
        return;
    }

    // search frame number to draw for all TYPE of object
    for (o=0; o < txt->line_num; o++) {
        if (glb_ds1edit.obj_desc[o].usage_count) {
            cof = glb_ds1edit.obj_desc[o].cof;
            if (cof == NULL) {
                continue;
            }
            if (cof->fpd == 0) {
                continue;
            }
            if (cof->spd_div == 0) {
                continue;
            }

            //typedef struct COF_S
            //{
            //   UBYTE     lay;
            //   UBYTE     fpd; // frames per direction
            //   UBYTE     dir;
            //   long      xoffset;
            //   long      yoffset;
            //   LAY_INF_S lay_inf[COMPOSIT_NB];
            //   UBYTE     * priority;
            //   long      cur_frame;
            //   int       cur_dir;
            //   long      spd_mul;
            //   long      spd_div;
            //   long      spd_mod; // = is (mul % div), for extra precision
            //   long      orderflag; // from data\global\excel\objects.txt, 0 1 or 2
            //} COF_S;
            //

            //   long      n, nb_ticks = glb_ds1edit.ticks_elapsed;
            //   nb_ticks Àµ∞◊¡ÀæÕ «»´æ÷±‰¡øµƒøΩ±¥
            //
            // default animation speed
            // animation speed, Àµ∞◊¡ÀæÕ «÷°º‰≤Ó
            //√ø√Î÷”25∏ˆclick
            //cof->spd_mul = 1;
            //cof->spd_div = 256;

            //   long      n, nb_ticks = glb_ds1edit.ticks_elapsed;
            //   glb_ds1edit.ticks_elapsed = 0;
            //’‚¡Ωæ‰...nb_ticksæÕ «…œ“ª¥Œµ˜”√’‚∏ˆ∫Ø ˝∫Õ’‚“ª¥Œµ˜”√’‚∏ˆ∫Ø ˝÷Æº‰º‰∏Ùµƒticks ˝ƒø
            //∂¯≤ª «¿˙ ∑…œÀ˘”–µƒticks
            //◊¢“‚’‚∏ˆ≥Ã–Ú «√ª”–cpu π”√¬ øÿ÷∆µƒ

            //n=384, mul=176, div=256, frame_increasement=1
            //n=256, mul=256, div=256, frame_increasement=1
            //n=160, mul=140, div=256, frame_increasement=0
            //n=224, mul=100, div=256, frame_increasement=0
            //n=256, mul=160, div=256, frame_increasement=1
            //n=256, mul=128, div=256, frame_increasement=1
            //n=256, mul=128, div=256, frame_increasement=1
            //n=512, mul=256, div=256, frame_increasement=2
            //n=352, mul=112, div=256, frame_increasement=1
            //n=400, mul=104, div=256, frame_increasement=1
            //n=480, mul=176, div=256, frame_increasement=1
            //n=512, mul=256, div=256, frame_increasement=2
            //n=440, mul=140, div=256, frame_increasement=1
            //n=424, mul=100, div=256, frame_increasement=1

            //soga Œ“∂Æ¡À~
            //À‰»ª√ª”–¥Ê¥¢¥”ø™ ºµΩœ÷‘⁄µƒÀ˘”–µƒ ±º‰(œÒŒ““‘«∞ƒ«—˘)
            //µ´ «À˚’‚¿Ô¥Ê¥¢¡À“ª∏ˆƒ£÷µ(%),∂‘÷‹∆⁄»°ƒ£
            //À˘“‘Ω·π˚ «“ª—˘µƒ, ªπ≤ª”√µ£–ƒ“Á≥ˆŒ Ã‚
            //ø¥∆¿¥nb_ticksŒ™…œ“ª¥Œµ˜”√∫Õ’‚“ª¥Œµ˜”√÷Æº‰µƒ≤Ó÷µ,  µº Õ≥º∆¡À¥”ø™ ºµΩœ÷‘⁄µƒÀ˘”– ±º‰ticks,‘Ÿ∂‘÷‹∆⁄»°ƒ£¡À∂¯“—
            //÷‹∆⁄ «cof->fpd...‡≈
            n = nb_ticks * cof->spd_mul + cof->spd_mod;
            cof->cur_frame += n / cof->spd_div;
            //printf("n=%d, mul=%d, div=%d, frame_increasement=%d\n",n,cof->spd_mul,cof->spd_div,n/cof->spd_div);
            cof->spd_mod    = n % cof->spd_div;
            //’‚∏ˆµÿ∑Ω∏…¬Ô≤ª»°ƒ£, ∂¯ «’‚√¥∏„?
            while (cof->cur_frame >= cof->fpd) {
                cof->cur_frame -= cof->fpd;
            }
        }
    }
}


// ==========================================================================
// draw objects while in Tile mode (just simple text)
void wpreview_draw_objects(int ds1_idx)
{
    int  dx, dy, o, x1, y1, d;
    long type, id, x, y;


    for (o=0; o < glb_ds1[ds1_idx].obj_num; o++) {
        type = glb_ds1[ds1_idx].obj[o].type;
        id   = glb_ds1[ds1_idx].obj[o].id;
        x    = glb_ds1[ds1_idx].obj[o].x;
        y    = glb_ds1[ds1_idx].obj[o].y;
        d    = glb_ds1[ds1_idx].obj[o].desc_idx;

        dx = ((y-2) * -glb_ds1[ds1_idx].tile_w / 10) + ((x+3) * glb_ds1[ds1_idx].tile_w / 10);
        dy = ((y-2) *  glb_ds1[ds1_idx].tile_h / 10) + ((x+3) * glb_ds1[ds1_idx].tile_h / 10);

        if (glb_ds1[ds1_idx].objects_layer_mask == OL_DESC) {
            // draw name, except if "?"
            if (d != -1) {
                if (glb_ds1edit.obj_desc[d].desc[0] == '?') {
                    d = -1;
                } else {
                    // draw name
                    x1 = dx - glb_ds1edit.win_preview.x0 - (8 * strlen(glb_ds1edit.obj_desc[d].desc) / 2);
                    y1 = dy - glb_ds1edit.win_preview.y0 - 4;

                    textprintf(glb_ds1edit.screen_buff, font, x1+1, y1+1, 0, "%s", glb_ds1edit.obj_desc[d].desc);
                    textprintf(glb_ds1edit.screen_buff, font, x1, y1, 255, "%s", glb_ds1edit.obj_desc[d].desc);
                }
            }
        }

        if ((glb_ds1[ds1_idx].objects_layer_mask == OL_TYPEID) || (d == -1)) {
            // draw Type-Id
            x1 = dx - glb_ds1edit.win_preview.x0 - 20;
            y1 = dy - glb_ds1edit.win_preview.y0 - 4;

            textprintf(glb_ds1edit.screen_buff, font, x1+1, y1+1, 0, "%i,%3i", glb_ds1[ds1_idx].obj[o].type, glb_ds1[ds1_idx].obj[o].id);
            textprintf(glb_ds1edit.screen_buff, font, x1, y1, 11, "%i", glb_ds1[ds1_idx].obj[o].type);
            textprintf(glb_ds1edit.screen_buff, font, x1+8, y1, 255, ",%3i", glb_ds1[ds1_idx].obj[o].id);
        }
    }
}


// ==========================================================================
// draw simple walkable infos of 1 cell (only walk & jump infos)
void wpreview_draw_simple_wi(int mx, int my, int z, UBYTE * walkinfo)
{
    int i;

    for (i=0; i<25; i++) {
        if (walkinfo[i] & 0x04) {
            draw_rle_sprite(glb_ds1edit.screen_buff, glb_ds1edit.subtile_nojump[z][i], mx - glb_ds1edit.win_preview.x0, my - glb_ds1edit.win_preview.y0);
        } else if (walkinfo[i] & 0x09) {
            draw_rle_sprite(glb_ds1edit.screen_buff, glb_ds1edit.subtile_nowalk[z][i], mx - glb_ds1edit.win_preview.x0, my - glb_ds1edit.win_preview.y0);
        }
    }
}


// ==========================================================================
// draw accurate walkable infos of 1 cell (all flags appear)
void wpreview_draw_wi(int mx, int my, int z, UBYTE * walkinfo)
{
    int i;

    for (i=0; i<25; i++) {
        if (walkinfo[i]) {
            draw_rle_sprite( glb_ds1edit.screen_buff, glb_ds1edit.subtile_flag_combination[walkinfo[i]][z][i], mx - glb_ds1edit.win_preview.x0, my - glb_ds1edit.win_preview.y0);
        }
    }
}


// ==========================================================================
void wpreview_draw_an_object(int ds1_idx, int o)
{
    COF_S     * cof;
    LAY_INF_S * lay;
    BITMAP    ** bmp_ptr, * bmp;
    int       c, f, x, y, d, dx0, dy0, dx, dy, p, col_black, col_white;
    UBYTE     * bptr;
    UBYTE     new_frame;


    d = glb_ds1[ds1_idx].obj[o].desc_idx;

    if (d == -1) {
        return;
    }

    if (glb_ds1edit.obj_desc[d].usage_count == 0) {
        return;
    }

    cof = glb_ds1edit.obj_desc[d].cof;
    if (cof == NULL) {
        return;
    }
    if (cof->fpd == 0) {
        return;
    }

    // random starting animation frame
    //UBYTE       frame_delta;
    new_frame = cof->cur_frame + glb_ds1[ds1_idx].obj[o].frame_delta;
    while (new_frame >= cof->fpd) {
        new_frame -= cof->fpd;
    }

    x   = glb_ds1[ds1_idx].obj[o].x;
    y   = glb_ds1[ds1_idx].obj[o].y;
    dx0 = ((y-2) * -glb_ds1[ds1_idx].tile_w / 10) + ((x+3) * glb_ds1[ds1_idx].tile_w / 10);
    dy0 = 4 + ((y-2) *  glb_ds1[ds1_idx].tile_h / 10) + ((x+3) * glb_ds1[ds1_idx].tile_h / 10);

    col_black = makecol(  0,   0,   0);
    col_white = makecol(255, 255, 255);

    // body
    for (c=0; c < cof->lay; c++) {
        p  = (cof->cur_dir * cof->lay * cof->fpd);
        p += c + (new_frame * cof->lay);
        p  = cof->priority[p];
        if (p >= COMPOSIT_NB) {
            continue;
        }

        lay = & cof->lay_inf[p];
        if (lay == NULL) {
            continue;
        }
        bmp_ptr = lay->bmp;
        if (bmp_ptr == NULL) {
            continue;
        }
        if (new_frame >= lay->bmp_num) {
            f = lay->last_good_frame;
        } else {
            f = new_frame;
        }
        bmp = bmp_ptr[f];
        if (bmp == NULL) {
            continue;
        }
        dx = dx0 - glb_ds1edit.win_preview.x0 + cof->xoffset + lay->off_x;
        dy = dy0 - glb_ds1edit.win_preview.y0 + cof->yoffset + lay->off_y;
        if (((dx + bmp->w) < 0) || ((dy + bmp->h) < 0)) {
            continue;
        }
        if ( (dx >= glb_ds1edit.win_preview.w) || (dy >= glb_ds1edit.win_preview.h)) {
            continue;
        }

        if ((glb_ds1[ds1_idx].cur_zoom == ZM_11) || (glb_config.stretch_sprites != TRUE)) {
            // normal drawing
            if ((lay->trans_a) && (lay->trans_b <= 6) && (lay->trans_b != 5)) {
                // valid gfx effect
                if (glb_ds1edit.cmd_line.force_pal_num == -1) {
                    bptr = glb_ds1edit.d2_pal[glb_ds1[ds1_idx].act - 1];
                } else {
                    bptr = glb_ds1edit.d2_pal[glb_ds1edit.cmd_line.force_pal_num - 1];
                }
                switch(lay->trans_b) {
                    case 0 : bptr += (256 * COF_75TRANS);     break;
                    case 1 : bptr += (256 * COF_50TRANS);     break;
                    case 2 : bptr += (256 * COF_25TRANS);     break;
                    case 3 : bptr += (256 * COF_ALPHA);       break;
                    case 4 : bptr += (256 * COF_LUMINANCE);   break;
                    case 6 : bptr += (256 * COF_ALPHABRIGHT); break;
                }
                color_map = (COLOR_MAP *) bptr;
                draw_trans_sprite(glb_ds1edit.screen_buff, bmp, dx, dy);
            } else {
                // normal colors
                draw_sprite(glb_ds1edit.screen_buff, bmp, dx, dy);
            }
        } else {
            // stretch drawing
            dx = dx0 - glb_ds1edit.win_preview.x0 + (cof->xoffset * glb_ds1[ds1_idx].height_mul / glb_ds1[ds1_idx].height_div) + (lay->off_x * glb_ds1[ds1_idx].height_mul / glb_ds1[ds1_idx].height_div);
            dy = dy0 - glb_ds1edit.win_preview.y0 + (cof->yoffset * glb_ds1[ds1_idx].height_mul / glb_ds1[ds1_idx].height_div) + (lay->off_y * glb_ds1[ds1_idx].height_mul / glb_ds1[ds1_idx].height_div);
            if ((lay->trans_a) && (lay->trans_b <= 6) && (lay->trans_b != 5)){
                // valid gfx effect
                if (glb_ds1edit.cmd_line.force_pal_num == -1){
                    bptr = glb_ds1edit.d2_pal[glb_ds1[ds1_idx].act - 1];
                }else{
                    bptr = glb_ds1edit.d2_pal[glb_ds1edit.cmd_line.force_pal_num - 1];
                }
                switch(lay->trans_b) {
                    case 0 : bptr += (256 * COF_75TRANS);     break;
                    case 1 : bptr += (256 * COF_50TRANS);     break;
                    case 2 : bptr += (256 * COF_25TRANS);     break;
                    case 3 : bptr += (256 * COF_ALPHA);       break;
                    case 4 : bptr += (256 * COF_LUMINANCE);   break;
                    case 6 : bptr += (256 * COF_ALPHABRIGHT); break;
                }
                color_map = (COLOR_MAP *) bptr;
            } else {
                // normal colors
                color_map = NULL;
            }

            stretch_trans_sprite_8bpp( glb_ds1edit.screen_buff, bmp, dx, dy, glb_ds1[ds1_idx].height_div);
        }

        // end
        if (new_frame < lay->bmp_num) {
            lay->last_good_frame = f;
        }
    }

    // if Object editing mode, no speed info
    if (glb_ds1edit.mode == MOD_O) {
        return;
    }

    // speed info
    if (glb_ds1[ds1_idx].objects_layer_mask == OL_SPEED) {
        dx = dx0 - glb_ds1edit.win_preview.x0 - 44;
        dy = dy0 - glb_ds1edit.win_preview.y0 - 8; // + cof->yoffset;

        textprintf(glb_ds1edit.screen_buff, font, dx+1, dy+1, col_black, "speed = %3li", cof->spd_mul);
        textprintf(glb_ds1edit.screen_buff, font, dx, dy, col_white, "speed = %3li", cof->spd_mul);
    }
}


// ==========================================================================
void wpreview_draw_an_object_shad(int ds1_idx, int o)
{
    COF_S     * cof;
    LAY_INF_S * lay;
    BITMAP    ** bmp_ptr, * bmp;
    int       c, f, x, y, d, dx0, dy0, dx, dy, p, offx, offy;
    UBYTE     * bptr;
    UBYTE     new_frame;

    d = glb_ds1[ds1_idx].obj[o].desc_idx;

    if (d == -1) {
        return;
    }

    if (glb_ds1edit.obj_desc[d].usage_count == 0) {
        return;
    }

    cof = glb_ds1edit.obj_desc[d].cof;
    if (cof == NULL) {
        return;
    }
    if (cof->fpd == 0) {
        return;
    }

    new_frame = cof->cur_frame + glb_ds1[ds1_idx].obj[o].frame_delta;
    while (new_frame >= cof->fpd) {
        new_frame -= cof->fpd;
    }

    x   = glb_ds1[ds1_idx].obj[o].x;
    y   = glb_ds1[ds1_idx].obj[o].y;

    dx0 = ((y-2) * -glb_ds1[ds1_idx].tile_w / 10) + ((x+3) * glb_ds1[ds1_idx].tile_w / 10);
    dy0 = 4 + ((y-2) *  glb_ds1[ds1_idx].tile_h / 10) + ((x+3) * glb_ds1[ds1_idx].tile_h / 10);

    // only projected shadow
    for (c=0; c < cof->lay; c++) {
        p  = (cof->cur_dir * cof->lay * cof->fpd);
        p += c + (new_frame * cof->lay);
        p  = cof->priority[p];
        if (p >= COMPOSIT_NB) {
            continue;
        }

        lay = & cof->lay_inf[p];
        if (lay == NULL) {
            continue;
        }

        // shadow for this layer ?
        if (lay->shad_a == 0) {
            continue;
        }

        bmp_ptr = lay->bmp;
        if (bmp_ptr == NULL) {
            continue;
        }
        if (new_frame >= lay->bmp_num) {
            f = lay->last_good_frame;
        } else {
            f = new_frame;
        }
        bmp = bmp_ptr[f];
        if (bmp == NULL) {
            continue;
        }
        dx = dx0 - glb_ds1edit.win_preview.x0 + cof->xoffset + lay->off_x;
        dy = dy0 - glb_ds1edit.win_preview.y0 + cof->yoffset + lay->off_y;
        if (((dx + bmp->w) < 0) || ((dy + bmp->h) < 0)) {
            continue;
        }
        if ( (dx >= glb_ds1edit.win_preview.w) || (dy >= glb_ds1edit.win_preview.h)) {
            continue;
        }

        // stretch drawing of shadow

        if (lay->trans_a) {
            // transparent layer, very few shadows
            if (glb_ds1edit.cmd_line.force_pal_num == -1) {
                bptr = glb_ds1edit.d2_pal[glb_ds1[ds1_idx].act - 1];
            } else {
                bptr = glb_ds1edit.d2_pal[glb_ds1edit.cmd_line.force_pal_num - 1];
            }
            bptr += (256 * 32); // 28th level of transparency table on 32
        } else {
            // darker shadow
            if (glb_ds1edit.cmd_line.force_pal_num == -1) {
                bptr = glb_ds1edit.d2_pal[glb_ds1[ds1_idx].act - 1];
            } else {
                bptr = glb_ds1edit.d2_pal[glb_ds1edit.cmd_line.force_pal_num - 1];
            }
            bptr += (256 * 14); // 10th level of transparency table on 32
        }

        if ((glb_ds1[ds1_idx].cur_zoom == ZM_11) || (glb_config.stretch_sprites != TRUE)) {
            offx = cof->xoffset + lay->off_x;
            offy = cof->yoffset + lay->off_y;

            dx = dx0 - glb_ds1edit.win_preview.x0 + offx;
            dy = dy0 - glb_ds1edit.win_preview.y0 + offy;

            stretch_trans_shadow_8bpp( glb_ds1edit.screen_buff, bmp, dx, dy, 1, bptr, dy0 - glb_ds1edit.win_preview.y0);
        } else {
            offx = (cof->xoffset * glb_ds1[ds1_idx].height_mul / glb_ds1[ds1_idx].height_div) + (lay->off_x * glb_ds1[ds1_idx].height_mul / glb_ds1[ds1_idx].height_div);
            offy = (cof->yoffset * glb_ds1[ds1_idx].height_mul / glb_ds1[ds1_idx].height_div) + (lay->off_y * glb_ds1[ds1_idx].height_mul / glb_ds1[ds1_idx].height_div);

            dx = dx0 - glb_ds1edit.win_preview.x0 + offx;
            dy = dy0 - glb_ds1edit.win_preview.y0 + offy;

            stretch_trans_shadow_8bpp( glb_ds1edit.screen_buff, bmp, dx, dy, glb_ds1[ds1_idx].height_div, bptr, dy0 - glb_ds1edit.win_preview.y0);
        }
    }
}


// ==========================================================================
void wpreview_draw_obj_tile_shad(int ds1_idx, int x, int y, int * cur_idx)
{
    OBJ_S * obj;
    int   o;


    // 1st quick check
    if ((* cur_idx) >= glb_ds1[ds1_idx].obj_num) {
        return;
    }

    // go on 1st potential object to draw
    o   = glb_ds1[ds1_idx].drawing_order[* cur_idx];
    obj = & glb_ds1[ds1_idx].obj[o];
    while (obj->ty < y) {
        // search line
        (* cur_idx) ++;
        if ( (* cur_idx) >= glb_ds1[ds1_idx].obj_num ) {
            return;
        }
        o   = glb_ds1[ds1_idx].drawing_order[* cur_idx];
        obj = & glb_ds1[ds1_idx].obj[o];
    } if (obj->ty == y) {
        while (obj->tx < x) {
            // search column
            (* cur_idx) ++;
            if ( (* cur_idx) >= glb_ds1[ds1_idx].obj_num ) {
                return;
            }
            o   = glb_ds1[ds1_idx].drawing_order[* cur_idx];
            obj = & glb_ds1[ds1_idx].obj[o];
        }
    } else {
        return;
    }

    // draw all objects on this tile, if any
    for (;;) {
        if ((obj->tx == x) && (obj->ty == y)) {
            // draw this obj
            wpreview_draw_an_object_shad(ds1_idx, o);

            // next obj
            (* cur_idx) ++;
            if ( (* cur_idx) >= glb_ds1[ds1_idx].obj_num) {
                return;
            }
            o   = glb_ds1[ds1_idx].drawing_order[* cur_idx];
            obj = & glb_ds1[ds1_idx].obj[o];
        } else {
            return;
        }
    }
}


// ==========================================================================
void wpreview_draw_obj_tile_0_2(int ds1_idx, int x, int y, int * cur_idx)
{
    OBJ_S * obj;
    int   o, d;
    COF_S * cof;


    // 1st quick check
    if ((* cur_idx) >= glb_ds1[ds1_idx].obj_num) {
        return;
    }

    // go on 1st potential object to draw
    o   = glb_ds1[ds1_idx].drawing_order[* cur_idx];
    obj = & glb_ds1[ds1_idx].obj[o];
    while (obj->ty < y) {
        // search line
        (* cur_idx) ++;
        if ( (* cur_idx) >= glb_ds1[ds1_idx].obj_num ) {
            return;
        }
        o   = glb_ds1[ds1_idx].drawing_order[* cur_idx];
        obj = & glb_ds1[ds1_idx].obj[o];
    }
    if (obj->ty == y) {
        while (obj->tx < x) {
            // search column
            (* cur_idx) ++;
            if ( (* cur_idx) >= glb_ds1[ds1_idx].obj_num ) {
                return;
            }
            o   = glb_ds1[ds1_idx].drawing_order[* cur_idx];
            obj = & glb_ds1[ds1_idx].obj[o];
        }
    } else {
        return;
    }

    // draw all objects on this tile, if any
    for (;;) {
        if ((obj->tx == x) && (obj->ty == y)) {
            // draw this obj
            d = glb_ds1[ds1_idx].obj[o].desc_idx;
            if (d != -1) {
                if (glb_ds1edit.obj_desc[d].usage_count) {
                    cof = glb_ds1edit.obj_desc[d].cof;
                    if (cof != NULL) {
                        // printf(" cof is not NULL .................\n");
                        if ((cof->orderflag == 0) || (cof->orderflag == 2)) {
                            wpreview_draw_an_object(ds1_idx, o);
                        }
                    }
                }
            }

            // next obj
            (* cur_idx) ++;
            if ( (* cur_idx) >= glb_ds1[ds1_idx].obj_num) {
                return;
            }
            o   = glb_ds1[ds1_idx].drawing_order[* cur_idx];
            obj = & glb_ds1[ds1_idx].obj[o];
        }
        else {
            return;
        }
    }
}


// ==========================================================================
void wpreview_draw_obj_tile_1(int ds1_idx, int x, int y, int * cur_idx)
{
    OBJ_S * obj;
    int   o, d;
    COF_S * cof;


    // 1st quick check
    if ((* cur_idx) >= glb_ds1[ds1_idx].obj_num) {
        return;
    }

    // go on 1st potential object to draw
    o   = glb_ds1[ds1_idx].drawing_order[* cur_idx];
    obj = & glb_ds1[ds1_idx].obj[o];
    while (obj->ty < y) {
        // search line
        (* cur_idx) ++;
        if ( (* cur_idx) >= glb_ds1[ds1_idx].obj_num ) {
            return;
        }
        o   = glb_ds1[ds1_idx].drawing_order[* cur_idx];
        obj = & glb_ds1[ds1_idx].obj[o];
    }
    if (obj->ty == y) {
        while (obj->tx < x) {// search column
            (* cur_idx) ++;
            if ( (* cur_idx) >= glb_ds1[ds1_idx].obj_num ) {
                return;
            }
            o   = glb_ds1[ds1_idx].drawing_order[* cur_idx];
            obj = & glb_ds1[ds1_idx].obj[o];
        }
    } else {
        return;
    }

    // draw all objects on this tile, if any
    for(;;) {
        if ((obj->tx == x) && (obj->ty == y)) {
            // draw this obj
            d = glb_ds1[ds1_idx].obj[o].desc_idx;
            if (d != -1) {
                if (glb_ds1edit.obj_desc[d].usage_count) {
                    cof = glb_ds1edit.obj_desc[d].cof;
                    if (cof != NULL) {
                        if (cof->orderflag == 1) {
                            wpreview_draw_an_object(ds1_idx, o);
                        }
                    }
                }
            }

            // next obj
            (* cur_idx) ++;
            if ( (* cur_idx) >= glb_ds1[ds1_idx].obj_num) {
                return;
            }
            o   = glb_ds1[ds1_idx].drawing_order[* cur_idx];
            obj = & glb_ds1[ds1_idx].obj[o];
        } else {
            return;
        }
    }
}


// ==========================================================================
// draw the tile grid for this ds1
void wpreview_draw_tile_grid(int ds1_idx)
{
    int tw, th, dw, dh, px, py, base_x, base_y, mx, my, c, i, x1, y1, x2, y2;
    int min_x, min_y, max_x, max_y, dummy;


    tw = glb_ds1[ds1_idx].tile_w;
    th = glb_ds1[ds1_idx].tile_h;
    dw = glb_ds1[ds1_idx].width;
    dh = glb_ds1[ds1_idx].height;
    px = glb_ds1edit.win_preview.x0;
    py = glb_ds1edit.win_preview.y0;
    c  = makecol(255, 255, 255);

    base_x = tw/2 - px - 1;
    base_y = - py - 1;
    mx     = base_x - (tw * dh / 2);
    my     = base_y + (th * dh / 2);

    x1 = px;
    y1 = py;
    coord_to_tile(ds1_idx, x1, y1, & min_x, & dummy);

    x1 = px + glb_config.screen.width;
    coord_to_tile(ds1_idx, x1, y1, & dummy, & min_y);

    x1 = px;
    y1 = py + glb_config.screen.height;
    coord_to_tile(ds1_idx, x1, y1, & dummy, & max_y);

    x1 = px + glb_config.screen.width;
    coord_to_tile(ds1_idx, x1, y1, & max_x, & dummy);

    if ( (glb_ds1edit.mode == MOD_O) || (glb_ds1edit.mode == MOD_P) || (glb_ds1edit.mode == MOD_L) ) {
        min_x /= 5;
        min_y /= 5;
        max_x /= 5;
        max_y /= 5;
    }
    if (min_x < 0) {
        min_x = 0;
    }
    if (min_y < 0) {
        min_y = 0;
    }
    if (max_x > glb_ds1[ds1_idx].width){
        max_x = glb_ds1[ds1_idx].width;
    }
    if (max_y > glb_ds1[ds1_idx].height){
        max_y = glb_ds1[ds1_idx].height;
    }

    //   for (i=0; i <= dw ; i++)
    for (i=min_x; i <= max_x ; i++) {
        x1 = base_x + i * tw / 2;
        y1 = base_y + i * th / 2;
        x2 = mx + i * tw / 2;
        y2 = my + i * th / 2;
        line(glb_ds1edit.screen_buff, x1, y1, x2, y2, c);
    }

    base_x = tw/2 - px - 1;
    base_y = - py - 1;
    mx     = base_x + (tw * dw / 2);
    my     = base_y + (th * dw / 2);
    for (i=min_y; i <= max_y ; i++) {
        x1 = base_x - i * tw / 2;
        y1 = base_y + i * th / 2;
        x2 = mx - i * tw / 2;
        y2 = my + i * th / 2;
        line(glb_ds1edit.screen_buff, x1, y1, x2, y2, c);
    }
}


// ==========================================================================
// draw all tiles of this ds1
void wpreview_draw_tiles(int ds1_idx)
{
    int               x, y, base_x = 0, base_y = 0, mx, my;
    int               cx, cy, dx, dy, z, x1, x2, x3, x4, y1, y2, y3, i, select;
    static int        old_pal = -1;
    char              * mode;
    UBYTE             walkinfo[25];
    int               objdraw_cur_idx = 0;
    void              (* fptr_wi) (int, int, int, UBYTE *);
    PATH_EDIT_WIN_S   * pwin = & glb_ds1[ds1_idx].path_edit_win;


    z = glb_ds1[ds1_idx].cur_zoom;
    clear(glb_ds1edit.screen_buff);

    // handle palette
    if (glb_ds1edit.cmd_line.force_pal_num == -1) {
        // use .ds1 act value for palette
        if (old_pal != glb_ds1[ds1_idx].act - 1) {
            old_pal = glb_ds1[ds1_idx].act - 1;
            set_palette(glb_ds1edit.vga_pal[old_pal]);
        }
    } else {
        // use force_pal value for palette
        if (old_pal != glb_ds1edit.cmd_line.force_pal_num - 1) {
            old_pal = glb_ds1edit.cmd_line.force_pal_num - 1;
            set_palette(glb_ds1edit.vga_pal[old_pal]);
        }
    }

    // which tile is under the mouse ?
    mouse_to_tile(ds1_idx, &cx, &cy);
    if (glb_ds1edit.mode == MOD_T) {
        if (cx < 0) {
            cx = 0;
        } else if (cx >= glb_ds1[ds1_idx].width) {
            cx = glb_ds1[ds1_idx].width - 1;
        }
        if (cy < 0) {
            cy = 0;
        } else if (cy >= glb_ds1[ds1_idx].height) {
            cy = glb_ds1[ds1_idx].height - 1;
        }
    } else {
        // the 2 folowing lines... maybe because floors are not
        // displayed at the same height of walls ?
        // ... then why in TILE mode it's ok ? weird.
        cx -= 2;
        cy += 2;


        // restrict the range only if NOT in paths editing mode
        // (paths can be out of the ds1 borders)
        if (glb_ds1edit.mode != MOD_P) {
            if (cx < 0) {
                cx = 0;
            } else if (cx >= glb_ds1[ds1_idx].width * 5 - 1) {
                cx = glb_ds1[ds1_idx].width * 5 - 1;
            }
            if (cy < 0) {
                cy = 0;
            } else if (cy >= glb_ds1[ds1_idx].height * 5 - 1) {
                cy = glb_ds1[ds1_idx].height * 5 - 1;
            }
        }
    }


    // update objects animation, only if in 'running' animation mode
    if (glb_ds1[ds1_idx].animations_layer_mask == 1) {
        wpreview_obj_animate();
    }

    // loop 1A : lower walls, floors, shadows of dt1
    for (y=0; y<glb_ds1[ds1_idx].height; y++) {
        base_x = y * -glb_ds1[ds1_idx].tile_w / 2;
        base_y = y * glb_ds1[ds1_idx].tile_h / 2;
        for (x=0; x<glb_ds1[ds1_idx].width; x++) {
            select = FALSE;
            if ((glb_ds1edit.mode == MOD_T) && (x==cx) && (y==cy))
                select = TRUE;
            mx = base_x + x * glb_ds1[ds1_idx].tile_w / 2;
            if ((mx >= glb_ds1edit.win_preview.x0-glb_ds1[ds1_idx].tile_w) && (mx < glb_ds1edit.win_preview.x0 + glb_ds1edit.win_preview.w)) {
                my = base_y + x * glb_ds1[ds1_idx].tile_h / 2;
                wpreview_draw_w(ds1_idx, x, y, mx, my, z, select, FALSE); // lower walls
                wpreview_draw_f(ds1_idx, x, y, mx, my, z, select);        // floors
                wpreview_draw_s(ds1_idx, x, y, mx, my, z, select);        // shadows of dt1
            }
        }
    }

    // loop 1B : shadows of objects
    objdraw_cur_idx = 0;
    for (y=0; y<glb_ds1[ds1_idx].height; y++) {
        base_x = y * -glb_ds1[ds1_idx].tile_w / 2;
        base_y = y * glb_ds1[ds1_idx].tile_h / 2;
        for (x=0; x<glb_ds1[ds1_idx].width; x++) {
            select = FALSE;
            if ((glb_ds1edit.mode == MOD_T) && (x==cx) && (y==cy)) {
                select = TRUE;
            }
            mx = base_x + x * glb_ds1[ds1_idx].tile_w / 2;
            if ((mx >= glb_ds1edit.win_preview.x0-glb_ds1[ds1_idx].tile_w) && (mx < glb_ds1edit.win_preview.x0 + glb_ds1edit.win_preview.w)) {
                // shadows of objects
                if (glb_ds1[ds1_idx].animations_layer_mask) {
                    wpreview_draw_obj_tile_shad(ds1_idx, x, y, & objdraw_cur_idx);
                }
            }
        }
    }

    // loop 2 : objects with orderflag set to 1 (optional)
    objdraw_cur_idx = 0;
    if (glb_ds1[ds1_idx].animations_layer_mask) {
        for (y=0; y<glb_ds1[ds1_idx].height; y++) {
            base_x = y * -glb_ds1[ds1_idx].tile_w / 2;
            base_y = y * glb_ds1[ds1_idx].tile_h / 2;
            for (x=0; x<glb_ds1[ds1_idx].width; x++) {
                select = FALSE;
                if ((glb_ds1edit.mode == MOD_T) && (x==cx) && (y==cy)) {
                    select = TRUE;
                }
                mx = base_x + x * glb_ds1[ds1_idx].tile_w / 2;
                if ((mx >= glb_ds1edit.win_preview.x0-glb_ds1[ds1_idx].tile_w) && (mx < glb_ds1edit.win_preview.x0 + glb_ds1edit.win_preview.w)) {
                    // objects of this tile
                    wpreview_draw_obj_tile_1(ds1_idx, x, y, & objdraw_cur_idx);
                }
            }
        }
    }

    // tile grid : if over floor but under wall, draw it now
    if (glb_ds1edit.display_tile_grid == TG_OVERFLOOR) {
        wpreview_draw_tile_grid(ds1_idx);
    }

    // loop 3 : upper walls, objects with orderflag set to 0 or 2
    objdraw_cur_idx = 0;
    for (y=0; y<glb_ds1[ds1_idx].height; y++) {
        base_x = y * -glb_ds1[ds1_idx].tile_w / 2;
        base_y = y * glb_ds1[ds1_idx].tile_h / 2;
        for (x=0; x<glb_ds1[ds1_idx].width; x++) {
            select = FALSE;
            if ((glb_ds1edit.mode == MOD_T) && (x==cx) && (y==cy)) {
                select = TRUE;
            }
            mx = base_x + x * glb_ds1[ds1_idx].tile_w / 2;
            if ((mx >= glb_ds1edit.win_preview.x0-glb_ds1[ds1_idx].tile_w) && (mx < glb_ds1edit.win_preview.x0 + glb_ds1edit.win_preview.w)) {
                my = base_y + x * glb_ds1[ds1_idx].tile_h / 2;
                wpreview_draw_w(ds1_idx, x, y, mx, my, z, select, TRUE);  // upper walls

                // objects of this tile
                if (glb_ds1[ds1_idx].animations_layer_mask) {
                    wpreview_draw_obj_tile_0_2(ds1_idx, x, y, & objdraw_cur_idx);
                }
            }
        }
    }

    // loop 4 : roofs
    for (y=0; y<glb_ds1[ds1_idx].height; y++) {
        base_x = y * -glb_ds1[ds1_idx].tile_w / 2;
        base_y = y * glb_ds1[ds1_idx].tile_h / 2;
        for (x=0; x<glb_ds1[ds1_idx].width; x++) {
            select = FALSE;
            if ((glb_ds1edit.mode == MOD_T) && (x==cx) && (y==cy)) {
                select = TRUE;
            }
            mx = base_x + x * glb_ds1[ds1_idx].tile_w / 2;
            if ((mx >= glb_ds1edit.win_preview.x0-glb_ds1[ds1_idx].tile_w) && (mx < glb_ds1edit.win_preview.x0 + glb_ds1edit.win_preview.w)) {
                my = base_y + x * glb_ds1[ds1_idx].tile_h / 2;
                wpreview_draw_r (ds1_idx, x, y, mx, my, z, select); // roofs
            }
        }
    }

    // loop 5 : special tiles (optional)
    if (glb_ds1[ds1_idx].special_layer_mask) {
        for (y=0; y<glb_ds1[ds1_idx].height; y++) {
            base_x = y * -glb_ds1[ds1_idx].tile_w / 2;
            base_y = y * glb_ds1[ds1_idx].tile_h / 2;
            for (x=0; x<glb_ds1[ds1_idx].width; x++) {
                select = FALSE;
                if ((glb_ds1edit.mode == MOD_T) && (x==cx) && (y==cy)) {
                    select = TRUE;
                }
                mx = base_x + x * glb_ds1[ds1_idx].tile_w / 2;
                if ((mx >= glb_ds1edit.win_preview.x0-glb_ds1[ds1_idx].tile_w) && (mx < glb_ds1edit.win_preview.x0 + glb_ds1edit.win_preview.w)) {
                    my = base_y + x * glb_ds1[ds1_idx].tile_h / 2;
                    wpreview_draw_sp(ds1_idx, x, y, mx, my, z, select); // special
                }
            }
        }
    }

    // loop 6 : walkable infos (optional)
    switch(glb_ds1[ds1_idx].walkable_layer_mask) {
        case 1  : fptr_wi = wpreview_draw_simple_wi; break;
        case 2  : fptr_wi = wpreview_draw_wi;        break;
        default : fptr_wi = NULL;
    }
    if (fptr_wi != NULL) {
        for (y=0; y<glb_ds1[ds1_idx].height; y++) {
            base_x = y * -glb_ds1[ds1_idx].tile_w / 2;
            base_y = y * glb_ds1[ds1_idx].tile_h / 2;
            for (x=0; x<glb_ds1[ds1_idx].width; x++) {
                mx = base_x + x * glb_ds1[ds1_idx].tile_w / 2;
                if ((mx >= glb_ds1edit.win_preview.x0-glb_ds1[ds1_idx].tile_w) && (mx < glb_ds1edit.win_preview.x0 + glb_ds1edit.win_preview.w)) {
                    my = base_y + x * glb_ds1[ds1_idx].tile_h / 2;
                    if ((my >= glb_ds1edit.win_preview.y0-glb_ds1[ds1_idx].tile_h) && (my < glb_ds1edit.win_preview.y0 + glb_ds1edit.win_preview.h)) {
                        misc_search_walk_infos(ds1_idx, x, y, walkinfo);
                        fptr_wi(mx, my, z, walkinfo);
                    }
                }
            }
        }
    }

    // tile grid : if over floor and walls, draw it now
    if (glb_ds1edit.display_tile_grid == TG_OVERWALL) {
        wpreview_draw_tile_grid(ds1_idx);
    }

    // mouse floor cursor
    if (glb_ds1edit.mode == MOD_T) {
        // tile cursor
        dx = (cy * -glb_ds1[ds1_idx].tile_w / 2) + (cx * glb_ds1[ds1_idx].tile_w / 2);
        dy = (cy *  glb_ds1[ds1_idx].tile_h / 2) + (cx * glb_ds1[ds1_idx].tile_h / 2);

        x1 = dx - glb_ds1edit.win_preview.x0;
        x2 = x1 + glb_ds1[ds1_idx].tile_w / 2 - 1;
        x3 = x1 + glb_ds1[ds1_idx].tile_w / 2;
        x4 = x1 + glb_ds1[ds1_idx].tile_w - 1;

        y1 = dy - glb_ds1edit.win_preview.y0;
        y2 = y1 + glb_ds1[ds1_idx].tile_h / 2 - 1;
        y3 = y1 + glb_ds1[ds1_idx].tile_h - 2;

        line(glb_ds1edit.screen_buff, x1, y2, x2, y1, 129);
        line(glb_ds1edit.screen_buff, x3, y1, x4, y2, 129);
        line(glb_ds1edit.screen_buff, x3, y3, x4, y2, 129);
        line(glb_ds1edit.screen_buff, x1, y2, x2, y3, 129);
    } else {
        // if (glb_ds1edit.mode != MOD_L)
        // sub-cell cursor

        // invert the change
        cx += 2;
        cy -= 2;

        // compute the pixels position
        dx = (cy * -glb_ds1[ds1_idx].tile_w / 10) + (cx * glb_ds1[ds1_idx].tile_w / 10);
        dy = (cy *  glb_ds1[ds1_idx].tile_h / 10) + (cx * glb_ds1[ds1_idx].tile_h / 10);

        // redo it
        cx -= 2;
        cy += 2;

        x1 = dx - glb_ds1edit.win_preview.x0;
        x2 = x1 + glb_ds1[ds1_idx].tile_w / 10 - 1;
        x3 = x1 + glb_ds1[ds1_idx].tile_w / 10;
        x4 = x1 + glb_ds1[ds1_idx].tile_w / 5 - 1;

        y1 = dy - glb_ds1edit.win_preview.y0;
        y2 = y1 + glb_ds1[ds1_idx].tile_h / 10 - 1;
        y3 = y1 + glb_ds1[ds1_idx].tile_h / 5 - 2;

        line(glb_ds1edit.screen_buff, x1, y2, x2, y1, 129);
        line(glb_ds1edit.screen_buff, x3, y1, x4, y2, 129);
        line(glb_ds1edit.screen_buff, x3, y3, x4, y2, 129);
        line(glb_ds1edit.screen_buff, x1, y2, x2, y3, 129);
    }

    // npc paths
    if (glb_ds1edit.mode == MOD_P) {
        wpreview_draw_paths_1obj(ds1_idx, pwin->obj_idx);
    } else if (glb_ds1[ds1_idx].paths_layer_mask) {
        wpreview_draw_paths(ds1_idx);
    }

    // objects infos
    if (glb_ds1edit.mode == MOD_O) {
        editobj_draw_obj_lab(ds1_idx, TRUE);
        editobj_draw_obj_lab(ds1_idx, FALSE);
        if (glb_ds1[ds1_idx].draw_edit_obj) {
            editobj_draw_edit_obj(ds1_idx);
        }
    } else if (glb_ds1[ds1_idx].objects_layer_mask != OL_NONE) {
        wpreview_draw_objects(ds1_idx);
    }

    // path infos window
    if (glb_ds1edit.mode == MOD_P) {
        editpath_draw(ds1_idx, mouse_x, mouse_y, mouse_b, cx, cy);
    }

    // help window for accurate sub-tile flags
    if ((glb_ds1[ds1_idx].walkable_layer_mask == 2) && (glb_ds1[ds1_idx].subtile_help_display)) {
        x1 = glb_ds1edit.screen_buff->w - glb_ds1edit.subtile_help->w - 10;
        x2 = x1 + glb_ds1edit.subtile_help->w;
        y1 = glb_ds1edit.screen_buff->h - glb_ds1edit.subtile_help->h - 20;
        y2 = y1 + glb_ds1edit.subtile_help->h;
        blit(glb_ds1edit.subtile_help, glb_ds1edit.screen_buff, 0, 0, x1, y1, x2, y2);
        rect(glb_ds1edit.screen_buff, x1-1, y1-1, x2+1, y2+1, 255);
    }

    // make up & bottom border black, with white line
    if (glb_ds1edit.show_2nd_row == TRUE) {
        rectfill(glb_ds1edit.screen_buff, 0,  0, glb_config.screen.width, 19, 0);
        hline(glb_ds1edit.screen_buff,    0,  9, glb_config.screen.width, 29);
        hline(glb_ds1edit.screen_buff,    0, 20, glb_config.screen.width, 255);

        // 2nd row datas
        textprintf(glb_ds1edit.screen_buff, font,   0, 11, 255, "Set:");
        textprintf(glb_ds1edit.screen_buff, font,  32, 11, 109, "%i", glb_ds1edit.ds1_group_idx + 1);

        textprintf(glb_ds1edit.screen_buff, font,  65, 11, 255, "Ds1Index:");
        textprintf(glb_ds1edit.screen_buff, font, 137, 11, 109, "%i", ds1_idx + 1);

        textprintf(glb_ds1edit.screen_buff, font, 175, 11, 255, "File:");
        textprintf(glb_ds1edit.screen_buff, font, 215, 11, 109, "%s", glb_ds1[ds1_idx].name);
    } else {
        rectfill(glb_ds1edit.screen_buff, 0, 0, glb_config.screen.width, 8, 0);
        hline(glb_ds1edit.screen_buff,    0, 9, glb_config.screen.width, 255);
    }

    // bottom row background
    rectfill(glb_ds1edit.screen_buff, 0, glb_config.screen.height-9,  glb_config.screen.width, glb_config.screen.height, 0);
    hline(glb_ds1edit.screen_buff,    0, glb_config.screen.height-10, glb_config.screen.width, 255);

    // layers toggle
    text_mode(-1);

    // floor layers (F1, F2)
    for (i=0; i < glb_ds1[ds1_idx].floor_num; i++) {
        if (glb_ds1[ds1_idx].floor_layer_mask[i] == 0) {
            textprintf(glb_ds1edit.screen_buff, font, 20*i, 0,  98, "f%i", i+1);
        } else {
            textprintf(glb_ds1edit.screen_buff, font, 20*i, 0, 132, "f%i", i+1);
        }
    }

    // animation layer (F3)
    switch(glb_ds1[ds1_idx].animations_layer_mask) {
        case 0 :
            textprintf(glb_ds1edit.screen_buff, font, 50, 0, 98, "anims");
            break;

        case 1 :
            textprintf(glb_ds1edit.screen_buff, font, 50, 0, 132, "anims");
            break;

        default :
            textprintf(glb_ds1edit.screen_buff, font, 50, 0, 108, "anims");
            break;
    }

    // objects layer (F4)
    switch(glb_ds1[ds1_idx].objects_layer_mask) {
        case OL_NONE :
            textprintf(glb_ds1edit.screen_buff, font, 100, 0, 98, "obj");
            break;

        case OL_TYPEID :
            textprintf(glb_ds1edit.screen_buff, font, 100, 0, 210, "obj");
            break;

        case OL_SPEED :
            textprintf(glb_ds1edit.screen_buff, font, 100, 0, 108, "obj");
            break;

        case OL_DESC :
            textprintf(glb_ds1edit.screen_buff, font, 100, 0, 132, "obj");
            break;

        default :
            break;
    }

    // drawing order for special tiles (F9)
    switch(glb_ds1[ds1_idx].special_layer_mask) {
        case 0 :
            textprintf(glb_ds1edit.screen_buff, font, 240, 0, 98, "spl");
            break;

        default :
            textprintf(glb_ds1edit.screen_buff, font, 240, 0, 132, "spl");
            break;
    }

    // wall layers (F5, F6, F7 F8)
    for (i=0; i < glb_ds1[ds1_idx].wall_num; i++) {
        if (glb_ds1[ds1_idx].wall_layer_mask[i] == 0) {
            textprintf(glb_ds1edit.screen_buff, font, 140+20*i, 0,  98, "w%i", i+1);
        } else {
            textprintf(glb_ds1edit.screen_buff, font, 140+20*i, 0, 132, "w%i", i+1);
        }
    }

    // paths layer (F10)
    if (glb_ds1[ds1_idx].paths_layer_mask == 0) {
        textprintf(glb_ds1edit.screen_buff, font, 280, 0, 98, "path");
    } else {
        textprintf(glb_ds1edit.screen_buff, font, 280, 0, 132, "path");
    }

    // shadow layer (F11)
    switch(glb_ds1[ds1_idx].shadow_layer_mask[0]) {
        case 1 :
            textprintf(glb_ds1edit.screen_buff, font, 340, 0, 210, "shad");
            break;

        case 2 :
            textprintf(glb_ds1edit.screen_buff, font, 340, 0, 255, "shad");
            break;

        case 3 :
            textprintf(glb_ds1edit.screen_buff, font, 340, 0, 132, "shad");
            break;

        default :
            textprintf(glb_ds1edit.screen_buff, font, 340, 0, 98, "shad");
            break;

    }

    // other infos

    // zoom (+, -)
    textprintf(glb_ds1edit.screen_buff, font, 390, 0, 255, "zoom=%i:%i", glb_ds1[ds1_idx].height_mul, glb_ds1[ds1_idx].height_div);

    // gamma (F12)
    textprintf(glb_ds1edit.screen_buff, font, 490, 0, 255, "gamma=%s", glb_gamma_str[glb_ds1edit.cur_gamma].str);

    // ds1 file name
    textprintf(glb_ds1edit.screen_buff, font, 606, 0, 109, "%s", glb_ds1[ds1_idx].filename);

    // cell coordinates
    if (glb_ds1edit.mode == MOD_T) {
        // mode Tiles, 1 cell = 1 Tile
        textprintf( glb_ds1edit.screen_buff, font, 0, glb_config.screen.height-8, 255, "Cell (%3i, %3i)", cx, cy);
    } else {
        // mode Objects or Paths, 1 cell = 1 sub-Tile
        textprintf( glb_ds1edit.screen_buff, font, 0, glb_config.screen.height-8, 255, "Sub-Cell (%3i, %3i)", cx, cy);
    }

    // frames per second
    textprintf( glb_ds1edit.screen_buff, font, glb_config.screen.width-80, 0, 255, "  fps=%i", glb_ds1edit.old_fps);

    // refresh rate
    textprintf( glb_ds1edit.screen_buff, font, glb_config.screen.width-168, glb_config.screen.height-8, 92, "%iHz", glb_ds1edit.current_refresh_rate);

    // current number of objects / max number of objects
    textprintf( glb_ds1edit.screen_buff, font, 200, glb_config.screen.height-8, 92, "[Objects : %ld / %ld]", glb_ds1[ds1_idx].obj_num, glb_ds1[ds1_idx].current_obj_max);

    // editing mode
    switch(glb_ds1edit.mode) {
        case MOD_T : mode = "Tiles  "; break;
        case MOD_O : mode = "Objects"; break;
        case MOD_P : mode = "Paths  "; break;

        case MOD_L : if (glb_ds1edit.night_mode == 0) {
                         mode = "Night 1";
                     } else {
                         mode = "Night 2";
                     }
                     break;

        default    : mode = "?      "; break;
    }
    textprintf(glb_ds1edit.screen_buff, font, glb_config.screen.width-112, glb_config.screen.height-8, 255, "Mode :");
    textprintf(glb_ds1edit.screen_buff, font, glb_config.screen.width-56, glb_config.screen.height-8, 108, "%s", mode);

    // uncomment this part to understand the axis and
    // glb_ds1edit.win_preview.x0 (and y0) relations, at different zooms
    /*
       textprintf(glb_ds1edit.screen_buff, font, 0, 40, 255, "prev x0, y0  = "
       "%i, %i", glb_ds1edit.win_preview.x0, glb_ds1edit.win_preview.y0);
       hline(glb_ds1edit.screen_buff, 0, - glb_ds1edit.win_preview.y0, glb_config.screen.width, 255);
       vline(glb_ds1edit.screen_buff, - glb_ds1edit.win_preview.x0, 0, glb_config.screen.height, 255);
     */

    // draw screen
    misc_draw_screen(mouse_x, mouse_y);

    wpreview_reiinit_animated_floor(ds1_idx);
}


// ==========================================================================
// draw all tiles of this ds1
int wpreview_draw_tiles_big_screenshot(int ds1_idx)
{
    int               x, y, base_x = 0, base_y = 0, mx, my;
    int               cx, cy, z, x1, x2, y1, y2, select;
    static int        old_pal = -1;
    UBYTE             walkinfo[25];
    int               objdraw_cur_idx = 0;
    void              (* fptr_wi) (int, int, int, UBYTE *);
    PATH_EDIT_WIN_S   * pwin = & glb_ds1[ds1_idx].path_edit_win;

    long              minx, miny, maxx, maxy, tmpw, tmph;
    BLOCK_TABLE_S     * bt_ptr;
    BITMAP            * tmp_bmp;
    CELL_S_S          * s_ptr;
    CELL_F_S          * f_ptr;
    CELL_W_S          * w_ptr;
    int               n, t, bt_idx, dt1_idx, block_idx;
    int               old_screen_width, old_screen_height,
                      old_screen_x0, old_screen_y0;

    // some inits
    z = glb_ds1[ds1_idx].cur_zoom;

    // init coordinates
    minx = miny = 0x7FFFFFFFLU;
    maxx = maxy = 0x80000000LU;

    // find coordinates
    for (y=0; y<glb_ds1[ds1_idx].height; y++) {
        base_x = y * -glb_ds1[ds1_idx].tile_w / 2;
        base_y = y * glb_ds1[ds1_idx].tile_h / 2;
        for (x=0; x<glb_ds1[ds1_idx].width; x++) {
            mx = base_x + x * glb_ds1[ds1_idx].tile_w / 2;
            my = base_y + x * glb_ds1[ds1_idx].tile_h / 2;

            // for all shadow layers of that tile
            t     = (y * glb_ds1[ds1_idx].shadow_line) + (x * glb_ds1[ds1_idx].shadow_num);
            s_ptr = glb_ds1[ds1_idx].shadow_buff + t;
            for (n=0; n<glb_ds1[ds1_idx].shadow_num; n++) {
                bt_idx = s_ptr[n].bt_idx; // index in block table

                if (s_ptr[n].prop4 & 0x80) {
                    // binary : 1000-0000
                    bt_idx = -1; // consider that tile as "unknown"
                }

                if (bt_idx != -1) {
                    bt_ptr = glb_ds1[ds1_idx].block_table + bt_idx; // pointer in block table

                    if (bt_ptr->type != BT_SHADOW) {
                        continue; // only shadows
                    }

                    dt1_idx   = bt_ptr->dt1_idx;
                    block_idx = bt_ptr->block_idx;

                    tmp_bmp = * (glb_dt1[dt1_idx].block_zoom[z] + block_idx);

                    if (tmp_bmp == NULL) {
                        continue;
                    }

                    y1 = my - bt_ptr->zero_line * glb_ds1[ds1_idx].height_mul / glb_ds1[ds1_idx].height_div;
                    y1 += glb_ds1[ds1_idx].tile_h; // shadow, like walls, are lower than floors
                    //    (and than roofs) by 80 pixels
                    y2 = y1 + tmp_bmp->h;
                    x1 = mx;
                    x2 = x1 + tmp_bmp->w;
                    if (x1 < minx) {
                        minx = x1;
                    }
                    if (x2 > maxx) {
                        maxx = x2;
                    }
                    if (y1 < miny) {
                        miny = y1;
                    }
                    if (y2 > maxy) {
                        maxy = y2;
                    }
                }
            }

            // for all floor layers of that tile
            t     = (y * glb_ds1[ds1_idx].floor_line) + (x * glb_ds1[ds1_idx].floor_num);
            f_ptr = glb_ds1[ds1_idx].floor_buff + t;
            for (n=0; n<glb_ds1[ds1_idx].floor_num; n++) {
                bt_idx = f_ptr[n].bt_idx; // index in block table

                if (bt_idx != -1) {
                    bt_ptr = glb_ds1[ds1_idx].block_table + bt_idx; // pointer in block table
                    if ((bt_ptr->type != BT_STATIC) && (bt_ptr->type != BT_ANIMATED)) {
                        continue; // only floors
                    }

                    dt1_idx   = bt_ptr->dt1_idx;
                    block_idx = bt_ptr->block_idx;

                    tmp_bmp = * (glb_dt1[dt1_idx].block_zoom[z] + block_idx);

                    if (tmp_bmp == NULL) {
                        continue;
                    }

                    y1 = my - bt_ptr->zero_line * glb_ds1[ds1_idx].height_mul / glb_ds1[ds1_idx].height_div;
                    y2 = y1 + tmp_bmp->h;
                    x1 = mx;
                    x2 = x1 + tmp_bmp->w;
                    if (x1 < minx) {
                        minx = x1;
                    }
                    if (x2 > maxx) {
                        maxx = x2;
                    }
                    if (y1 < miny) {
                        miny = y1;
                    }
                    if (y2 > maxy) {
                        maxy = y2;
                    }
                }
            }

            // for all wall layers of that tile
            t     = (y * glb_ds1[ds1_idx].wall_line) + (x * glb_ds1[ds1_idx].wall_num);
            w_ptr = glb_ds1[ds1_idx].wall_buff + t;
            for (n=0; n<glb_ds1[ds1_idx].wall_num; n++) {
                bt_idx = w_ptr[n].bt_idx; // index in block table

                if (bt_idx != -1) {
                    bt_ptr = glb_ds1[ds1_idx].block_table + bt_idx; // pointer in block table

                    if ( (bt_ptr->type != BT_WALL_UP) && (bt_ptr->type != BT_WALL_DOWN) && (bt_ptr->type != BT_ROOF) && (bt_ptr->type != BT_SPECIAL) && (bt_ptr->type != BT_WALL_ANIMATED)) {
                        continue; // only walls
                    }

                    dt1_idx   = bt_ptr->dt1_idx;
                    block_idx = bt_ptr->block_idx;

                    tmp_bmp = * (glb_dt1[dt1_idx].block_zoom[z] + block_idx);

                    if (tmp_bmp == NULL) {
                        continue;
                    }

                    y1 = my - bt_ptr->zero_line * glb_ds1[ds1_idx].height_mul / glb_ds1[ds1_idx].height_div;
                    y1 += glb_ds1[ds1_idx].tile_h; // shadow, like walls, are lower than floors
                    //    (and than roofs) by 80 pixels
                    y2 = y1 + tmp_bmp->h;
                    x1 = mx;
                    x2 = x1 + tmp_bmp->w;
                    if (x1 < minx) {
                        minx = x1;
                    }
                    if (x2 > maxx) {
                        maxx = x2;
                    }
                    if (y1 < miny) {
                        miny = y1;
                    }
                    if (y2 > maxy) {
                        maxy = y2;
                    }
                }
            }
        }
    }

    // deduce BIG screenshot dimensions
    tmpw = maxx - minx;
    tmph = maxy - miny;
    /*
       printf("bigscreenshot : (%i, %i) - (%i, %i) = %i * %i pixels\n",
       minx, miny, maxx, maxy, tmpw, tmph
       );
     */

    // make a temporary new screen buffer
    if ((tmpw <= 0) || (tmph <= 0)) {
        return -1;
    }
    tmp_bmp = create_bitmap_ex(8, tmpw, tmph);
    if (tmp_bmp == NULL) {
        return -1;
    }

    // swap it with the normal one
    glb_ds1edit.screen_buff = tmp_bmp;

    old_screen_width  = glb_ds1edit.win_preview.w;
    old_screen_height = glb_ds1edit.win_preview.h;
    old_screen_x0     = glb_ds1edit.win_preview.x0;
    old_screen_y0     = glb_ds1edit.win_preview.y0;

    glb_ds1edit.win_preview.w  = tmpw;
    glb_ds1edit.win_preview.h  = tmph;
    glb_ds1edit.win_preview.x0 = minx;
    glb_ds1edit.win_preview.y0 = miny;
    glb_config.screen.width        = tmpw;
    glb_config.screen.height       = tmph;

    // let's go
    clear(glb_ds1edit.screen_buff);

    // handle palette
    if (glb_ds1edit.cmd_line.force_pal_num == -1) {
        // use .ds1 act value for palette
        if (old_pal != glb_ds1[ds1_idx].act - 1) {
            old_pal = glb_ds1[ds1_idx].act - 1;
            set_palette(glb_ds1edit.vga_pal[old_pal]);
        }
    } else {
        // use force_pal value for palette
        if (old_pal != glb_ds1edit.cmd_line.force_pal_num - 1) {
            old_pal = glb_ds1edit.cmd_line.force_pal_num - 1;
            set_palette(glb_ds1edit.vga_pal[old_pal]);
        }
    }

    // tile cursor under the mouse
    cx = cy = -1;

    // loop 1A : lower walls, floors, shadows of dt1
    for (y=0; y<glb_ds1[ds1_idx].height; y++) {
        base_x = y * -glb_ds1[ds1_idx].tile_w / 2;
        base_y = y * glb_ds1[ds1_idx].tile_h / 2;
        for (x=0; x<glb_ds1[ds1_idx].width; x++) {
            select = FALSE;
            if ((glb_ds1edit.mode == MOD_T) && (x==cx) && (y==cy)) {
                select = TRUE;
            }
            mx = base_x + x * glb_ds1[ds1_idx].tile_w / 2;
            if ((mx >= glb_ds1edit.win_preview.x0-glb_ds1[ds1_idx].tile_w) && (mx < glb_ds1edit.win_preview.x0 + glb_ds1edit.win_preview.w)) {
                my = base_y + x * glb_ds1[ds1_idx].tile_h / 2;
                wpreview_draw_w(ds1_idx, x, y, mx, my, z, select, FALSE); // lower walls
                wpreview_draw_f(ds1_idx, x, y, mx, my, z, select);        // floors
                wpreview_draw_s(ds1_idx, x, y, mx, my, z, select);        // shadows of dt1
            }
        }
    }

    // loop 1B : shadows of objects
    objdraw_cur_idx = 0;
    for (y=0; y<glb_ds1[ds1_idx].height; y++) {
        base_x = y * -glb_ds1[ds1_idx].tile_w / 2;
        base_y = y * glb_ds1[ds1_idx].tile_h / 2;
        for (x=0; x<glb_ds1[ds1_idx].width; x++) {
            select = FALSE;
            if ((glb_ds1edit.mode == MOD_T) && (x==cx) && (y==cy)) {
                select = TRUE;
            }
            mx = base_x + x * glb_ds1[ds1_idx].tile_w / 2;
            if ((mx >= glb_ds1edit.win_preview.x0-glb_ds1[ds1_idx].tile_w) && (mx < glb_ds1edit.win_preview.x0 + glb_ds1edit.win_preview.w)) {
                // shadows of objects
                if (glb_ds1[ds1_idx].animations_layer_mask) {
                    wpreview_draw_obj_tile_shad(ds1_idx, x, y, & objdraw_cur_idx);
                }
            }
        }
    }

    // loop 2 : objects with orderflag set to 1 (optional)
    objdraw_cur_idx = 0;
    if (glb_ds1[ds1_idx].animations_layer_mask) {
        for (y=0; y<glb_ds1[ds1_idx].height; y++) {
            base_x = y * -glb_ds1[ds1_idx].tile_w / 2;
            base_y = y * glb_ds1[ds1_idx].tile_h / 2;
            for (x=0; x<glb_ds1[ds1_idx].width; x++) {
                select = FALSE;
                if ((glb_ds1edit.mode == MOD_T) && (x==cx) && (y==cy)) {
                    select = TRUE;
                }
                mx = base_x + x * glb_ds1[ds1_idx].tile_w / 2;
                if ((mx >= glb_ds1edit.win_preview.x0-glb_ds1[ds1_idx].tile_w) && (mx < glb_ds1edit.win_preview.x0 + glb_ds1edit.win_preview.w)) {
                    // objects of this tile
                    wpreview_draw_obj_tile_1(ds1_idx, x, y, & objdraw_cur_idx);
                }
            }
        }
    }

    // loop 3 : upper walls, objects with orderflag set to 0 or 2
    objdraw_cur_idx = 0;
    for (y=0; y<glb_ds1[ds1_idx].height; y++) {
        base_x = y * -glb_ds1[ds1_idx].tile_w / 2;
        base_y = y * glb_ds1[ds1_idx].tile_h / 2;
        for (x=0; x<glb_ds1[ds1_idx].width; x++) {
            select = FALSE;
            if ((glb_ds1edit.mode == MOD_T) && (x==cx) && (y==cy)) {
                select = TRUE;
            }
            mx = base_x + x * glb_ds1[ds1_idx].tile_w / 2;
            if ((mx >= glb_ds1edit.win_preview.x0-glb_ds1[ds1_idx].tile_w) && (mx < glb_ds1edit.win_preview.x0 + glb_ds1edit.win_preview.w)) {
                my = base_y + x * glb_ds1[ds1_idx].tile_h / 2;
                wpreview_draw_w(ds1_idx, x, y, mx, my, z, select, TRUE);  // upper walls

                // objects of this tile
                if (glb_ds1[ds1_idx].animations_layer_mask) {
                    wpreview_draw_obj_tile_0_2(ds1_idx, x, y, & objdraw_cur_idx);
                }
            }
        }
    }

    // loop 4 : roofs
    for (y=0; y<glb_ds1[ds1_idx].height; y++) {
        base_x = y * -glb_ds1[ds1_idx].tile_w / 2;
        base_y = y * glb_ds1[ds1_idx].tile_h / 2;
        for (x=0; x<glb_ds1[ds1_idx].width; x++) {
            select = FALSE;
            if ((glb_ds1edit.mode == MOD_T) && (x==cx) && (y==cy)) {
                select = TRUE;
            }
            mx = base_x + x * glb_ds1[ds1_idx].tile_w / 2;
            if ((mx >= glb_ds1edit.win_preview.x0-glb_ds1[ds1_idx].tile_w) && (mx < glb_ds1edit.win_preview.x0 + glb_ds1edit.win_preview.w)) {
                my = base_y + x * glb_ds1[ds1_idx].tile_h / 2;
                wpreview_draw_r (ds1_idx, x, y, mx, my, z, select); // roofs
            }
        }
    }

    // loop 5 : special tiles (optional)
    if (glb_ds1[ds1_idx].special_layer_mask) {
        for (y=0; y<glb_ds1[ds1_idx].height; y++) {
            base_x = y * -glb_ds1[ds1_idx].tile_w / 2;
            base_y = y * glb_ds1[ds1_idx].tile_h / 2;
            for (x=0; x<glb_ds1[ds1_idx].width; x++) {
                select = FALSE;
                if ((glb_ds1edit.mode == MOD_T) && (x==cx) && (y==cy)) {
                    select = TRUE;
                }
                mx = base_x + x * glb_ds1[ds1_idx].tile_w / 2;
                if ((mx >= glb_ds1edit.win_preview.x0-glb_ds1[ds1_idx].tile_w) && (mx < glb_ds1edit.win_preview.x0 + glb_ds1edit.win_preview.w)) {
                    my = base_y + x * glb_ds1[ds1_idx].tile_h / 2;
                    wpreview_draw_sp(ds1_idx, x, y, mx, my, z, select); // special
                }
            }
        }
    }

    // loop 6 : walkable infos (optional)
    switch(glb_ds1[ds1_idx].walkable_layer_mask) {
        case 1  : fptr_wi = wpreview_draw_simple_wi; break;
        case 2  : fptr_wi = wpreview_draw_wi;        break;
        default : fptr_wi = NULL;
    }
    if (fptr_wi != NULL) {
        for (y=0; y<glb_ds1[ds1_idx].height; y++) {
            base_x = y * -glb_ds1[ds1_idx].tile_w / 2;
            base_y = y * glb_ds1[ds1_idx].tile_h / 2;
            for (x=0; x<glb_ds1[ds1_idx].width; x++) {
                mx = base_x + x * glb_ds1[ds1_idx].tile_w / 2;
                if ((mx >= glb_ds1edit.win_preview.x0-glb_ds1[ds1_idx].tile_w) && (mx < glb_ds1edit.win_preview.x0 + glb_ds1edit.win_preview.w)) {
                    my = base_y + x * glb_ds1[ds1_idx].tile_h / 2;
                    if ((my >= glb_ds1edit.win_preview.y0-glb_ds1[ds1_idx].tile_h) && (my < glb_ds1edit.win_preview.y0 + glb_ds1edit.win_preview.h)) {
                        misc_search_walk_infos(ds1_idx, x, y, walkinfo);
                        fptr_wi(mx, my, z, walkinfo);
                    }
                }
            }
        }
    }

    // tile grid
    if (glb_ds1edit.display_tile_grid == TRUE) {
        wpreview_draw_tile_grid(ds1_idx);
    }

    // npc paths
    if (glb_ds1edit.mode == MOD_P) {
        wpreview_draw_paths_1obj(ds1_idx, pwin->obj_idx);
    } else if (glb_ds1[ds1_idx].paths_layer_mask) {
        wpreview_draw_paths(ds1_idx);
    }

    // objects infos
    if (glb_ds1edit.mode == MOD_O) {
        editobj_draw_obj_lab(ds1_idx, TRUE);
        editobj_draw_obj_lab(ds1_idx, FALSE);
        if (glb_ds1[ds1_idx].draw_edit_obj) {
            editobj_draw_edit_obj(ds1_idx);
        }
    } else if (glb_ds1[ds1_idx].objects_layer_mask != OL_NONE) {
        wpreview_draw_objects(ds1_idx);
    }

    // path infos window
    if (glb_ds1edit.mode == MOD_P) {
        editpath_draw(ds1_idx, mouse_x, mouse_y, mouse_b, cx, cy);
    }

    // help window for accurate sub-tile flags
    if ((glb_ds1[ds1_idx].walkable_layer_mask == 2) && (glb_ds1[ds1_idx].subtile_help_display)) {
        x1 = glb_ds1edit.screen_buff->w - glb_ds1edit.subtile_help->w - 10;
        x2 = x1 + glb_ds1edit.subtile_help->w;
        y1 = glb_ds1edit.screen_buff->h - glb_ds1edit.subtile_help->h - 20;
        y2 = y1 + glb_ds1edit.subtile_help->h;
        blit(glb_ds1edit.subtile_help, glb_ds1edit.screen_buff, 0, 0, x1, y1, x2, y2);
        rect(glb_ds1edit.screen_buff, x1-1, y1-1, x2+1, y2+1, 255);
    }

    glb_ds1edit.win_preview.w  = old_screen_width;
    glb_ds1edit.win_preview.h  = old_screen_height;
    glb_ds1edit.win_preview.x0 = old_screen_x0;
    glb_ds1edit.win_preview.y0 = old_screen_y0;
    glb_config.screen.width        = old_screen_width;
    glb_config.screen.height       = old_screen_height;

    return 0;
}

#ifdef WIN32
#pragma warning (pop)
#endif
#ifndef _ANIMDATA_H_

#define _ANIMDATA_H_

UBYTE animdata_hash_value   (char * name);
void  animdata_load         (void);
int   animdata_get_cof_info (char * name, long * fpd, long * speed);

#endif
#ifndef _ANIM_H_

#define _ANIM_H_

int     anim_load_dcc      (char * name, COF_S * cof, int lay_idx, long user_dir, UBYTE * palshift);
COF_S * anim_load_cof      (char * base, char * tok, char * mod, char * clas, long user_dir, int obj_line, int progress);
COF_S * anim_load_desc_gfx (int i, int progress);
int     anim_destroy_cof   (COF_S * cof);
void    anim_update_gfx    (int progress);
int     anim_exit          (void);


#endif
#ifndef _DC6_INFO_H_

#define _DC6_INFO_H_

void dc6_decomp_norm (void * src, BITMAP * dst, long size, int x0, int y0);
void dc6_decomp_cmap (void * src, BITMAP * dst, long size, int x0, int y0, UBYTE * cmap);
int  anim_load_dc6   (char * name, COF_S * cof, int lay_idx, long user_dir, UBYTE * palshift);

#endif
#ifndef _DCC_INFO_H_

#define _DCC_INFO_H_


#define DCC_MAX_DIR    32
#define DCC_MAX_FRAME 256

#define DCC_MAX_PB_ENTRY 85000


char dcc_error[512]; // if an error is found while using a function of this
                     // dcc "library", this variable contain a string that
                     // explain what happened. You should display it somewhere
                     // to inform the user

int dcc_bits_width_table[16]; // will be initialized by dcc_decode()

typedef struct DCC_BOX_S
{
   long xmin;
   long ymin;
   long xmax;
   long ymax;
   long width;
   long height;
} DCC_BOX_S;

typedef struct DCC_CELL_S
{
   int    x0, y0;  // for frame cells in stage 2
   int    w, h;

   int    last_w, last_h;   // width & size of the last frame cell that used
                            // this buffer cell (for stage 2)
   int    last_x0, last_y0;
   
   BITMAP * bmp;   // sub-bitmap in the buffer bitmap
} DCC_CELL_S; // maybe I'll make 2 kind of cells, 1 for frame-buffer cells,
              // the other for the frame cells...

typedef struct DCC_FRAME_S
{
   UDWORD variable0;
   UDWORD width;
   UDWORD height;
   long   xoffset;
   long   yoffset;
   UDWORD optional_bytes;
   UDWORD coded_bytes;

   UBYTE  * optional_bytes_data;

   // next var : UBYTE should be enough
   //    but my bitstream reading function need a 32 bits wide variable
   UDWORD bottom_up;

   // cells infos
   DCC_CELL_S * cell;
   int        nb_cells_w;
   int        nb_cells_h;

   // not in file, for my own purpose
   DCC_BOX_S box;

   // final bitmap
   BITMAP * bmp;
   
} DCC_FRAME_S;

typedef struct DCC_BITSTREAM_S
{
   UBYTE  * data;      // pointer to the start of the bitstream
   UDWORD size;        // size of the bitstream, in bits
   UDWORD cur_byte;    // byte cursor
   UBYTE  cur_bit;     // bit cursor in the byte of current byte cursor
                       //    (from 0 to 7 : lowest bit to highest bit)
   UDWORD cur_bit_num; // bit cursor in the bitstream (not in the byte)
                       //    this also indicate the # of bits already read
} DCC_BITSTREAM_S;

// PixelBuffer entry
typedef struct DCC_PB_ENTRY_S
{
   UBYTE      val[4];
   int        frame;
   int        frame_cell_index;
} DCC_PB_ENTRY_S;

typedef struct DCC_DIRECTION_S
{
   UDWORD outsize_coded;
   UDWORD compression_flag;

   // next var : UBYTE should be enough
   //    but my bitstream reading function need a 32 bits wide variable
   UDWORD          variable0_bits;
   UDWORD          width_bits;
   UDWORD          height_bits;
   UDWORD          xoffset_bits;
   UDWORD          yoffset_bits;
   UDWORD          optional_bytes_bits;
   UDWORD          coded_bytes_bits;

   // bitstreams
   UDWORD          equal_cell_bitstream_size;
   UDWORD          pixel_mask_bitstream_size;
   UDWORD          encoding_type_bitstream_size;
   UDWORD          raw_pixel_bitstream_size;
   DCC_BITSTREAM_S equal_cell_bitstream;
   DCC_BITSTREAM_S pixel_mask_bitstream;
   DCC_BITSTREAM_S encoding_type_bitstream;
   DCC_BITSTREAM_S raw_pixel_bitstream;
   DCC_BITSTREAM_S pixel_code_and_displacment_bitstream;
   
   // frame buffer size, in # of cells, used in stage 2
   int             nb_cells_w;
   int             nb_cells_h;
   BITMAP          * bmp;        // frame buffer bitmap
   DCC_CELL_S      * buffer_ptr; // frame buffer cells
   
   // pixel buffer (1 entry = 4 pixels code & some other datas)
   DCC_PB_ENTRY_S  * pixel_buffer;
   int             pb_nb_entry;

   // colors present in the frame
   UBYTE           pixel_values[256]; // for pixel code color conversion

   // not in file, for my own purpose
   DCC_BOX_S       box;
} DCC_DIRECTION_S;

typedef struct DCC_HEADER_S
{
   UBYTE file_signature;
   UBYTE version;
   UBYTE directions;
   long  frames_per_dir;
   long  tag; // always 1. A data's presence bitfield maybe,
              //    like 0x01 = "final_dc6_size data present" ?
   long  final_dc6_size;
   long  dir_offset [DCC_MAX_DIR];

   int   already_decoded;
} DCC_HEADER_S;

typedef struct DCC_S
{
   UBYTE           * ptr; // copy of the dcc in mem
   long            size;  // size of the dcc in mem (in bytes)
   DCC_HEADER_S    header;
   DCC_DIRECTION_S direction [DCC_MAX_DIR];
   DCC_FRAME_S     frame     [DCC_MAX_DIR] [DCC_MAX_FRAME];
   DCC_BOX_S       box;
} DCC_S;

void    dcc_init                   (void);
int     dcc_read_bytes             (DCC_BITSTREAM_S * bs, int bytes_number, void * dest);
int     dcc_read_bits              (DCC_BITSTREAM_S * bs, int bits_number, int is_signed, UDWORD * dest );
int     dcc_frame_header_bitstream (DCC_S * dcc, DCC_BITSTREAM_S * bs, int d, int f);
void    dcc_init_dir_bitstream     (DCC_S * dcc, DCC_BITSTREAM_S * bs, int d);
int     dcc_optional_datas         (DCC_S * dcc, DCC_BITSTREAM_S * bs, int d);
int     dcc_other_bitstream_size   (DCC_S * dcc, DCC_BITSTREAM_S * bs, int d);
int     dcc_pixel_values_key       (DCC_S * dcc, DCC_BITSTREAM_S * bs, int d);
int     dcc_prepare_buffer_cells   (DCC_S * dcc, int d);
int     dcc_prepare_frame_cells    (DCC_S * dcc, int d, int f);
int     dcc_fill_pixel_buffer      (DCC_S * dcc, int d);
int     dcc_save_frame             (DCC_S * dcc, int d, int f, BITMAP * frm_bmp);
int     dcc_make_frames            (DCC_S * dcc, int d);
int     dcc_dir_bitstream          (DCC_S * dcc, int d);
int     dcc_file_header            (DCC_S * dcc);
int     dcc_decode                 (DCC_S * dcc, long dir_bitfield);
void    dcc_debug                  (DCC_S * dcc);
DCC_S * dcc_disk_load              (char * dcc_name);
DCC_S * dcc_mem_load               (void * mem_ptr, int mem_size);
void    dcc_destroy                (DCC_S * dcc);

#endif
#ifndef _DS1MISC_H_

#define _DS1MISC_H_

int  ds1_free              (int i);
void wprop_2_block         (int i, CELL_W_S * w_ptr);
void fprop_2_block         (int i, CELL_F_S * f_ptr);
void sprop_2_block         (int i, CELL_S_S * s_ptr);
void ds1_make_prop_2_block (int i);
int  ds1_read              (const char * ds1name, int ds1_idx, int new_width, int new_height);

#endif
#ifndef _DS1SAVE_H_

#define _DS1SAVE_H_

void ds1_save(int ds1_idx, int is_tmp_file);

#endif
#ifndef _DT1_DRAW_H_

#define _DT1_DRAW_H_

void draw_sub_tile_isometric (BITMAP * dst, int x0, int y0, UBYTE * data, int length);
void draw_sub_tile_normal    (BITMAP * dst, int x0, int y0, UBYTE * data, int length);

#endif
#ifndef _DT1MISC_H_

#define _DT1MISC_H_

int  dt1_already_loaded (char * dt1name, int * idx);
int  dt1_free           (int i);
int  dt1_del            (int i);
void dt1_bh_update      (int i);
void dt1_fill_subt      (SUB_TILE_S * ptr, int i, long tiles_ptr, int s);
void dt1_zoom           (BITMAP * src, int i, int b, int z);
void dt1_all_zoom_make  (int i);
void dt1_struct_update  (int i);
int  dt1_add            (char * dt1name);
int  dt1_add_special    (char * dt1name);

#endif
#ifndef _EDITOBJ_H_

#define _EDITOBJ_H_                                                           

int  editobj_qsort_helper_drawing_order (const void * e1, const void * e2);
void editobj_set_drawing_order          (int ds1_idx);
void editobj_make_obj_label             (int ds1_idx);
void editobj_draw_obj_lab               (int ds1_idx, int is_shadow);
void editobj_make_obj_desc              (int ds1_idx, int obj_idx);
void editobj_make_obj_new_id            (int ds1_idx, int obj_idx);
void editobj_clear_obj_lab_sel          (int ds1_idx);
void editobj_clear_obj_lab_over         (int ds1_idx);
void editobj_clear_obj_lab_flags        (int ds1_idx);
int  editobj_over_obj_lab               (int ds1_idx, int * ptr_t, int * ptr_o, int cx, int cy, int mx, int my);
void editobj_prepare_moving             (int ds1_idx);
int  editobj_moving_obj_lab             (int ds1_idx, int dcx, int dcy, int dmx, int dmy);
void editobj_end_move_obj_lab           (int ds1_idx);
void editobj_prepare_undo               (int ds1_idx);
void editobj_undo                       (int ds1_idx);
void editobj_del_obj                    (int ds1_idx);
void editobj_copy_obj                   (int ds1_idx);
// void editobj_search_copy_center         (int ds1_idx, int * cx, int * cy);
// int  editobj_center_before_copy         (int ds1_idx, int * cx0, int * cy0, int * mx,  int * my);
int  editobj_count_sel_obj              (int ds1_idx);
int  editobj_insert_obj                 (int ds1_idx, int cx, int cy);
void editobj_prepare_edit_obj_win       (int ds1_idx, int obj_idx);
void editobj_draw_edit_obj              (int ds1_idx);
int  editobj_edit_obj                   (int ds1_idx, int * edit_end, int mx, int my, int mb);
int  editobj_handler                    (int ds1_idx, int cx, int cy, int mx, int my, int mb);

#endif
#ifndef _EDITPATH_H_

#define _EDITPATH_H_

int  editpath_mouse_in            (int ds1_idx, int mx, int my);
void editpath_init                (int ds1_idx);
void editpath_search_selected_obj (int ds1_idx);
void editpath_draw                (int ds1_idx, int mx, int my, int mb, long tx, long ty);

#endif
#ifndef _EDITTILE_H_

#define _EDITTILE_H_                                                           

// COPY / PASTE MANAGMENT
void edittile_middle_select               (int ds1_idx, int * start_x, int * start_y);
void edittile_paste_prepare               (int ds1_idx);
void edittile_paste_undo                  (int ds1_idx);
void edittile_paste_preview               (int ds1_idx, int dx, int dy, PASTE_POS_S * p);
void edittile_paste_final                 (int ds1_idx);

// DELETE TILES MANAGMENT
void edittile_delete_selected_tiles       (int ds1_idx);
void edittile_delete_selected_tiles2      (int ds1_idx);

// MODIFY SELECTION MANAGMENT
void edittile_deselect_one                (int ds1_idx, int x, int y);
void edittile_deselect_one_completly      (int ds1_idx, int x, int y);
void edittile_select_one                  (int ds1_idx, int x, int y);
void edittile_select_new_one              (int ds1_idx, int x, int y);
void edittile_identical                   (int ds1_idx, IT_ENUM itype, int tx, int ty);

// HIDE / SHOW (UN-HIDE) MANAGMENT
void edittile_unhide_all                  (int ds1_idx);
void edittile_hide_add_one                (int ds1_idx, int x, int y);

// TEMP SELECTION MANAGMENT
void edittile_delete_all_tmpsel           (int ds1_idx);
void edittile_add_tmpsel_one              (int ds1_idx, int x, int y);
void edittile_set_tmpsel                  (int ds1_idx, TMP_SEL_S * s);
void edittile_change_to_new_permanent_sel (int ds1_idx, TMP_SEL_S * s);
void edittile_change_to_add_permanent_sel (int ds1_idx, TMP_SEL_S * s);
void edittile_change_to_hide_sel          (int ds1_idx, TMP_SEL_S * s);
void edittile_change_to_del_sel           (int ds1_idx, TMP_SEL_S * s);

#endif
#ifndef _ERROR_H_

#define _ERROR_H_


//#define FATAL_EXIT(...) do{ fprintf( stderr, "fatal error:\n"  ); fprintf( stderr, __VA_ARGS__ ); fflush(stderr); exit(DS1ERR_OTHER); }while(0)
#define FATAL_EXIT(...) do{ fprintf( stderr, "FATAL ERROR:::"  ); fprintf( stderr, __VA_ARGS__ ); fflush(stderr); exit(255); }while(0)
#define DEBUG_MESSAGE(...) do{ fprintf( stderr, "DEBUG MESSAGE:::"); fprintf( stderr, __VA_ARGS__ ); fflush(stderr);                     }while(0)
#define WARNING_MESSAGE(...) do{ fprintf( stderr, "WARNING:::"); fprintf( stderr, __VA_ARGS__ ); fflush(stderr);                     }while(0)

#endif
#ifndef _GFX_CUSTOM_H_

#define _GFX_CUSTOM_H_

void stretch_trans_sprite_8bpp(BITMAP * dst, BITMAP * sprite, int x0, int y0, int div);
void stretch_trans_shadow_8bpp(BITMAP * dst, BITMAP * sprite, int x0, int y0, int div, UBYTE * cmap_ptr, int offy);

#endif
#ifndef _INICREAT_H_

#define _INICREAT_H_

void ini_create (char * ininame);

#endif
#ifndef _INIREAD_H_

#define _INIREAD_H_

void ini_read (char * ininame);

#endif
#ifndef _INTERFAC_H_

#define _INTERFAC_H_

void interfac_user_handler (int start_ds1_idx);

#endif
#ifndef _MISC_H_

#define _MISC_H_

void   misc_pal_d2_2_vga               (int pal_idx);
int    misc_qsort_helper_block_table_1 (const void * e1, const void * e2);
int    misc_qsort_helper_block_table_2 (const void * e1, const void * e2);
void   misc_check_tiles_conflicts      (int ds1_idx);
void   misc_make_block_table           (int ds1_idx);
void   misc_read_gamma                 (void);
void   misc_update_pal_with_gamma      (void);
void   misc_pcx_put_d2_palette         (char * name, int pal_idx);
void   misc_make_cmaps_helper          (const PALETTE pal, int x, int y, RGB * rgb);
void   misc_make_cmaps                 (void);
int    misc_load_pal_from_disk         (int pal_idx);
void   misc_save_pal_on_disk           (int pal_idx, UBYTE * d2_pal_ptr);
int    misc_my_fgets                   (char * dst, int max, FILE * in);
char * misc_search_name                (char * tmp);
void   misc_open_1_ds1                 (int ds1_idx, char * name, int type, int def, int new_width, int new_height);
void   misc_open_several_ds1           (char * filename);
void   misc_walkable_tile_info_pcx     (void);
int    misc_seach_block_or4            (int ds1_idx, BLOCK_TABLE_S * bt_ptr, int b, int m, int s);
void   misc_search_walk_infos          (int ds1_idx, int x, int y, UBYTE * dsttable);
int    misc_load_mpq_file              (char * filename, char ** buffer, long * buf_len, int output);
int    misc_get_txt_column_num         (RQ_ENUM txt_idx, char * col_name);
void   misc_open_1_ds1_force_dt1       (int ds1_idx);
void   misc_pl2_correct                (int i);
int    misc_cmd_line_parse             (int argc, char ** argv);
/*
void   misc_restore_mouse_background   (void);
void   misc_save_mouse_background      (int x, int y);
void   misc_draw_mouse_cursor          (int x, int y, int restore_background_first);
void   misc_set_mouse_cursor           (BITMAP * sprite);
*/
void   misc_draw_screen                (int mx, int my);
int    misc_increase_ds1_objects_max   (int ds1_idx, long nb_objects);
#endif
#ifndef _MSG_QUIT_H_

#define _MSG_QUIT_H_

int msg_quit_main(void);

#endif
#ifndef _MSG_SAVE_H_

#define _MSG_SAVE_H_

int msg_save_main(void);

#endif
#ifndef _WINDS1EDIT_STRUCTS_H_

#define _WINDS1EDIT_STRUCTS_H_

// for allegro with MSVC6/7/2008, in console version
#define USE_CONSOLE

#include "types.h"
#include <stdio.h>
#include <string.h>
#include <allegro.h>
#include "mpqtypes.h"

#define MAX_MPQ_FILE           4
#define MAX_MOD_DIR            1
#define DT1_IN_DS1_MAX        33
#define DS1_MAX              100
#define DT1_MAX              300
#define ACT_MAX                5
#define FLOOR_MAX_LAYER        2
#define SHADOW_MAX_LAYER       1
#define TAG_MAX_LAYER          1
#define WALL_MAX_LAYER         4
#define OBJ_MAX_START        100
#define OBJ_MAX_GRANULARITY   50
#define WINDS1EDIT_PATH_MAX  100

#define TXT_COL_NAME_LENGTH   30

#define FLG_SELECTED      1
#define FLG_HIDE          2
#define FLG_TMP_SELECT    4
#define FLG_COPY_INFO     8
#define FLG_COPY_STATE   16

// these ones are only for the Edit Objects mode
#define FLG_MOUSE_OVER   32
#define FLG_MOVING       64
#define FLG_ACTIVATED   128

#define IS_SELECTED(x)    ((x) & FLG_SELECTED)
#define IS_HIDE(x)        ((x) & FLG_HIDE)
#define IS_TMP_SELECT(x)  ((x) & FLG_TMP_SELECT)
#define IS_COPY_INFO(x)   ((x) & FLG_COPY_INFO)
#define IS_COPY_STATE(x)  ((x) & FLG_COPY_STATE)
#define IS_MOUSE_OVER(x)  ((x) & FLG_MOUSE_OVER)
#define IS_MOVING(x)      ((x) & FLG_MOVING)
#define IS_ACTIVATED(x)   ((x) & FLG_ACTIVATED)

#define SET_SELECTED(x)   ((x) |= FLG_SELECTED)
#define SET_HIDE(x)       ((x) |= FLG_HIDE)
#define SET_TMP_SELECT(x) ((x) |= FLG_TMP_SELECT)
#define SET_COPY_INFO(x)  ((x) |= FLG_COPY_INFO)
#define SET_COPY_STATE(x) ((x) |= FLG_COPY_STATE)
#define SET_MOUSE_OVER(x) ((x) |= FLG_MOUSE_OVER)
#define SET_MOVING(x)     ((x) |= FLG_MOVING)
#define SET_ACTIVATED(x)  ((x) |= FLG_ACTIVATED)

#define DEL_SELECTED(x)   ((x) &= ~FLG_SELECTED)
#define DEL_HIDE(x)       ((x) &= ~FLG_HIDE)
#define DEL_TMP_SELECT(x) ((x) &= ~FLG_TMP_SELECT)
#define DEL_COPY_INFO(x)  ((x) &= ~FLG_COPY_INFO)
#define DEL_COPY_STATE(x) ((x) &= ~FLG_COPY_STATE)
#define DEL_MOUSE_OVER(x) ((x) &= ~FLG_MOUSE_OVER)
#define DEL_MOVING(x)     ((x) &= ~FLG_MOVING)
#define DEL_ACTIVATED(x)  ((x) &= ~FLG_ACTIVATED)

// Data Flags for undo, tells whiwh data are to be saved (for 1 layer)
#define DF_P1  1
#define DF_P2  2
#define DF_P3  4
#define DF_P4  8
#define DF_OR 16
#define DF_BT 32
#define DF_FL 64

// Message Windows
#define MW_SHORTCUT_NUM        5
#define MW_COMBINATION_KEY_NUM 5

// colormaps index for COF effect
#define COF_25TRANS       53
#define COF_50TRANS      309
#define COF_75TRANS      565
#define COF_ALPHA        821
#define COF_LUMINANCE   1077
#define COF_ALPHABRIGHT 1461

extern char      glb_tiles_path       [30];
extern char      glb_ds1edit_data_dir [80];
extern char      glb_ds1edit_tmp_dir  [80];
extern GLB_MPQ_S glb_mpq_struct       [MAX_MPQ_FILE];

typedef struct SCREEN_S
{
    int width;
    int height;
    int depth;
    int refresh;
} SCREEN_S;

typedef struct XY_S
{
    int x;
    int y;
} XY_S;

typedef struct SCROLL_S
{
    XY_S keyb;
    XY_S mouse;
    XY_S edit;
    int  obj_edit;
} SCROLL_S;

typedef enum GC_ENUM
{
    GC_060, GC_062, GC_064, GC_066, GC_068,
    GC_070, GC_072, GC_074, GC_076, GC_078,
    GC_080, GC_082, GC_084, GC_086, GC_088,
    GC_090, GC_092, GC_094, GC_096, GC_098,
    GC_100,
    GC_110, GC_120, GC_130, GC_140, GC_150,
    GC_160, GC_170, GC_180, GC_190, GC_200,
    GC_210, GC_220, GC_230, GC_240, GC_250,
    GC_260, GC_270, GC_280, GC_290, GC_300,
    GC_MAX
} GC_ENUM;

typedef struct GAMMA_S
{
    char    str[5];
    GC_ENUM val;
} GAMMA_S;

extern GAMMA_S glb_gamma_str[GC_MAX];

typedef struct CONFIG_S
{
    int      fullscreen;
    char     * mpq_file[MAX_MPQ_FILE];
    char     * mod_dir[MAX_MOD_DIR];
    SCREEN_S screen;
    SCROLL_S scroll;
    GC_ENUM  gamma;
    XY_S     mouse_speed;
    int      normal_type2;
    int      always_max_layers;
    int      stretch_sprites;
    int      winobj_scroll_keyb;
    int      winobj_scroll_mouse;
    int      center_zoom;
    int      nb_type1_per_act;
    int      nb_type2_per_act;
    int      minimize_ds1;
    int      lower_speed_zoom_out;
    int      workspace_enable;
} CONFIG_S;

extern CONFIG_S glb_config;

typedef struct WIN_PREVIEW_S
{
    int x0;
    int y0;
    int w;
    int h;
} WIN_PREVIEW_S;

typedef enum BUT_STATE_E
{
    BS_OFF,
    BS_ON
} BUT_STATE_E; // button state

typedef struct BUTTON_S
{
    int         x0, y0;
    int         w, h;
    int         active;
    int         tab_have_tiles;
    BUT_STATE_E state;
    int         mouse_over;  // TRUE / FALSE
    BITMAP      * bmp[2];    // [0]=OFF, [1]=ON
} BUTTON_S;

typedef enum BLK_TYP_E
{
    /* null    */ BT_NULL,
    /* floors  */ BT_STATIC,  BT_ANIMATED,
    /* walls   */ BT_WALL_UP, BT_WALL_DOWN, BT_ROOF, BT_SPECIAL, BT_WALL_ANIMATED,
    /* shadows */ BT_SHADOW,
    BT_MAX
} BLK_TYP_E; // block type

typedef enum BUT_TYP_E
{
    /* null      */ BU_NULL,
    /* floors    */ BU_FLOOR1, BU_FLOOR2,
    /* shadows   */ BU_SHADOW,
    /* walls     */ BU_WALL1,  BU_WALL2,  BU_WALL3,  BU_WALL4,
    /* ok/cancel */ BU_OK,     BU_CANCEL,
    /* random    */ BU_VIEW_RAND,
    BU_MAX
} BUT_TYP_E; // button type

typedef struct WIN_ELEMENT_S
{
    // border (outside)
    int        b_x0, b_y0; // upper-left corner, in the screen
    RLE_SPRITE * border;

    // inside
    int        i_x0, i_y0; // upper-left corner, in the screen
    BITMAP     * inside;
} WIN_ELEMENT_S;


typedef struct SUB_ELM_S
{
    int bt_idx_tab;
    int x1;
    int y1;
    int x2;
    int y2;
    int is_draw;
} SUB_ELM_S;

typedef struct MAIN_LINE_S
{
    SUB_ELM_S * sub_elm;
    int       bt_idx_num;   // # of elements in * bt_idx_tab
    int       max_height;   // max height (in pixels) for this line
} MAIN_LINE_S;

typedef struct WIN_EDIT_S
{
    BUTTON_S      button [BU_MAX];
    BUTTON_S      tab    [BT_MAX];
    WIN_ELEMENT_S w_preview;
    WIN_ELEMENT_S w_tiles;
    MAIN_LINE_S   * main_line_tab[BT_MAX];
    int           main_line_num[BT_MAX];
    BITMAP        * tmp_edit;
} WIN_EDIT_S;

typedef enum ZOOM_E
{
    ZM_11,
    ZM_12,
    ZM_14,
    ZM_18,
    ZM_116,
    ZM_MAX
} ZOOM_E;

// color map type
typedef enum CMAP_E
{
    CM_SELECT,
    CM_TRANS,
    CM_SHADOW,
    CM_MAX
} CMAP_E;

typedef enum COL_E
{
    COL_FLOOR    =  29, // dark  grey,   selected without mouse
    COL_FLOOR_M  =  32, // light grey,   selected with mouse
    COL_WALL     = 151, // dark  blue,   selected without mouse
    COL_WALL_M   = 162, // light blue,   selected with mouse
    COL_MOUSE    = 255, // white,        not selected, with mouse
    COL_TMPSEL   =  92, // orange,       left-click selection, without mouse
    COL_TMPSEL_M = 108, // orange,       left-click selection, with mouse
    COL_PASTE_OK = 132, // green,        no conflicts when pasting
    COL_PASTE_KO =  98, // red,          conflicts when pasting
    COL_SHADOW   = 168  // yellow        shadow easy to view
} COL_E; // tile's color index in color map

typedef enum MODE_E
{
    MOD_T, // Edit Tiles
    MOD_O, // Edit Objects
    MOD_P, // Edit Paths
    MOD_L, // Preview with Lights
    MOD_MAX
} MODE_E;

// cof & dcc
#define COMPOSIT_NB 16

typedef struct LAY_INF_S
{
    UBYTE  shad_a;
    UBYTE  shad_b;
    UBYTE  trans_a;
    UBYTE  trans_b;
    char   wclass[4];               // weapon class

    // editor only
    int    bmp_num;
    BITMAP ** bmp;
    int    off_x;
    int    off_y;
    int    last_good_frame;
} LAY_INF_S;

typedef struct COF_S
{
    UBYTE     lay;
    UBYTE     fpd; // frames per direction
    UBYTE     dir;
    long      xoffset;
    long      yoffset;
    LAY_INF_S lay_inf[COMPOSIT_NB];
    UBYTE     * priority;
    long      cur_frame;
    int       cur_dir;
    long      spd_mul;
    long      spd_div;
    long      spd_mod; // = is (mul % div), for extra precision
    long      orderflag; // from data\global\excel\objects.txt, 0 1 or 2
} COF_S;

typedef struct OBJ_DESC_S
{
    int   act;
    int   type;
    int   id;
    char  * desc;
    COF_S * cof;
    int   objects_line;
    int   monstats_line;
    int   usage_count;
} OBJ_DESC_S;

// struct for convenience, for undo
// if bit is set, indicate that this data of this layer is to be save
typedef struct UNDO_DAT_FLG_S
{
    UBYTE f [FLOOR_MAX_LAYER];
    UBYTE s [SHADOW_MAX_LAYER];
    UBYTE w [WALL_MAX_LAYER];
} UNDO_DAT_FLG_S;

typedef struct UNDO_S
{
    FILE           * fptr;
    long           buf_num;
    long           cur_buf_num;
    char           name[150];
    char           tag[4];
    int            in_seg;
    long           seg_offset;
    UBYTE          seg_num;
    long           cell_offset;
    UBYTE          cell_num;
    UBYTE          old_x, old_y;
    UNDO_DAT_FLG_S dat_flg;
} UNDO_S;

typedef enum COL_TYPE_NM
{
    CT_NULL,
    CT_STR,
    CT_NUM
} COL_TYPE_NM;

typedef struct TXT_COL_S
{
    // for loading function
    char        name[TXT_COL_NAME_LENGTH]; // column header

    // fill by loading function
    int         pos;      // column index in the original file
    COL_TYPE_NM type;     // string or num
    int         size;     // strlen()+1 or sizeof(long)
    int         offset;   // offset in a line to get the data
} TXT_COL_S;

typedef struct TXT_S
{
    char      * data;           // buffer having all lines
    int       line_num;         // number of lines
    int       line_size;        // size of 1 line (in bytes)
    int       nb_required_cols; // number of required columns
    int       col_num;          // total number of columns (required + user defined filters)
    TXT_COL_S * col;            // pointer on a table of TXT_COL_S
} TXT_S;

#pragma pack(1)

typedef struct ANIM_DATA_RECORD_S
{
    char  cof_name[8];
    long  frames_per_dir;
    long  speed;
    UBYTE flags[144];
} ANIM_DATA_RECORD_S;

#pragma pack()

typedef struct ANIM_DATA_S
{
    void               * buffer;
    long               buffer_size;
    ANIM_DATA_RECORD_S * block_pointer [256];
    int                nb_records      [256];
} ANIM_DATA_S;

// command-line parameters
typedef struct CMD_LINE_S
{
    // ptr to ds1 filename, NULL if not used
    char * ds1_filename;

    // ptr to ini filename, NULL if not used
    char * ini_filename;

    // lvltype.txt ID, -1 if not used
    int  lvltype_id;

    // lvlprest.txt DEF, -1 if not used
    int  lvlprest_def;

    // -resize : width parameter, >= 1, -1 if not used
    int  resize_width;

    // -resize : height parameter, >= 1, -1 if not used
    int  resize_height;

    // -force_pal : number is act of palette, 0 to 4, -1 if not used
    int  force_pal_num;

    // -no_check_act option (don't compare .ds1 and .txt acts for safety), TRUE / FALSE
    int  no_check_act;

    // -dt1_list : number of file, 1 to DT1_IN_DS1_MAX, -1 if not used
    int  dt1_list_num;

    // -dt1_list : DT1_IN_DS1_MAX ptr to dt1 filenames, unused slots are set to NULL
    char * dt1_list_filename[DT1_IN_DS1_MAX];

    // -debug : activate debug mode
    int  debug_mode;

    // -no_vis_debug : desactivate debug infos on Vis Tiles that have graphics
    int  no_vis_debug;
} CMD_LINE_S;

// Tile Grid states
typedef enum TILEGRID_ENUM
{
    TG_OFF = 0,   // disable
    TG_OVERFLOOR, // enable, over floor but under walls
    TG_OVERWALL,  // enable, over all tiles
    TG_MAX
} TILEGRID_ENUM;

typedef struct GLB_DS1EDIT_S
{
    UBYTE         * d2_pal [ACT_MAX];
    long          pal_size [ACT_MAX];
    PALETTE       vga_pal  [ACT_MAX];
    PALETTE       dummy_pal;
    int           pal_loaded[ACT_MAX];
    BITMAP        * mouse_cursor[MOD_MAX];
    WIN_PREVIEW_S win_preview;
    WIN_EDIT_S    win_edit;
    BITMAP        * big_screen_buff; // for safety about cliping
    BITMAP        * screen_buff;
    BITMAP        * video_page[2];
    int           video_page_num;
    UBYTE         gamma_table[GC_MAX][256];
    GC_ENUM       cur_gamma;
    volatile int  old_fps;
    volatile int  fps;
    volatile int  ticks_elapsed;
    int           screenshot_num;
    COLOR_MAP     cmap[CM_MAX][ACT_MAX];
    OBJ_DESC_S    * obj_desc;
    int           obj_desc_num; // # of objects's description
    MODE_E        mode;
    RLE_SPRITE    * subtile_flag[9][ZM_MAX][25];
    RLE_SPRITE    * subtile_flag_combination[256][ZM_MAX][25];
    RLE_SPRITE    * subtile_nowalk[ZM_MAX][25];
    RLE_SPRITE    * subtile_nojump[ZM_MAX][25];
    BITMAP        * subtile_help;
    int           night_mode;
    TXT_S         * lvltypes_buff;
    TXT_S         * lvlprest_buff;
    TXT_S         * obj_buff;
    TXT_S         * objects_buff;
    int           new_dir1[1],
                  new_dir4[4],
                  new_dir8[8],
                  new_dir16[16],
                  new_dir32[32];
    int           obj_order_ds1_idx;
    int           obj_sub_tile_order[5][5];
  //char          version[15];
    int           current_refresh_rate;
    int           col_obj_id;
    int           col_objects_id;
    int           col_frame_delta[8];
    int           col_orderflag[8];
    ANIM_DATA_S   anim_data;
    CMD_LINE_S    cmd_line;
    int           ds1_group_idx;
    int           show_2nd_row;
    char          strtmp[512];
    TILEGRID_ENUM display_tile_grid;
    //char          * version_build;
    //char          * version_dll;
} GLB_DS1EDIT_S;

extern GLB_DS1EDIT_S glb_ds1edit;

typedef struct BLOCK_TABLE_S
{
    // key
    int       dt1_idx_for_ds1;
    long      main_index;
    long      orientation;
    long      sub_index;

    // datas
    int       dt1_idx;
    long      rarity;
    int       block_idx;
    BLK_TYP_E type;
    int       zero_line;
    int       roof_y;

    // conflicts managment
    char      conflict;
    char      used_by_game;   // True / False
    char      used_by_editor; // True / False

    // animated tile
    long      curr_frame;
    int       updated;
} BLOCK_TABLE_S;

typedef struct PATH_S
{
    long x;
    long y;
    long action;
    int  flags;
} PATH_S;

typedef struct OBJ_LABEL_S
{
    int rx, ry; // upper/left corner of the label, relative to the sub-cell
    // (in pixels, at zoom of 1:1)
    int w, h;   // width & height (pixels)
    int x0, y0; // pixels position on screen
    int flags;

    // for moving
    int old_rx;
    int old_ry;

} OBJ_LABEL_S;

typedef struct OBJ_S
{
    long        type;
    long        id;
    long        x;     // sub-cell X
    long        y;     // sub-cell Y
    long        ds1_flags;

    PATH_S      path[WINDS1EDIT_PATH_MAX];
    long        path_num;
    int         desc_idx;
    int         flags;
    OBJ_LABEL_S label;

    // for moving
    long         old_x;
    long         old_y;

    // for sorting
    long        tx; // tile X
    long        ty; // tile Y
    long        sx; // sub-tile X
    long        sy; // sub-tile Y

    // random starting animation frame
    UBYTE       frame_delta;
} OBJ_S;

typedef struct BOX_S
{
    int x1, y1, x2, y2;
} BOX_S;

typedef struct EDT_BUT_S
{
    BOX_S box;
    XY_S  txt;
    char  name[10];
    int   flags;
} EDT_BUT_S;

typedef enum EDT_BUT_E
{
    EB_OK, EB_CANCEL, EB_TYPE1, EB_TYPE2,
    EB_ACT1, EB_ACT2, EB_ACT3, EB_ACT4, EB_ACT5,
    EB_MAX
} EDT_BUT_E; // edit obj buttons

typedef struct WIN_EDT_OBJ_S
{
    // window itself
    int x0, y0;
    int w, h;
    int obj_idx;
    int cur_type;
    int start_act;
    int cur_act;

    // buttons
    EDT_BUT_S button[EB_MAX]; // OK, Cancel, Type1, Type2, ACT1, 2, 3, 4, 5

    // text
    int num;        // number of row to display
    int start;      // index of the win's 1st row
    int cur;        // current index, pointed by the mouse

    int desc_char;  // max chars of description
    int desc_start; // starting index in glb_ds1edit.obj_desc[]
    int desc_num;   // number of description for this act
    int desc_end;   // ending index
    int desc_cur;   // curent selected index (the object's one before editing)
} WIN_EDT_OBJ_S;

typedef struct CELL_W_S
{
    UBYTE prop1;
    UBYTE prop2;
    UBYTE prop3;
    UBYTE prop4;
    UBYTE orientation;
    int   bt_idx;
    UBYTE flags;
} CELL_W_S;

typedef struct CELL_F_S
{
    UBYTE prop1;
    UBYTE prop2;
    UBYTE prop3;
    UBYTE prop4;
    int   bt_idx;
    UBYTE flags;
} CELL_F_S;

typedef struct CELL_S_S // exactly the same struct for shadow as for the floor
{
    UBYTE prop1;
    UBYTE prop2;
    UBYTE prop3;
    UBYTE prop4;
    int   bt_idx;
    UBYTE flags;
} CELL_S_S;

typedef struct CELL_T_S
{
    // assume the data is 1 dword, and not 4 different bytes
    UDWORD num;
    UBYTE  flags;
} CELL_T_S;

typedef struct GROUP_S
{
    UDWORD tile_x;
    UDWORD tile_y;
    UDWORD width;
    UDWORD height;
    UDWORD unk;
} GROUP_S;

// Object Layer Enum
typedef enum OL_ENUM
{
    OL_NONE,
    OL_TYPEID,
    OL_SPEED,
    OL_DESC,
    OL_MAX
} OL_ENUM;

// color struct for path editing buttons
typedef struct PATH_EDIT_BUT_COL_S
{
    int bg;
    int fg;
    int border;
} PATH_EDIT_BUT_COL_S;

// buttons for path editing window
typedef struct PATH_EDIT_BUT_S
{
    int                 show;
    int                 x0, y0, w, h;
    char                * text;
    int                 text_x0;
    PATH_EDIT_BUT_COL_S col_on;
    PATH_EDIT_BUT_COL_S col_off;
} PATH_EDIT_BUT_S;

// enum of each path editing button
typedef enum PEB_E
{
    PEB_OK,
    PEB_CANCEL,
    PEB_ALLNEW,
    PEB_STOP,
    PEB_SETACTION,
    PEB_MAX
} PEB_E; // Path Editing Button enumeration

// enum of path editing window current mode
typedef enum PEM_E
{
    PEM_NONE,
    PEM_ALLNEW,
    PEM_MAX
} PEM_E; // Path Editing Mode enumeration

// path editing window data
typedef struct PATH_EDIT_WIN_S
{
    int x0, y0;          // screen position
    int w, h;            // dimensions in pixels
    int obj_idx;         // object index that is used, -1 = none
    int obj_dirty;       // if TRUE, need a click on the OK or CANCEL button
    // before another object can be edited
    int path_start_idx;  // first path index displayed

    // command buttons
    int but_x0, but_y0;  // screen position
    int but_w, but_h;    // dimensions in pixels
    PATH_EDIT_BUT_S button[PEB_MAX]; // buttons

    // colors
    int c_black;
    int c_white;
    int c_green;
    int c_darkgreen;
    int c_yellow;
    int c_gray;
    int c_darkgray;

    // coriginal values of the paths of the object we're working with
    PATH_S path_copy[WINDS1EDIT_PATH_MAX];
    int    path_copy_num;

    // current mode
    PEM_E mode;

    // current Action number
    long curr_action;

} PATH_EDIT_WIN_S;

typedef struct DS1_S
{
    char          dt1_idx[DT1_IN_DS1_MAX];
    int           dt1_mask[DT1_IN_DS1_MAX];
    int           txt_act;
    BLOCK_TABLE_S * block_table;
    int           bt_num;
    UBYTE         wall_layer_mask[WALL_MAX_LAYER];
    UBYTE         floor_layer_mask[FLOOR_MAX_LAYER];
    char          shadow_layer_mask[SHADOW_MAX_LAYER];
    OL_ENUM       objects_layer_mask;
    UBYTE         paths_layer_mask;
    UBYTE         walkable_layer_mask;
    UBYTE         animations_layer_mask;
    UBYTE         special_layer_mask;
    int           subtile_help_display;
    char          name[256];    // long filename with paths
    char          filename[50]; // short filename
    UNDO_S        undo;

    // from file
    long          version;
    long          tag_type;
    long          width;    // from file, +1
    long          height;   // from file, +1
    long          act;      // from file, +1

    // files in the ds1 (not used by the game)
    long          file_num;
    char          * file_buff;
    int           file_len;

    // floors
    CELL_F_S      * floor_buff,   // buffer for all floor layers
                  * floor_buff2;  // 2nd buffer, for copy/paste
    int           floor_buff_len; // sizeof the floor buffer (in bytes)
    int           floor_num;      // # of layers in floor buffer
    int           floor_line;     // width * floor_num
    int           floor_len;      // floor_line * height

    // shadow
    CELL_S_S      * shadow_buff,   // buffer for all shadow layers
                  * shadow_buff2;  // 2nd buffer, for copy/paste
    int           shadow_buff_len; // sizeof the shadow buffer (in bytes)
    int           shadow_num;      // # of layers in shadow buffer
    int           shadow_line;     // width * shadow_num
    int           shadow_len;      // shadow_line * height

    // walls
    CELL_W_S      * wall_buff,    // buffer for all wall layers
                  * wall_buff2;   // 2nd buffer, for copy/paste
    int           wall_buff_len;  // sizeof the wall buffer (in bytes)
    int           wall_num;       // # of layers in wall buffer
    int           wall_line;      // width * wall_num
    int           wall_len;       // wall_line * height

    // tag
    CELL_T_S      * tag_buff,   // buffer for all unk layers
                  * tag_buff2;  // 2nd buffer, for copy/paste
    int           tag_buff_len; // sizeof the unk buffer (in bytes)
    int           tag_num;      // # of layers in unk buffer
    int           tag_line;     // width * unk_num
    int           tag_len;      // unk_line * height

    // groups for tag layer
    long          group_num;
    int           group_size;
    GROUP_S       * group;

    // internal
    ZOOM_E        cur_zoom;
    int           tile_w;
    int           tile_h;
    int           height_mul;
    int           height_div;
    SCROLL_S      cur_scroll;

    // screen position and size for this ds1
    WIN_PREVIEW_S own_wpreview;

    // objects and npc paths (paths are in obj struct)
    int           * drawing_order;
    OBJ_S         * obj;
    OBJ_S         * obj_undo;
    long          obj_num;
    long          obj_num_undo;
    int           can_undo_obj;
    int           draw_edit_obj; // edit Type-Id of objects, FALSE / TRUE
    WIN_EDT_OBJ_S win_edt_obj;

    // current animated floor frame
    int           cur_anim_floor_frame;

    // path editing window of this ds1
    PATH_EDIT_WIN_S path_edit_win;

    // save count
    UDWORD save_count;

    // current number of objects
    long current_obj_max;
} DS1_S;

extern DS1_S * glb_ds1;

typedef struct BLOCK_S
{
    long       direction;
    WORD       roof_y;
    UBYTE      sound;
    UBYTE      animated;
    long       size_y;
    long       size_x;
    // long       zeros1;
    long       orientation;
    long       main_index;
    long       sub_index;
    long       rarity;
    /*
       UBYTE      unknown_a;
       UBYTE      unknown_b;
       UBYTE      unknown_c;
       UBYTE      unknown_d;
       */
    UBYTE      sub_tiles_flags[25];
    // int        zeros2[7];
    long       tiles_ptr;
    long       tiles_length;
    long       tiles_number;
    // int        zeros3[12];
} BLOCK_S;

typedef struct DT1_S
{
    int        ds1_usage; // current number of ds1 using this dt1
    char       name[80];
    void       * buffer;
    long       buff_len;
    long       x1; // signature (7)
    long       x2; // signature (6)
    long       block_num;
    long       bh_start;

    // block headers : block_num structs of BLOCK_S
    void       * bh_buffer;
    int        bh_buff_len;

    // all blocks in differents zoom format
    BITMAP     ** block_zoom[ZM_MAX]; // ZM_MAX tables of table of pointers
    //   to BITMAP
    int        bz_size[ZM_MAX];
} DT1_S;

extern DT1_S * glb_dt1;

typedef struct SUB_TILE_S
{
    WORD  x_pos;
    WORD  y_pos;
    //   WORD  unknown1;
    int   x_grid;
    int   y_grid;
    WORD  format;
    long  length;
    //   WORD  unknown2;
    long  data_offset;
} SUB_TILE_S;

typedef struct ORDER_DATA_S
{
    int idx;
    int height;
} ORDER_DATA_S;

typedef struct TMP_SEL_S
{
    enum type {TMP_NULL, TMP_NEW, TMP_ADD, TMP_DEL, TMP_HIDE} type;
    int start;
    int x1, y1, x2, y2, old_x2, old_y2;
} TMP_SEL_S;

typedef struct PASTE_POS_S
{
    int src_ds1_idx;
    int start;
    int start_x, start_y, old_x, old_y, old_ds1_idx;
    int is_cut;
    int cut_saved;
} PASTE_POS_S;

typedef enum IT_ENUM
{
    IT_NULL,
    IT_NEW,
    IT_ADD,
    IT_DEL
} IT_ENUM; // Identical Type

// txt required cols
typedef enum RQ_ENUM
{
    RQ_LVLTYPE,
    RQ_LVLPREST,
    RQ_OBJ,
    RQ_OBJECTS,
    RQ_MAX
} RQ_ENUM;

extern char ** glb_txt_req_ptr [RQ_MAX];

typedef struct WMSG_FGBG_S
{
    int fg;
    int bg;
} WMSG_FGBG_S;

typedef struct WMSG_BUTCOL_S
{
    int fg;
    int bg;
    int border;
} WMSG_BUTCOL_S;

typedef struct WMSG_BUTKEY_S
{
    int key [MW_COMBINATION_KEY_NUM]; // scancodes of max X keys combination
    int mb; // mouse buttons
} WMSG_BUTKEY_S;

typedef struct WMSG_BUT_S
{
    char          * text;
    int           right_spaces;
    WMSG_BUTCOL_S on;
    WMSG_BUTCOL_S off;
    WMSG_BUTKEY_S shortcut[MW_SHORTCUT_NUM];
} WMSG_BUT_S;

typedef struct WMSG_S
{
    int         font_width;
    int         font_height;
    char        * title;
    char        * text;
    WMSG_FGBG_S col_win;
    WMSG_FGBG_S col_title;
    WMSG_FGBG_S col_text;
    WMSG_BUT_S  * button;
} WMSG_S;

typedef enum DS1ERR_ENUM
{
    DS1ERR_OK        =   0,
    DS1ERR_INICREATE =   1,
    DS1ERR_CMDLINE   =   2,
    DS1ERR_NOHEIGHT  =   3,
    DS1ERR_INITMPQ   =   4,
    DS1ERR_OTHER     = 255
} DS1ERR_ENUM;

typedef enum WBITSTYPE_ENUM
{
    WBITSTYPE_UNKNOWN = 0,
    WBITSTYPE_SAME,
    WBITSTYPE_DIFFERENT
} WBITSTYPE_ENUM;

typedef struct WBITSDATA_S
{
    // mix of bits values for selected tiles
    CELL_F_S mix_f[FLOOR_MAX_LAYER];
    CELL_S_S mix_s[SHADOW_MAX_LAYER];
    CELL_W_S mix_w[WALL_MAX_LAYER];
    CELL_T_S mix_t[TAG_MAX_LAYER];

    // are each bit always the same for the entire selection of tiles ?
    WBITSTYPE_ENUM bit_type_f[FLOOR_MAX_LAYER ][ 4][8];
    WBITSTYPE_ENUM bit_type_s[SHADOW_MAX_LAYER][ 4][8];
    WBITSTYPE_ENUM bit_type_w[WALL_MAX_LAYER  ][ 5][8];
    WBITSTYPE_ENUM bit_type_t[TAG_MAX_LAYER   ][32];
} WBITSDATA_S;

// workspace datas saved in .ds1
typedef enum WRKSPC_ENUM
{
    WRKSPC_TILE_X = 0,   // tile x position in the middle of the screen
    WRKSPC_TILE_Y,       // tile y position in the middle of the screen
    WRKSPC_ZOOM,         // last zoom
    WRKSPC_VERSION,      // version
    WRKSPC_SAVE_COUNT,   // number of times the ds1 has been saved
    WRKSPC_MAX           // number of datas
} WRKSPC_ENUM;

typedef struct WRKSPC_DATAS_S{
    char * id;
} WRKSPC_DATAS_S;

extern WRKSPC_DATAS_S glb_wrkspc_datas[WRKSPC_MAX];

// debug files
extern char * glb_path_lvltypes_mem;
extern char * glb_path_lvltypes_def;
extern char * glb_path_lvlprest_mem;
extern char * glb_path_lvlprest_def;
extern char * glb_path_obj_mem;
extern char * glb_path_obj_def;
extern char * glb_path_objects_mem;
extern char * glb_path_objects_def;

#endif
#ifndef _TXTREAD_H_

#define _TXTREAD_H_
                        
char  * txt_gets               (char * bptr, int * nb_char, int * is_new_line, int del_char);
void  txt_count_header_cols    (char * cur_col, int * col_count);
char  * txt_read_header        (char * cur_col, TXT_S * txt);
int   txt_check_type_and_size  (char * cur_col, TXT_S * txt);
int   txt_fill_data            (char * cur_col, TXT_S * txt);
TXT_S * txt_destroy            (TXT_S * txt);
void  txt_get_user_filter_cols (char * cur_col, TXT_S * txt);
TXT_S * txt_load               (char * mem, RQ_ENUM enum_txt, char * filename);
void  * txt_read_in_mem        (char * txtname);
void  txt_convert_slash        (char * str);
void  txt_debug                (char * file_path_mem, char * file_path_def, TXT_S * txt);
int   read_lvltypes_txt        (int ds1_idx, int type);
int   read_lvlprest_txt        (int ds1_idx, int def);
int   read_obj_txt             (void);
int   read_objects_txt         (void);

#endif
#ifndef _WINDS1EDIT_TYPES_H_

#define _WINDS1EDIT_TYPES_H_

typedef unsigned char      UBYTE;
typedef short int          WORD;
typedef unsigned short int UWORD;
typedef unsigned long      UDWORD;

// Disable warning message : warning C4996: 'sprintf': This function or variable may be unsafe. Consider using sprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
#pragma warning(disable : 4996)

#endif
#ifndef _UNDO_H_

#define _UNDO_H_

void undo_reset_flags              (int ds1_idx);
void undo_exit                     (void);
void undo_new_tile_buffer          (int ds1_idx);
void undo_start_seg_in_tile_buffer (int ds1_idx, UBYTE x, UBYTE y);
void undo_close_seg_in_tile_buffer (int ds1_idx);
void undo_add_to_tile_buffer       (int ds1_idx, int ix, int iy);
void undo_close_tile_buffer        (int ds1_idx);
void undo_apply_tile_buffer        (int ds1_idx);
void undo_add_this_tile_to_buffer  (int ds1_idx, int ix, int iy, CELL_F_S * f, CELL_W_S * w, CELL_S_S * s);

#endif
#ifndef _WBITS_H_

#define _WBITS_H_

void wbits_main_single_tile    (int ds1_idx, int tx, int ty);
void wbits_apply_modification  (int ds1_idx, WBITSDATA_S * ptr_wbitsdata);
void wbits_main_multiple_tiles (int ds1_idx, WBITSDATA_S * ptr_wbitsdata);
void wbits_main                (int ds1_idx, int tx, int ty);

#endif
#ifndef _WEDIT_H_

#define _WEDIT_H_

void wedit_draw_s             (int ds1_idx, int x, int y);
void wedit_draw_f             (int ds1_idx, int x, int y);
void wedit_draw_w             (int ds1_idx, int x, int y, int upper);
void wedit_draw_r             (int ds1_idx, int x, int y);
void wedit_draw_sp            (int ds1_idx, int x, int y);
void wedit_make_2nd_buttons   (void);
void wedit_read_pcx           (void);
void wedit_free               (void);
void wedit_draw_button        (BUT_TYP_E b_num);
void wedit_draw_tab           (BLK_TYP_E t_num);
int  wedit_tab_have           (int ds1_idx, BLK_TYP_E t);
void wedit_tiles_free         (void);
void wedit_tiles_make         (int ds1_idx);
int  wedit_search_tile        (int ds1_idx, int x, int y, BUT_TYP_E but);
void wedit_tab_tiles          (int ds1_idx, BLK_TYP_E t, int x0, int y0, int bt_sel, int m_idx, int s_idx);
void wedit_jump               (int ds1_idx, int bt_idx, int * xn, int * yn);
void wedit_mouse_tile         (int mx, int my, int x0, int y0, int t, int * m_idx, int * s_idx);
void wedit_update_tile        (int ds1_idx, int x, int y, BUT_TYP_E button, BLK_TYP_E type, int m_idx, int s_idx);
void wedit_save_tile          (int ds1_idx, int x, int y, CELL_F_S * dst_f_ptr, CELL_W_S * dst_w_ptr, CELL_S_S * dst_s_ptr);
void wedit_cancel_tile        (int ds1_idx, int x, int y, CELL_F_S * src_f_ptr, CELL_W_S * src_w_ptr, CELL_S_S * src_s_ptr);
void wedit_keep_tile          (int ds1_idx, int x, int y, CELL_F_S * src_f_ptr, CELL_W_S * src_w_ptr, CELL_S_S * src_s_ptr);
void wedit_test               (int ds1_idx, int tx, int ty);

#endif
#ifndef _WMSG_H_

#define _WMSG_H_

int wmsg_main(WMSG_S * wmsg);

#endif
#ifndef _WPREVIEW_H_

#define _WPREVIEW_H_

void wpreview_shape                     (BITMAP * tmp_bmp, int x0, int y0, int ds1_idx, COL_E col_idx);
void wpreview_gouraud_f                 (BITMAP * tmp_bmp, int x0, int y0, int ds1_idx, int c1, int c2, int c3, int c4);
void wpreview_gouraud_w                 (BITMAP * tmp_bmp, int x0, int y0, int ds1_idx, int c1, int c2, int c3, int c4);
int  wpreview_light_dist                (int x0, int y0, int mx, int my);
int  qsort_helper_order_data            (const void *e1, const void *e2);
void wpreview_draw_s                    (int ds1_idx, int x, int y, int mx, int my, int z, int selected);
void wpreview_draw_f                    (int ds1_idx, int x, int y, int mx, int my, int z, int selected);
void wpreview_draw_w                    (int ds1_idx, int x, int y, int mx, int my, int z, int selected, int upper);
void wpreview_draw_r                    (int ds1_idx, int x, int y, int mx, int my, int z, int selected);
void wpreview_draw_sp                   (int ds1_idx, int x, int y, int mx, int my, int z, int selected);
void coord_to_tile                      (int ds1_idx, int ax, int ay, int * layer_x, int * layer_y);
void mouse_to_tile                      (int ds1_idx, int * layer_x, int * layer_y);
void change_zoom                        (int ds1_idx, ZOOM_E z);
void wpreview_draw_paths                (int ds1_idx);
void wpreview_draw_paths_1obj           (int ds1_idx, int o);
void wpreview_obj_animate               (void);
void wpreview_draw_objects              (int ds1_idx);
void wpreview_draw_simple_wi            (int mx, int my, int z, UBYTE * walkinfo);
void wpreview_draw_wi                   (int mx, int my, int z, UBYTE * walkinfo);
void wpreview_draw_an_object            (int ds1_idx, int o);
void wpreview_draw_an_object_shad       (int ds1_idx, int o);
void wpreview_draw_obj_tile_shad        (int ds1_idx, int x, int y, int * cur_idx);
void wpreview_draw_obj_tile_0_2         (int ds1_idx, int x, int y, int * cur_idx);
void wpreview_draw_obj_tile_1           (int ds1_idx, int x, int y, int * cur_idx);
void wpreview_draw_tiles                (int ds1_idx);
void wpreview_reiinit_animated_floor    (int ds1_idx);
int  wpreview_draw_tiles_big_screenshot (int ds1_idx);

#endif
/* DCL decompression table */

#include "dclib.h"

const UInt8 dcl_table[] =
{	0x02, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05, 0x06,
	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x07, 0x07,
	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0x03, 0x0D, 0x05, 0x19, 0x09, 0x11, 0x01, 0x3E,
	0x1E, 0x2E, 0x0E, 0x36, 0x16, 0x26, 0x06, 0x3A,
	0x1A, 0x2A, 0x0A, 0x32, 0x12, 0x22, 0x42, 0x02,
	0x7C, 0x3C, 0x5C, 0x1C, 0x6C, 0x2C, 0x4C, 0x0C,
	0x74, 0x34, 0x54, 0x14, 0x64, 0x24, 0x44, 0x04,
	0x78, 0x38, 0x58, 0x18, 0x68, 0x28, 0x48, 0x08,
	0xF0, 0x70, 0xB0, 0x30, 0xD0, 0x50, 0x90, 0x10,
	0xE0, 0x60, 0xA0, 0x20, 0xC0, 0x40, 0x80, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
	0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00,
	0x04, 0x00, 0x05, 0x00, 0x06, 0x00, 0x07, 0x00,
	0x08, 0x00, 0x0A, 0x00, 0x0E, 0x00, 0x16, 0x00,
	0x26, 0x00, 0x46, 0x00, 0x86, 0x00, 0x06, 0x01,
	0x03, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05,
	0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x07, 0x07,
	0x05, 0x03, 0x01, 0x06, 0x0A, 0x02, 0x0C, 0x14,
	0x04, 0x18, 0x08, 0x30, 0x10, 0x20, 0x40, 0x00,
	0x0B, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
	0x0C, 0x08, 0x07, 0x0C, 0x0C, 0x07, 0x0C, 0x0C,
	0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
	0x0C, 0x0C, 0x0D, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
	0x04, 0x0A, 0x08, 0x0C, 0x0A, 0x0C, 0x0A, 0x08,
	0x07, 0x07, 0x08, 0x09, 0x07, 0x06, 0x07, 0x08,
	0x07, 0x06, 0x07, 0x07, 0x07, 0x07, 0x08, 0x07,
	0x07, 0x08, 0x08, 0x0C, 0x0B, 0x07, 0x09, 0x0B,
	0x0C, 0x06, 0x07, 0x06, 0x06, 0x05, 0x07, 0x08,
	0x08, 0x06, 0x0B, 0x09, 0x06, 0x07, 0x06, 0x06,
	0x07, 0x0B, 0x06, 0x06, 0x06, 0x07, 0x09, 0x08,
	0x09, 0x09, 0x0B, 0x08, 0x0B, 0x09, 0x0C, 0x08,
	0x0C, 0x05, 0x06, 0x06, 0x06, 0x05, 0x06, 0x06,
	0x06, 0x05, 0x0B, 0x07, 0x05, 0x06, 0x05, 0x05,
	0x06, 0x0A, 0x05, 0x05, 0x05, 0x05, 0x08, 0x07,
	0x08, 0x08, 0x0A, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C,
	0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D,
	0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D,
	0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D,
	0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D,
	0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D,
	0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D,
	0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
	0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
	0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
	0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
	0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
	0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
	0x0D, 0x0C, 0x0D, 0x0D, 0x0D, 0x0C, 0x0D, 0x0D,
	0x0D, 0x0C, 0x0D, 0x0D, 0x0D, 0x0D, 0x0C, 0x0D,
	0x0D, 0x0D, 0x0C, 0x0C, 0x0C, 0x0D, 0x0D, 0x0D,
	0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D,
	0x90, 0x04, 0xE0, 0x0F, 0xE0, 0x07, 0xE0, 0x0B,
	0xE0, 0x03, 0xE0, 0x0D, 0xE0, 0x05, 0xE0, 0x09,
	0xE0, 0x01, 0xB8, 0x00, 0x62, 0x00, 0xE0, 0x0E,
	0xE0, 0x06, 0x22, 0x00, 0xE0, 0x0A, 0xE0, 0x02,
	0xE0, 0x0C, 0xE0, 0x04, 0xE0, 0x08, 0xE0, 0x00,
	0x60, 0x0F, 0x60, 0x07, 0x60, 0x0B, 0x60, 0x03,
	0x60, 0x0D, 0x60, 0x05, 0x40, 0x12, 0x60, 0x09,
	0x60, 0x01, 0x60, 0x0E, 0x60, 0x06, 0x60, 0x0A,
	0x0F, 0x00, 0x50, 0x02, 0x38, 0x00, 0x60, 0x02,
	0x50, 0x00, 0x60, 0x0C, 0x90, 0x03, 0xD8, 0x00,
	0x42, 0x00, 0x02, 0x00, 0x58, 0x00, 0xB0, 0x01,
	0x7C, 0x00, 0x29, 0x00, 0x3C, 0x00, 0x98, 0x00,
	0x5C, 0x00, 0x09, 0x00, 0x1C, 0x00, 0x6C, 0x00,
	0x2C, 0x00, 0x4C, 0x00, 0x18, 0x00, 0x0C, 0x00,
	0x74, 0x00, 0xE8, 0x00, 0x68, 0x00, 0x60, 0x04,
	0x90, 0x00, 0x34, 0x00, 0xB0, 0x00, 0x10, 0x07,
	0x60, 0x08, 0x31, 0x00, 0x54, 0x00, 0x11, 0x00,
	0x21, 0x00, 0x17, 0x00, 0x14, 0x00, 0xA8, 0x00,
	0x28, 0x00, 0x01, 0x00, 0x10, 0x03, 0x30, 0x01,
	0x3E, 0x00, 0x64, 0x00, 0x1E, 0x00, 0x2E, 0x00,
	0x24, 0x00, 0x10, 0x05, 0x0E, 0x00, 0x36, 0x00,
	0x16, 0x00, 0x44, 0x00, 0x30, 0x00, 0xC8, 0x00,
	0xD0, 0x01, 0xD0, 0x00, 0x10, 0x01, 0x48, 0x00,
	0x10, 0x06, 0x50, 0x01, 0x60, 0x00, 0x88, 0x00,
	0xA0, 0x0F, 0x07, 0x00, 0x26, 0x00, 0x06, 0x00,
	0x3A, 0x00, 0x1B, 0x00, 0x1A, 0x00, 0x2A, 0x00,
	0x0A, 0x00, 0x0B, 0x00, 0x10, 0x02, 0x04, 0x00,
	0x13, 0x00, 0x32, 0x00, 0x03, 0x00, 0x1D, 0x00,
	0x12, 0x00, 0x90, 0x01, 0x0D, 0x00, 0x15, 0x00,
	0x05, 0x00, 0x19, 0x00, 0x08, 0x00, 0x78, 0x00,
	0xF0, 0x00, 0x70, 0x00, 0x90, 0x02, 0x10, 0x04,
	0x10, 0x00, 0xA0, 0x07, 0xA0, 0x0B, 0xA0, 0x03,
	0x40, 0x02, 0x40, 0x1C, 0x40, 0x0C, 0x40, 0x14,
	0x40, 0x04, 0x40, 0x18, 0x40, 0x08, 0x40, 0x10,
	0x40, 0x00, 0x80, 0x1F, 0x80, 0x0F, 0x80, 0x17,
	0x80, 0x07, 0x80, 0x1B, 0x80, 0x0B, 0x80, 0x13,
	0x80, 0x03, 0x80, 0x1D, 0x80, 0x0D, 0x80, 0x15,
	0x80, 0x05, 0x80, 0x19, 0x80, 0x09, 0x80, 0x11,
	0x80, 0x01, 0x80, 0x1E, 0x80, 0x0E, 0x80, 0x16,
	0x80, 0x06, 0x80, 0x1A, 0x80, 0x0A, 0x80, 0x12,
	0x80, 0x02, 0x80, 0x1C, 0x80, 0x0C, 0x80, 0x14,
	0x80, 0x04, 0x80, 0x18, 0x80, 0x08, 0x80, 0x10,
	0x80, 0x00, 0x00, 0x1F, 0x00, 0x0F, 0x00, 0x17,
	0x00, 0x07, 0x00, 0x1B, 0x00, 0x0B, 0x00, 0x13,
	0xA0, 0x0D, 0xA0, 0x05, 0xA0, 0x09, 0xA0, 0x01,
	0xA0, 0x0E, 0xA0, 0x06, 0xA0, 0x0A, 0xA0, 0x02,
	0xA0, 0x0C, 0xA0, 0x04, 0xA0, 0x08, 0xA0, 0x00,
	0x20, 0x0F, 0x20, 0x07, 0x20, 0x0B, 0x20, 0x03,
	0x20, 0x0D, 0x20, 0x05, 0x20, 0x09, 0x20, 0x01,
	0x20, 0x0E, 0x20, 0x06, 0x20, 0x0A, 0x20, 0x02,
	0x20, 0x0C, 0x20, 0x04, 0x20, 0x08, 0x20, 0x00,
	0xC0, 0x0F, 0xC0, 0x07, 0xC0, 0x0B, 0xC0, 0x03,
	0xC0, 0x0D, 0xC0, 0x05, 0xC0, 0x09, 0xC0, 0x01,
	0xC0, 0x0E, 0xC0, 0x06, 0xC0, 0x0A, 0xC0, 0x02,
	0xC0, 0x0C, 0xC0, 0x04, 0xC0, 0x08, 0xC0, 0x00,
	0x40, 0x0F, 0x40, 0x07, 0x40, 0x0B, 0x40, 0x03,
	0x00, 0x03, 0x40, 0x0D, 0x00, 0x1D, 0x00, 0x0D,
	0x00, 0x15, 0x40, 0x05, 0x00, 0x05, 0x00, 0x19,
	0x00, 0x09, 0x40, 0x09, 0x00, 0x11, 0x00, 0x01,
	0x00, 0x1E, 0x00, 0x0E, 0x40, 0x01, 0x00, 0x16,
	0x00, 0x06, 0x00, 0x1A, 0x40, 0x0E, 0x40, 0x06,
	0x40, 0x0A, 0x00, 0x0A, 0x00, 0x12, 0x00, 0x02,
	0x00, 0x1C, 0x00, 0x0C, 0x00, 0x14, 0x00, 0x04,
	0x00, 0x18, 0x00, 0x08, 0x00, 0x10, 0x00, 0x00
};
#ifdef WIN32
   #pragma warning (push)
   #pragma warning (disable  :  4244 4306 4311 4312 )
#endif

/* DCL Explode */

#include <stdio.h>
#include "dclib.h"

static UInt16 __explode_1 (UInt8 *buf);
static UInt16 __explode_2 (UInt8 *buf);
static UInt16 __explode_3 (UInt8 *buf, UInt16 result);
static UInt16 __explode_4 (UInt8 *buf, UInt32 flag);
static void   __explode_5 (UInt16 count, UInt8 *buf_1, const UInt8 *table, UInt8 *buf_2);
static void   __explode_6 (UInt8 *buf, const UInt8 *table);
       void   __explode_7 (UInt8 *buf, const UInt8 *table, UInt32 count);


//extern UInt8 * explode_buffer;

// ==========================================================================
UInt32 explode(read_data_proc read_data, write_data_proc write_data, void * param)
{	
   UInt32      result;
   UInt16      read_result;
   const UInt8 * table = dcl_table;
   UInt8       * work_buff;


//	UInt8 *work_buff=(UInt8 *)malloc(EXP_BUFFER_SIZE);
	work_buff = (UInt8 *) glb_mpq->explode_buffer;
	
	*((UInt32 *) (work_buff + 0x16)) = (UInt32) read_data;
	*((UInt32 *) (work_buff + 0x1A)) = (UInt32) write_data;
	*((void **) (work_buff + 0x12)) = param;
	*((UInt16 *) (work_buff + 0x0E)) = 0x0800;
	read_result = read_data(work_buff + 0x2222, 0x0800, param);
	if (read_result == DCL_ERROR_4)
	{
		result = DCL_ERROR_3;
	}
	else
	{
		UInt16	flag_0 = *(work_buff + 0x2222),
				flag_1 = *(work_buff + 0x2223),
				flag_2 = *(work_buff + 0x2224);
		
		*((UInt16 *) (work_buff + 0x02)) = flag_0;
		*((UInt16 *) (work_buff + 0x06)) = flag_1;
		*((UInt16 *) (work_buff + 0x0A)) = flag_2;
		*((UInt16 *) (work_buff + 0x0C)) = 0x00;
		*((UInt16 *) (work_buff + 0x0E)) = 0x03;
		*((UInt16 *) (work_buff + 0x10)) = read_result;
		if ((flag_1 < 0x04) || (flag_1 > 0x06))
		{
			result = DCL_ERROR_1;
		}
		else
		{
			 *((UInt16 *) (work_buff + 0x08)) = (UInt16) (0x0000FFFFL >> (0x0010 - flag_1));
			 if (flag_0 > 0x01)
			 {
			 	result = DCL_ERROR_2;
			 }
			 else
			 {
			 	if (flag_0)
			 	{
		 			__explode_7(work_buff + 0x2FA2, table + 0x00D0, 0x0100);
		 			__explode_6(work_buff, table + 0x01D0);
			 	}
			 	__explode_7(work_buff + 0x30E2, table + 0x00B0, 0x0010);
			 	__explode_5(0x0010, work_buff + 0x30E2, table + 0x00C0, work_buff + 0x2B22);
			 	__explode_7(work_buff + 0x30F2, table + 0x0080, 0x0010);
			 	__explode_7(work_buff + 0x3102, table + 0x0090, 0x0020);
			 	__explode_7(work_buff + 0x30A2, table, 0x0040);
			 	__explode_5(0x0040, work_buff + 0x30A2, table + 0x0040, work_buff + 0x2A22);
			 	if (__explode_1(work_buff) != 0x0306)
			 	{
			 		result = DCL_NO_ERROR;
			 	}
			 	else
			 	{
			 		result = DCL_ERROR_4;
			 	}
			 }
		}
	}
//	free(work_buff);
	return result;
}


// ==========================================================================
UInt16 __explode_1(UInt8 *buf)
{
	UInt32			result, temp;
	UInt8			*s, *d;
	write_data_proc	*write_data;
	void			*param;
	
	*((UInt16 *) (buf + 0x04)) = 0x1000;
	while (result = __explode_2(buf), (UInt16) result < 0x0305)
	{
		if ((UInt16) result < 0x0100)
		{
			temp = *((UInt16 *) (buf + 0x04));
			*((UInt16 *) (buf + 0x04)) = (UInt16) (temp + 0x01);
			*(buf + temp + 0x1E) =(UInt8) result;
		}
		else
		{
			result -= 0x00FE;
			s = (UInt8 *) __explode_3(buf, (UInt16)result);
			if (!s)
			{
				result = 0x0306;
				break;
			}
			else
			{
				temp = *((UInt16 *) (buf + 0x04));
				d = temp + 0x1E + buf;
				*((UInt16 *) (buf + 0x04)) =(UInt16) (temp + result);
				s = (UInt8 *)((UInt32)d - (UInt32)s);
				do
				{
					result--;
					*(d++) = *(s++);
				} while (result); 
			}			
		}
		if (*((UInt16 *) (buf + 4)) >= 0x2000)
		{
			result = 0x1000;
			write_data = (write_data_proc *) *((UInt32 *) (buf + 0x1A));
			param = (void *) *((UInt32 *) (buf + 0x12));
			write_data(buf + 0x101E, 0x1000, param);
			__explode_7(buf + 0x001E, buf + 0x101E, *((UInt16 *) (buf + 0x04)) - 0x1000);
			*((UInt16 *) (buf + 0x04)) -= 0x1000;
		}
	}
	write_data = (write_data_proc *) *((UInt32 *) (buf + 0x1A));
	param = (void *) *((UInt32 *) (buf + 0x12));
	write_data(buf + 0x101E, (UInt16)(*((UInt16 *) (buf + 0x04)) - 0x1000), param);	
	return (UInt16) result;
}


// ==========================================================================
UInt16 __explode_2(UInt8 *buf)
{
	UInt32	result, flag, flag_1;

	if (*((UInt16 *) (buf + 0x0A)) & 0x01)
	{
		if (__explode_4(buf, 0x01)) return 0x0306;
		result = *(buf + ((UInt8) *((UInt16 *) (buf + 0x0A))) + 0x2B22);
		if (__explode_4(buf, *(buf + ((UInt16) result) + 0x30E2))) return 0x0306;
		flag = *(buf + ((UInt16) result) + 0x30F2);
		if (flag)
		{
			flag_1 = (*((UInt16 *) (buf + 0x0A))) & ((0x01 << flag) - 0x01);
			if (__explode_4(buf, flag))
			{
				if ((((UInt16) result) + ((UInt16) flag_1)) != 0x010E) return 0x0306;
			}
			result = *((UInt16 *) (buf + (((UInt16) result) << 0x01) + 0x3102)) + flag_1;
		}
		result += 0x0100;
	}
	else
	{
		if (__explode_4(buf, 0x01)) return 0x0306;
		if (!*((UInt16 *) (buf + 0x02)))
		{
			result = (UInt8) *((UInt16 *) (buf + 0x0A));
			if (__explode_4(buf, 0x08)) return 0x0306;
		}
		else
		{
			flag = *((UInt16 *) (buf + 0x0A));
			if ((UInt8) flag)
			{
				result = *(buf + ((UInt8) flag) + 0x2C22);
				if (((UInt16) result) == 0x00FF)
				{
					if (flag & 0x003F)
					{
						if (__explode_4(buf, 0x04)) return 0x0306;
						result = *(buf + ((UInt8) *((UInt16 *) (buf + 0x0A))) + 0x2D22);
					}
					else
					{
						if (__explode_4(buf, 0x06)) return 0x0306;
						result = *(buf + ((*((UInt16 *) (buf + 0x0A))) & 0x007F) + 0x2E22);
					}
				}
			}
			else
			{
				if (__explode_4(buf, 0x08)) return 0x0306;
				result = *(buf + ((UInt8) *((UInt16 *) (buf + 0x0A))) + 0x2EA2);
			}
			flag = *(buf + ((UInt16) result) + 0x2FA2);
			if (__explode_4(buf, flag)) return 0x0306;
		}
	}
	return (UInt16)result;
}


// ==========================================================================
UInt16 __explode_3(UInt8 *buf, UInt16 flag)
{
	UInt32	result, flag_1;
	
	result = *(buf + ((UInt8) *((UInt16 *) (buf + 0x0A))) + 0x2A22);
	if (__explode_4(buf, *(buf + ((UInt16) result) + 0x30A2))) return 0x00;
	if (((UInt16) flag) == 0x02)
	{
		result <<= 0x02;
		result |= *((UInt16 *) (buf + 0x0A)) & 0x03;
		if (__explode_4(buf, 0x02)) return 0x00;
	}
	else
	{
		flag_1 = *((UInt16 *) (buf + 0x06));
		result <<= flag_1;
		result |= *((UInt16 *) (buf + 0x08)) & *((UInt16 *) (buf + 0x0A));
		if (__explode_4(buf, flag_1)) return 0x00;
	}
	return (UInt16) (result + 0x01);
}


// ==========================================================================
UInt16 __explode_4(UInt8 *buf, UInt32 flag)
{
	UInt32			result;
	UInt16			read_result;
	read_data_proc	*read_data = (read_data_proc *) *((UInt32 *) (buf + 0x16));
	void			*param = (void *) *((UInt32 *) (buf + 0x12));
	
	result = *((UInt16 *) (buf + 0x0C));
	if ((UInt16) flag <= result)
	{
		*((UInt16 *) (buf + 0x0A)) >>= flag;
		*((UInt16 *) (buf + 0x0C)) -= (UInt16)flag;
		result = 0x00;
	}
	else
	{
		*((UInt16 *) (buf + 0x0A)) >>= result;
		result = *((UInt16 *) (buf + 0x0E));
		if (result == *((UInt16 *) (buf + 0x10)))
		{
			*((UInt16 *) (buf + 0x0E)) = 0x0800;
			read_result = read_data(buf + 0x2222, 0x0800, param);
			*((UInt16 *) (buf + 0x10)) = read_result;
			if (!read_result) return 0x01;
			*((UInt16 *) (buf + 0x0E)) = 0x00;
		}
		result = *((UInt16 *) (buf + 0x0E)) + 0x2222;
		*((UInt16 *) (buf + 0x0A)) |= *(buf + result) << 0x08;
		*((UInt16 *) (buf + 0x0E)) += 0x01;
		*((UInt16 *) (buf + 0x0A)) >>= flag - *((UInt16 *) (buf + 0x0C));
		*((UInt16 *) (buf + 0x0C)) = (UInt16)(0x08 - (flag - *((UInt16 *) (buf + 0x0C))));
		result = 0x00;
	}
	return (UInt16) result;
}


// ==========================================================================
void __explode_5(UInt16 count, UInt8 *buf_1, const UInt8 *table, UInt8 *buf_2)
{
	SInt16	i = (SInt16)(count - 1);
	UInt32	idx_1, idx_2;
	
	for (; i >= 0; i--)
	{
		idx_1 = *(table + i);
		idx_2 = 0x01 << *(buf_1 + i);
		for (;;)
		{
			*(buf_2 + (UInt16) idx_1) = (UInt8) i;
			idx_1 += idx_2;
			if ((UInt16) idx_1 >= 0x0100) break;
		}
	} 
}


// ==========================================================================
void __explode_6(UInt8 *buf, const UInt8 *table)
{
	SInt16	i;
	UInt32	idx_1, idx_2;
	
	for (i = 0x00FF; i >= 0; i--)
	{		
		idx_1 = *(buf + i + 0x2FA2);
		if (idx_1 <= 0x08 )
		{
			idx_2 = *((UInt16 *) (table + (i << 0x01)));
			idx_1 = 0x01 << idx_1;
			do
			{
				*(buf + idx_2 + 0x2C22) =(UInt8) i;
				idx_2 += idx_1;
			} while ((UInt16) idx_2 < 0x0100);
		}
		else
		{
			idx_2 = *((UInt16 *) (table + (i << 0x01)));
			if ((UInt8) idx_2)
			{
				
				*(buf + (UInt8) idx_2 + 0x2C22) = 0xFF;
				if (*((UInt16 *) (table + (i << 0x01))) & 0x003F)
				{
					*(buf + i + 0x2FA2) -= 0x04;
					idx_1 = 0x01 << *(buf + i + 0x2FA2);
					idx_2 = *((UInt16 *) (table + (i << 0x01))) >> 0x04;
					do
					{
						*(buf + idx_2 + 0x2D22) =(UInt8) i;
						idx_2 += idx_1;
					} while ((UInt16) idx_2 < 0x0100);
				}
				else
				{
					*(buf + i + 0x2FA2) -= 0x06;
					idx_1 = 0x01 << *(buf + i + 0x2FA2);
					idx_2 = *((UInt16 *) (table + (i << 0x01))) >> 0x06;
					do
					{
						*(buf + idx_2 + 0x2E22) = (UInt8)i;
						idx_2 += idx_1;
					} while ((UInt16) idx_2 < 0x0080);
				}
			}
			else
			{
				*(buf + i + 0x2FA2) -= 0x08;
				idx_1 = 0x01 << *(buf + i + 0x2FA2);
				idx_2 = *((UInt16 *) (table + (i << 0x01))) >> 0x08;
				do
				{
					*(buf + idx_2 + 0x2EA2) = (UInt8)i;
					idx_2 += idx_1;
				} while ((UInt16) idx_2 < 0x0100);
			}
		}
	}
}


// ==========================================================================
void __explode_7(UInt8 *buf, const UInt8 *table, UInt32 count)
{
	UInt32	half_count = count >> 0x02;
	UInt8	*buf_end;
	
	if (half_count)
	{
		buf_end = buf + (half_count << 0x02);
		do
		{
			*((UInt32 *) buf) = *((UInt32 *) table);
			buf += 4;
			table += 4;
		} while (buf < buf_end);
	}
	switch (count - (half_count << 0x02))
	{
		case 3:
			*(buf++) = *(table++);
			
		case 2:
			*(buf++) = *(table++);
			
		case 1:
			*buf = *table;
			
		default:
			break;
	}
}

#ifdef WIN32
   #pragma warning (pop)
#endif
#ifdef WIN32
#pragma warning (push)
#pragma warning (disable  :  4057 )
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "mpqtypes.h"
#include "dclib.h"

#include "../structs.h"
#include "../error.h"


extern UInt32 ExtWavUnp1 (UInt32,UInt32,UInt32,UInt32); // Call for metod: 0x01
extern UInt32 ExtWavUnp2 (UInt32,UInt32,UInt32,UInt32); // Call for metod: 0x40
extern UInt32 ExtWavUnp3 (UInt32,UInt32,UInt32,UInt32); // Call for metod: 0x80

//  declaration of functions
int    test_prepare_archive (void);
DWORD  test_tell_entry      (char * filename);

void   BuildBaseMassive     (void);
int    InitializeLocals     (void);
void   FreeLocals           (void);
DWORD  Crc                  (char * string, DWORD * massive_base, DWORD massive_base_offset);
void   Decode               (DWORD * data_in, DWORD * massive_base, DWORD crc, DWORD lenght);
UInt16 read_data            (UInt8 * buffer, UInt16 size, void  * crap);
void   write_data           (UInt8 * buffer, UInt16 size, void  * crap);
int    ExtractTo            (FILE * fp_new, DWORD entry);
int    ExtractToMem         (void * mp_new, DWORD entry);

// a struct typedef
typedef struct params
{
    char * buf_in;
    char * buf_out;
} params;

GLB_MPQ_S * glb_mpq = NULL; // pointer to current mpq file structure


// ==========================================================================
// read from mod directory, NOT from a mpq
int mod_load_in_mem( char *moddir, char *filename, void **buffer, long *buf_len, int output )
{
    FILE       *in          =   NULL;
    long        size        =   0;
    char        strtmp[256];
    int         length;

    // ≥ı ºªØ
    *buffer     =   (void*)NULL;
    *buf_len    =   0;

    DEBUG_MESSAGE("mod_load_in_mem(\"%s\",\"%s\"):in\n", moddir, filename);
    // open file
    sprintf(strtmp, "%s/%s", moddir, filename);
    length = strlen( strtmp );
    length--;
    while( length >= 0 ){
        strtmp[length] = tolower( strtmp[length] );
        if( strtmp[length] == '\\' ){
            strtmp[length] = '/';
        }
        length--;
    }

    // strtmp == "\\Data\\Obj.txt"
    in = fopen(strtmp, "rb");
    if (in == NULL){
        return -1; // not read
    }

    // get size, for malloc()
    fseek(in, 0, SEEK_END);
    size = ftell(in) + 1;
    fseek(in, 0, SEEK_SET);
    *buffer = (void *) malloc(size);
    if (*buffer == NULL) {
        fclose(in);
        FATAL_EXIT("not enough mem (%li bytes) for %s (from Mod Directory)", size, filename);
    }
    size--;
    *buf_len = size;

    // copy the file in mem
    fread(* buffer, size, 1, in);
    * ( ((char *) (* buffer)) + size) = 0;

    //end
    if( output ){
        DEBUG_MESSAGE("ok (%li bytes)\n", size);
    }
    fclose(in);
    DEBUG_MESSAGE("mod_load_in_mem(\"%s\",\"%s\"):out\n", moddir, filename);
    return 0; // not equal to -1 means it's ok
}


// ==========================================================================
void mpq_batch_open(char * mpqname)
{
    char strtmp[256];

    // in case
    if(glb_mpq == NULL){
        FATAL_EXIT("pointer glb_mpq == NULL\n");
    }
    if(glb_mpq->is_open != FALSE){
        FATAL_EXIT("glb_mpq->is_open != FALSE\n");
    }
    if(mpqname == NULL){
        FATAL_EXIT("mpqname == NULL\n");
    }

    // ok, let's go
    glb_mpq->avail_metods[0] = 0x08;
    glb_mpq->avail_metods[1] = 0x01;
    glb_mpq->avail_metods[2] = 0x40;
    glb_mpq->avail_metods[3] = 0x80;

    // open mpq
    strcpy(glb_mpq->file_name, mpqname);
    glb_mpq->fpMpq = fopen(glb_mpq->file_name, "rb");
    if( ! glb_mpq->fpMpq){
        FATAL_EXIT("could not open %s\n", glb_mpq->file_name);
    }

    // prepare mpq to be read
    if (test_prepare_archive()){
        exit(DS1ERR_INITMPQ);
    }

    // flag this mpq to have some memory to free at exit
    glb_mpq->is_open = TRUE;
}


// ==========================================================================
int mpq_batch_load_in_mem(char * filename, void ** buffer, long * buf_len, int output)
{
    int  num_entry, size_unpack;
    void * mp_new;
    char strtmp[256];

    // in case
    if (glb_mpq == NULL) {
        FATAL_EXIT("mpq_batch_load_in_mem_mpq() : pointer glb_mpq == NULL");
    }
    if (glb_mpq->is_open == FALSE) {
        FATAL_EXIT("mpq_batch_load_in_mem_mpq() : glb_mpq->is_open == FALSE");
    }
    if (filename == NULL) {
        FATAL_EXIT("mpq_batch_load_in_mem_mpq() : filename == NULL");
    }
    if (strlen(filename) == 0) {
        FATAL_EXIT("mpq_batch_load_in_mem_mpq() : strlen(filename) == 0");
    }

    // let's go
    num_entry = test_tell_entry(filename);
    if (num_entry != -1) {
        //hash±Ì÷∏ æ≥ˆµƒ «∏√Œƒº˛‘⁄block±Ì÷–µƒŒª÷√?
        //table√ø∏ˆœÓµƒµ⁄»˝∏ˆ «size
        size_unpack = * (glb_mpq->block_table + (num_entry * 4) + 2);
        if(num_entry < 0 || num_entry > (int) glb_mpq->count_files - 1) {
            //≤Œ ˝ºÏ≤È∂¯“—
            FATAL_EXIT("Error! Invalid entry number %i (Valid entry numbers are 1-%i)\n", num_entry + 1, glb_mpq->count_files);
        }else{
            // load the file into memory
            mp_new = (void *) malloc(size_unpack);
            if (mp_new == NULL) {
                FATAL_EXIT("mpq_batch_load_in_mem() : not enough memory for %i bytes\n", size_unpack);
            }

            //≤È±Ì, »ª∫Û÷±Ω”‘⁄’‚¿ÔΩ‚—πÀı
            //Ω‚—πÀıµΩmp_new÷–, ≤¢Õ®π˝buff∑µªÿ
            //size_unpack «Œ¥—πÀı ±µƒ ˝æ›≥§∂»
            ExtractToMem(mp_new, num_entry);
            * buffer = mp_new;
            * buf_len = size_unpack;
            if (output)
                printf("ok (%i bytes)", size_unpack);
        }
    }
    return num_entry;
}


// ==========================================================================
void mpq_batch_close()
{
    fclose(glb_mpq->fpMpq);
    FreeLocals();
}


// ==========================================================================
// open and prepare the archive
int test_prepare_archive(void)
{
    DWORD   mpq_header[2] = {0x1a51504d, 0x00000020};
    DWORD   detected = 0;
    DWORD   tmp;
    char  name_htable[] = "(hash table)";
    char  name_btable[] = "(block table)";

    // search in the mpq the bytes 4D 50 51 1A 20 00 00 00
    //     = search the string : "MPQ" + 0x1A + " " + 0x00 + 0x00 + 0x00
    while(fread(&tmp,sizeof(DWORD),1,glb_mpq->fpMpq)) {
        if(mpq_header[0]==tmp) {
            fread(&tmp,sizeof(DWORD),1,glb_mpq->fpMpq);
            if(mpq_header[1]==tmp) {
                detected=1;
                break;
            }
        }
    }
    if(!detected) {
        printf("\nError: File \'%s\' is not a valid MPQ archive", glb_mpq->file_name);
        fclose(glb_mpq->fpMpq);
        return -1;
    }

    // found the start of mpq infos in the archive
    // it might be the start of archive
    glb_mpq->offset_mpq = ftell(glb_mpq->fpMpq) - 8;

    // read 4 bytes : Lenght of MPQ file data
    fread(&glb_mpq->lenght_mpq_part,sizeof(DWORD),1,glb_mpq->fpMpq);

    // SKIP 4 bytes
    fseek(glb_mpq->fpMpq,glb_mpq->offset_mpq + 16,SEEK_SET);

    // read 4 bytes : Offset to hash_table of MPQ
    fread(&glb_mpq->offset_htbl,sizeof(DWORD),1,glb_mpq->fpMpq);

    // read 4 bytes : Offset to block_table of MPQ
    fread(&glb_mpq->offset_btbl,sizeof(DWORD),1,glb_mpq->fpMpq);

    // read 4 bytes : Lenght of hash table
    fread(&glb_mpq->lenght_htbl,sizeof(DWORD),1,glb_mpq->fpMpq);
    glb_mpq->lenght_htbl *= 4;

    // read 4 bytes : Lenght of block table
    fread(&glb_mpq->lenght_btbl,sizeof(DWORD),1,glb_mpq->fpMpq);

    // Number of files in MPQ (calculated from size of block_table)
    glb_mpq->count_files = glb_mpq->lenght_btbl;
    glb_mpq->lenght_btbl *= 4; // in fact, length of block table is in # of file

    // prepare Crc
    // æÕ «“ª∏ˆº”√‹Ω‚√‹±Ì∂¯“—...ø…“‘ ÷π§º∆À„“ªœ¬
    //Œ““—æ≠À„π˝¡À,‘⁄’‚∏ˆ≥Ã–Ú¿Ô√Ê
    BuildBaseMassive();
    // ’‚∏ˆ∫Ø ˝÷–æÕ «∑÷≈‰“ª–©ƒ⁄¥Ê∂¯“—~
    // √ª”–◊ˆ∆‰À˚µƒ ¬«È
    if(InitializeLocals()) {
        fclose(glb_mpq->fpMpq);
        return -2;
    }

    // read hash table
    fseek(glb_mpq->fpMpq,glb_mpq->offset_mpq+glb_mpq->offset_htbl,SEEK_SET);
    fread(glb_mpq->hash_table,sizeof(DWORD),glb_mpq->lenght_htbl,glb_mpq->fpMpq);

    // read block table
    fseek(glb_mpq->fpMpq,glb_mpq->offset_mpq+glb_mpq->offset_btbl,SEEK_SET);
    fread(glb_mpq->block_table,sizeof(DWORD),glb_mpq->lenght_btbl,glb_mpq->fpMpq);



    //char  name_htable[] = "(hash table)";
    //char  name_btable[] = "(block table)";
    //  ÷±Ω”∂‘’‚¡Ω∏ˆ◊÷∑˚¥ÆΩ¯––º∆À„???????????????????????????
    // calculate crc of "(hash table)", then decode its datas
    // calculate crc of "(block table)", then decode its datas
    // hash±Ìµƒƒ⁄»›“≤±ªº”√‹¡À, –Ë“™ π”√Ω‚√‹À„∑®(µ»≥§º”√‹∫Õµ»≥§Ω‚√‹)
    tmp=Crc(name_htable,glb_mpq->massive_base,0x300);
    Decode(glb_mpq->hash_table,glb_mpq->massive_base,tmp,glb_mpq->lenght_htbl);
    tmp=Crc(name_btable,glb_mpq->massive_base,0x300);
    Decode(glb_mpq->block_table,glb_mpq->massive_base,tmp,glb_mpq->lenght_btbl);

    // end
    return 0;
}

// ==========================================================================
// search which entry in the archive is the file
// ‰»ÎæÕ“ª∏ˆ◊÷∑˚¥Æ
//≤Èhash table, entryº«¬º‘⁄table÷–
DWORD test_tell_entry(char * filename)
{
    DWORD scrc1, scrc2, scrc3, pointer_ht;

    scrc1 = Crc(filename, glb_mpq->massive_base, 0);
    scrc2 = Crc(filename, glb_mpq->massive_base, 0x100);
    scrc3 = Crc(filename, glb_mpq->massive_base, 0x200);
    //‘ÀÀ„Ω·π˚‘⁄’‚¿Ô
    //»Áπ˚≥ÂÕª¡ÀæÕÕ˘∫Û√Ê“∆∂Ø“ª∏ˆŒª÷√
    pointer_ht = (scrc1 & (glb_mpq->lenght_htbl/4-1) ) * 4;
    //DWORD  lenght_htbl;        // Lenght of hash table
    for(; pointer_ht<glb_mpq->lenght_htbl; pointer_ht += 4)
    {
        //≤‚ ‘,∫Û“∆∂Ø
        if( (* (glb_mpq->hash_table+pointer_ht)   == scrc2) && (* (glb_mpq->hash_table+pointer_ht+1) == scrc3)){
            //* (glb_mpq->hash_table + pointer_ht + 2) « ≤√¥∂´Œ˜?
            //’‚¿Ô+0∫Õ+1 «–ß—È¬Î,+3 «entry,2 «…∂?
            //“ª÷±’“≤ªµΩ2 « ≤√¥, √≤À∆“≤√ª”–”√µΩ
            return * (glb_mpq->hash_table + pointer_ht + 3);
        }
    }
    return (DWORD) -1;
}


/******************************************************************************
 *
 *   FUNCTION:   InitializeLocals() - Allocation of memory for hash_table,block_table,
 *                                    filename_table,identify_table and working buffers 
 *                                    to decompress files
 *                                     
 ******************************************************************************/
int InitializeLocals()
{
    //ø¥µΩ’‚¿Ô, √ª”–ºÃ–¯ø¥
    //MPQ≤ø∑÷√˜œ‘≤ª «◊˜’ﬂ–¥µƒ, ∑Á∏ÒÕÍ»´≤ª“ª—˘
    //¥”¡Ì“ª∏ˆ≤‡√Ê“≤Àµ√˜º¥ π≤ª”√ø¥MPQµƒ µœ÷œ∏Ω⁄
    //“≤ø…“‘∞…’‚∏ˆ≥Ã–Ú◊ˆ≥ˆ¿¥
    glb_mpq->global_buffer = (UInt8 *) malloc(0x60000); // Allocation 384 KB for global_buffer
    if(!glb_mpq->global_buffer) {
        printf("\nError! Insufficient memory");
        return -1;
    }
    glb_mpq->read_buffer_start=glb_mpq->global_buffer;                  // 4 KB for read_buffer
    glb_mpq->write_buffer_start=glb_mpq->global_buffer+0x1000;          // 4 KB for write_buffer
    glb_mpq->explode_buffer=glb_mpq->global_buffer+0x2000;              // 16 KB for explode_buffer
    glb_mpq->file_header=(DWORD *)(glb_mpq->global_buffer+0x6000);      // 360 KB for file_header (max size of unpacked file can't exceed 360 MB)


    glb_mpq->hash_table=(DWORD *)malloc(glb_mpq->lenght_htbl*4);
    glb_mpq->block_table=(DWORD *)malloc(glb_mpq->lenght_btbl*4);
    glb_mpq->filename_table=(char *)calloc(glb_mpq->lenght_btbl/4,MPQTYPES_MAX_PATH);
    //glb_mpq->identify_table  «∏ˆ…Ò¬Ì∂´Œ˜???????????
    glb_mpq->identify_table=(char *)calloc(glb_mpq->lenght_btbl/4,sizeof (char));
    if(glb_mpq->hash_table && glb_mpq->block_table && glb_mpq->filename_table && glb_mpq->identify_table)
        return 0;
    else {
        printf("\nError! Insufficient memory");
        return -1;
    }
}

/******************************************************************************
 *
 *   FUNCTION:   FreeLocals() - free memory
 *                                     
 ******************************************************************************/
void FreeLocals()
{   
    if(glb_mpq->global_buffer)
        free(glb_mpq->global_buffer);
    if(glb_mpq->hash_table)
        free(glb_mpq->hash_table);
    if(glb_mpq->block_table)
        free(glb_mpq->block_table);
    if(glb_mpq->filename_table)
        free(glb_mpq->filename_table);
    if(glb_mpq->identify_table)
        free(glb_mpq->identify_table);
    return;
}

/******************************************************************************
 *
 *   FUNCTION:   BuildBaseMassive() - fill massive_base
 *
 ******************************************************************************/
void BuildBaseMassive()
{

    //’‚∏ˆ∂´Œ˜ «πÃ∂®µƒ, ÕÍ»´ø…“‘◊‘º∫º∆À„≥ˆ¿¥
    //Œ“∞—’‚∏ˆ±Ìº∆À„¡À“ªœ¬
    //¥Û∏≈ «»Áœ¬’‚∞„, ±»Ωœ≥§(1280∏ˆDWORD):

    // 1439053538    46006640  1481339348   696578062  3062024201  2446296939  2002426916  1501387941  1511718578  3555315213   852348408  2978087373  1020134862  2774340542  3138059889  2474027827  2223989854  2279889477  1169711127  1583705256  
    //  461707925   625138647  2874014180  1500950171  1815182973  3453824916  1010570213   861606769   832934602  1373961292  4158348079  2327690817  2347411060   550941465  3731659421  3316417765  1146773483  2492828848   511522887  4082969008  
    // 3395079898  3073558709  4258021853   249359382  2634153646   291885966  2665583560  3207835964  1639714300  4013849577  4174697669  3348854420  1512397123   188600842  2635773347  3483941463  1584230505  3414800177  1036046683   223182462  
    // 2548268843  4277939121  4183496373   665148307  1173497641  1285056048  2087086178  1604585543  2750505477  2031843172   946550486  1852588015  3344455131  1253866951  1244827547  3471969295  1622707975  4156246927  2198557074  2499219948  
    //  539297618   966599075  3854599181  3882680229  1649388329  1576088550  2212542904  3313069051  1249555152  3126437921    61349452  3443187675   850553740  2385888563  2657288425  2365139653  2282559723   320492467   785570916  2989643713  
    // 2690928833   462605198  1928164110   430343664  2189649027  1121537674  4003190518  1433209706  3127203994  3726953700  1395826540  3344236171  1346186695   268598180  3551922827  1759939971   177285289  1499439967   184792510   352994756  
    // 2976029902  3858188667  2322634916  3089317481  2392914296  1532467568  3937485592  1260958307  3061214447   108537975   358378960  3339793212  4162440927    15408488  3607100014  1134451042  3613775579  3406548713  1832670791  2522113779  
    //  212435913  1961673166  4228211638  1118867438  3316877395  4266667243  2068000687  3272205840   741971928  1131890260   364748076  3983163917  3355398668  3098116049  1582129356  3111357713  3659629055  1940661655   982445197  2894456697  
    // 4093212118  3120462737   253058334   677426909  2203678667  2959111222  2628484971  2327384454  3240841705   537415307  1153076909  2772611376  2193413572  3430186830   253299160  3659804188  1870469792  3529663622  2295363614  2875808973  
    // 4199977285  3036591452  3192383638  3876223624  3579938210  2901723249   153625394   501148328  1493990107  4104746599  3218626309   245857484  2851623780  2199476329  2348483610  3682873180  3606115093  2809491111   173126713  2850945187  
    // 3641200175  2188642296  3568075396   158571789  3015404796  3577333629  1807522496   902185386  2471270064  3514495767   700889839  2994064812  3609617118  2673616196  3249114997  3649998746  1203592326  1892028582  3041406676   599377548  
    // 1008447078  1767206527  3640849888  1698503003  3731177979   129812140  3337516936  2148873428   740242880  3655229773  3184307333  3033833690   606950555  2643871638  3117332866  1509595561  3633867969  2660286881    29087791  3622946301  
    // 3716447930  2285711453   636563794  1251109197  2012341761  2149902055    44430653  2621371609  2940222668  3802989504  1190000364  1872483302  3424955770  1202694930  2183761399  1888263916  1996014001  3012843986  1058940633  3783334887  
    // 1458379853  3385953016  3894937102  2445990446  1556871607  4054143700  1016939331  3774908293   719318719  4177674400  1023986919  1114533808  1463588943   329794478  1080783929  1667270105  1342225050  2907326379  2936020365  1100548014  
    //  408719254  3857313101  1635139891  3547348375  2895704262  3687031676  2247102660  2420710962  4046330047  3364656865  3556497113  3821177608  3586066636  2984740953   625401295  2955981312  2868717585  1437740321  3549164903  1184660011  
    // 1523603346  2711984158  2113635204   886163978  2125519840  3592216822   964716727  3862981919  2511235911  3827831344  2961453153  2802465384  3812685349  1927069693  2394468301   414606879   401562204      809762  1805727798  1634067331  
    // 1950882907  3849258769  2725204004  1609707104   832956457  2701741040  3330337900  2364745687  3958453386  1780645167  1946571140  2381730066   733808110  3838840534   696315418  1793186419  3896906970  1821968043  3482190555  3547479703  
    // 2465623215  2894369223  2932233878  3112802255  4195796834  1836303967   542974630  1305717413   770403264  2671208556  1906649131   929806816  2147428891  3731331119  2629776334   778939191  1848911033   249643964  2200592601  3143838177  
    //  334937853  1499855748  4127925052  1030312323  1127359649  3050949349  2185599915  2669785873  2943111751  3024597306  2066118339  3280566733  2233904677  3310398811  1750112679  1709818557  3855014966  3775608745  2281793656  3464615140  
    //  618069120  1090917677  1833918352  3302782142  3678955372  1823828407  4089403791    69929177    46969566  2969923429  1201228532  4195621796  2474027822   128411447  1978132220  1151172769    62334365  4141823370  1517671865  1193830691  
    //  991572207  4005444970  2645666304     8032473   610693233    27030479  1761844173  2509244228  1696117227  1761997314  3996733874  3779198121  2038409266  1519773019  3592829717  1533146004  2306525980     6259625   574754673  4103411566  
    // 2115211069   328393604   926676906  2387683350  2841686986    74766156  4289517271   787869086  1620650666  2120814233   599815325  3638726917  1432181001   358816766  2795264540  1343231946  2571337800   947075783  3867337416  3563413462  
    // 2507033604   880670275   793450363  2481797796  2810060245  2061850370  3534041049  4018905484  3084108270  2155395725  2874845915  1965809807   109785537   126529084  2858058563   306025064   753593923  2394796601  1694650867    76035656  
    // 2355290414   313729383  3843108506   268445000  1048215949   125719335  4047555617  1827133277  2610559397   840266780  3064650670  1938254044  2191750191  1985048608  3716623064  2634613426  2098883332  1228412306  1671844517   202761766  
    // 3794759894    31998853  2996691252   549781518  3915510851   758212142  1021754408   888790420  4198882899  1232439485  2489852251   125303388  1869681856  3773310612  3828816262  1460743650  3771384457  4070821600  1782702521  3217991549  
    // 4180147538  1769242008  3198643419  2379453783    81485518   705201608  1004857582   567772636   165575694   844687923  1368533378  4002271268  1039570525   817963899  4160120938  2678890886  2084569206  2242703242  4105622048  3720562716  
    // 1134472900  1903935075  2186934951  3598892392  2469037584   952044159  1645404871  2297311592  3015864391  1630784286   355030278  1525047878   488672733  2837265850  3272971917  1789027915  1902972106  2300528982  2156293119  3176581191  
    // 2425569882   685612679  2230271496  1762281942  1786707842  2882528256  1027335626   941319436  1266452002  1040336627  2740328020  2491975260   988748786  1583179938  3543080412  1368861680   393879867  1184069058   929303504  4231210184  
    //  118037001   761517051   559149091  1210202229  1638225958  2350081336  1240931736  2227688734  2236947059   332793029  3607209510  2277000394  1948168861   707565436  3348613635  1816167895   766310299  1934598891  3425240407  4196300260  
    //  112368167  3201182330  1889817931  3375731758  2808396737   535007702  2013786306  1080061657  3843371142  3911024082  3982310313  2853484106  2209500633  3961517517  3123964627  3840897884  3154519096  3636450595  1195187716   537393319  
    // 2955477997  2263517914  2511038927  4246706185  2629032123  1374968152  2631746166  3259336286  2399961963  1323817991  4130770333  4012645825  3998659915  3177369135  4103170733  3357324692  1098030921   616493220  3740567465   573441464  
    // 2369516998   297095177  2903102131   433823697  3611455621   870055051  1382781816  2030967752  2996406784  2774800131   108450377  1804699084   820262031  2193960805  1472715812  1218191053  2680860714  1456869655  4270234796  1442599232  
    // 2143007618  2656763001   268729497  4238301572  1448640045  3112276976  2566807182   699489131  2506223701  3138169381   508480533   603273531   138785880  3472844746  2962853900    11621967   971961297  4240555908  2894631861  1686421262  
    // 2445290163  2349599856  1752148166  3782328022  3752736735  3584140519  3823847841  1583355104   542843308  4250448858   779880397  4012689498  3612900166  4095181949  2318454465  1889029996  4038472584  3256928653  3991284022  2462099379  
    //  519270888   537261999  2443473509  2966377732  3573590952  3411823571  2604387267  3479585973  3465840879     4180334  2856460847  1212478416  1303944567   141040302  1714371112  1981108955   502767994  2482957722  3427363407  2719469517  
    // 1000589616   646938231   127382689  2347498577   109654212   382235874  3259161124  4213350262  2692307714  1755299894   396834610  3524979712  2885723794  1528921880  2923566628   734026944  1220664186  1330537396   375910478   872550292  
    // 2536187221  2584163675    23484784  2109082735   987172923  1547504064  4003715802  2294422544   270808791  1782264832  3948035148  4221032598  2521610347  3716644920    86628941   185886885   410229448  4159858280  4132390001  1544877507  
    // 1151369723   967605815  2316812907  2257542759   959551373  1860139031  1230097511  2486437875  3428742287   729737001  3417514224   301910247  4241475160    54870868   926589420   492371610   105320622  2827657402  3515064894  1087459491  
    // 4113676497  2816057221   293833941  2979947699  1030202857  2955696838  2579085800  1277176698   368206291  2823564557  1358005670   867844565   964235283  1269822542  4008618524  3762848532  1436339499  2701456453  1668233156   642604603  
    // 1975615285  1967276337  3138475833  1962833242  2100984486   764143492  2213352778  4230378456  1155353215  2030398664  2194442289  2637962108  3913628666   607213204  1713320531  1968480092  3140183021  1742736790  4102645447   226224726  
    // 3261043439  2840045469  3729448815  2886665026  3555402859  2762609038  1010723398  1165968449  2768912495  1817218463  3920369895   516797626   967605818  2142438650  1866004712  1257040493  1627610739  2171635975  3955257861  2432529940  
    // 3039633791  1817043349   500469892  1693337644  2496111905  1410075096  1977585109  1094791671   915996022  4152679247  4173953539    76495289  1005908157  2360674706  2606291438  3853220300  2589941842  3180695984  4208075563  1516446292  
    //   42395160  2329135351  3825598838  1967932951  1544571147  1870491647   562541610  1467287899    49596003  1516096006  4266316999  1407295357  1509902005  3166972837  4247734935  3201751301  2506267499   564248795  2853221469  3874450776  
    //  680709965  2683137040   507014135  2615199464   724506095   435530875  2063535730   836392815   807742644  1467572396   376348250  2838973025  1899404438  2146969262  3893842726  3401317683    26286350  1771912254   917768994  3012887827  
    // 2609421306  2771013639  2888372205   994986575  3075725526  1012080418  1479500839  2848822185  1416509870   607103698  3537958727   167129693  1507100441  2910762606  3578865784  1457438621  1359472037  4055894692  2169293992  1611501808  
    // 2615768601  2438964722   727066845  2738708314  1499330497  1768300893  1357677367  4057076594   249753339  2912841911  2869768164  3475471197  1649957420  2203744324  1957821035  1236991957   782878820   311628200  3187284071  2211076503  
    // 2635970329  2226878950  2654968306   826237185   463021147  3512569778  3472428929   692397709  3686593907  2969704582  2665999389   486024439  2125082162  1774232245  1955873180  3797145555  1222262034  1169732977  3679261818  3626864094  
    //  643633314  2963729306  2115802022   922627910  3702352640    88314257  2966312068  1641136905  2376477187   114359855  3133594940  3391096563  2200023471    68265715  3901853356   564314450  2445333839  1789531386  3710035008  2295013493  
    // 2051979283  1739563121  3638135964   837881159  1878108328   799731873  1218585019  1004967051  2860115867   245835660  2050512879  1236794965  3575429425    68944269    12125441  1172994177  2411846607  3087741609  2880230121  1736170560  
    // 3970753858  1835341035   834707447  1584143037   473505039   245200881  1897478445  1810477242  1637153399  1172709704  1109609202  3273891174  2476522940  1444941212  1797739016     1729011  3435308358  1265773536  3995464375  1837551518  
    // 2859196621  1305323446  2027203091   921336537  1059706624  3739889028  1785394621   414169116  3638880060  2326202554  1703646425  2792769420  3483438114   626605172  2375426613  1603797616  1039592384  2390594298  3287176673  3589743687  
    //   45152917  1387312416  1892860191   980409708   423274136  1419179989  1107858203  2051081964  2213046336  4103827340  3124599377  1442139613   769987442  2600163099   984830982  2909077279  3346490622  2139505766  1097702612  2722665080  
    // 3809183460   189936054  3127357142  3853198439  1610779536   496902342   712796458  1802050779  2656172055  2608217580  1026110015  3487640424  1967867291  2720235591  3653588244  1809645505  1765696320  2184724455   420932191  3967536473  
    // 1927157338  3885635095  2395497012  2834354820   550044198  2079950980   681935665  1053031022  1289783643  3277042896   871302735   568713744  3367721117  3898460850  2892333727  2814350032    94771021   631573550  3855058807  1031078431  
    // 1269472408   599640196  2522069975  3135039477  3263407236  3225476910  2473633857   791765026   921621041  2888612876   331392155  3453036951   134123954  3447630797   738273053   407055864  1503423431  1978219866  3061477090  2389937686  
    // 4287656957  2943812202  4168000252  2437979811   866618822  1333338954   980759996   892992689   822341202  1332682345  1806953404  1287091541  2379344281   719209373   290594734  3108840773  2380176061   420034879  3079840317  1956398427  
    // 3048607532   939809230   229464096  2972746843   689749330  3734657975  1373567329  1364943880  3396239934   942567028  4005444977  1284443242  3866549482   350346364  1870644788  3481643331  3550390638   326007955  1902424836  4079948595  
    //  901988404  3728332577  2443736121  3289387295   703691436   320251647   317822190  1108055193  4146966748  1762369427   399592370  2408782520   561316028  2270434296  2561860669  3307181425  1422835146   119131257  4089907213  3827853169  
    // 2750067661  1248526560   298780505  2122937209  1530038124  1586287862   216922724  2442838727  2987717555   243909516  4039391801  3940615458  2203831814  2666283970  3928402390  1767053345  1730523722  3665932514  3585388083   135240187  
    //  363347375   702531360  2447478799   672546136  2211514274  1319900314  2675038744  1641399546  3819645535  3350255167  3016521002  1642844086   654292266  3984105023  2856044888  1163560840  3384836777   169602830  3264895614   353191733  
    // 2486700512  1763792144  4010479017   995008435  3635793996  3349160872  2966749832  1686246261  3261130959  2224471340  4283388981   263542284  2094484050  2472057984  2291620935  2210244765  2345419414    28847137  4253162943   642911047  
    //   77086233  3554789927  2016172047   846198131  3243752647  1331587972  1156316155  3659979224  1826214030   387576280  1901855879   741162130  1408936873  3162726726  1359778518  3767138346  1182799647   916390110  1894523697   237321557  
    // 3673921303  3856503341  2509331745  2686463894  2707541063  3939477233  3982397833  3669522052  2763484490  4201662615  1662980282  3550324985  1572126948   385737770   771716480  3044011134  3288314736  2389653180  1620563033  1364024630  
    // 2779199458   964147635  4247888074  2419288283  3895922017  2551223584  2917285036  2583178756  1105100451  2225193621   152640480   814943490   480224330  3288774359  4007436626  1632207004  2953420532  3321254821  1276147981  1929586796  

    DWORD   s1;
    int i,j;
    ldiv_t divres;

    divres.rem=0x100001;
    for(i=0;i<0x100;i++) {
        for(j=0;j<5;j++) {
            divres=ldiv(divres.rem*125+3,0x002AAAAB);
            s1=(divres.rem&0xFFFFL)<<0x10;
            divres=ldiv(divres.rem*125+3,0x002AAAAB);
            s1=s1|(divres.rem&0xFFFFL);
            glb_mpq->massive_base[i+0x100*j]=s1;
        }
    }
    return;
}

/******************************************************************************
 *
 *   FUNCTION:   Crc(char *,DWORD *,DWORD) - calculate crc
 *   Àµ∞◊¡ÀæÕ «ƒ«∏ˆÀ„hash÷µ
 *
 ******************************************************************************/
DWORD Crc(char *string,DWORD *massive_base,DWORD massive_base_offset)
{
    char   byte;
    DWORD  crc=0x7fed7fed;
    DWORD  s1=0xEEEEEEEE;

    byte=*string;
    while(byte) {
        if(byte>0x60 && byte<0x7B)
            byte-=0x20;
        //massive_base∆‰ µæÕ «∏ˆº”√‹”√µƒ≤È’“±Ì
        crc=*(massive_base+massive_base_offset+byte)^(crc+s1);
        s1+=crc+(s1<<5)+byte+3;
        string++;
        byte=*string;
    }
    return crc;
}

/******************************************************************************
 *
 *   FUNCTION:   read_data(UInt8 *,UInt16,void *) (called by explode)
 *
 ******************************************************************************/
UInt16 read_data(UInt8 *buffer,UInt16 size,void *crap)
{
    params *param=(params *)crap;
    memcpy(buffer,param->buf_in,size);
    param->buf_in+=size;
    return size;
}
/******************************************************************************
 *
 *   FUNCTION:   write_data(UInt8 *,UInt16,void *) (called by explode)
 *
 ******************************************************************************/
void write_data(UInt8 *buffer,UInt16 size,void *crap)
{
    params *param=(params *)crap;
    memcpy(param->buf_out,buffer,size);
    param->buf_out+=size;
    glb_mpq->lenght_write+=size;
}


/******************************************************************************
 *
 *   FUNCTION:   Decode(DWORD *,DWORD *,DWORD,DWORD) - decode data
 *
 ******************************************************************************/
void Decode(DWORD *data_in, DWORD *massive_base, DWORD crc, DWORD lenght)
{
    //¥´»Î: 
    //      data_in      = hash±Ì ◊µÿ÷∑
    //      massive_base = º”√‹±Ì
    //      crc          = "(hash table)"’‚∏ˆ◊÷∑˚¥Æµƒhash÷µ
    //      length       = hash±Ìµƒ≥§∂»
    DWORD  i,dec;
    DWORD  s1=0xEEEEEEEE;
    //≥§∂»≤ª±‰µƒdecode
    for(i=0;i<lenght;i++) {
        s1+=*(massive_base+0x400+(crc&0xFFL));
        dec=*(data_in+i)^(s1+crc);
        s1+=dec+(s1<<5)+3;
        *(data_in+i)=dec;
        crc=(crc>>0x0b)|(0x11111111+((crc^0x7FFL)<<0x15));
    }
    return;
}

/******************************************************************************
 *
 *   FUNCTION:   GetUnknowCrc(DWORD) - calculate crc for file without name
 *
 ******************************************************************************/
DWORD GetUnknowCrc(DWORD entry)
{   
    DWORD   tmp,i,j,coded_dword,crc_file=0;
    DWORD   flag,size_pack,size_unpack,num_block,offset_body;
    DWORD   sign_riff1=0x46464952; // 'RIFF'
    DWORD   sign_riff3=0x45564157; // 'WAVE'
    DWORD   sign_mpq1=0x1a51504d; // 'MPQ'
    DWORD   sign_mpq2=0x00000020;
    ldiv_t  divres;

    offset_body=*(glb_mpq->block_table+entry*4);                                // get offset of analized file
    flag=*(glb_mpq->block_table+entry*4+3);                                 // get flag of analized file
    fseek(glb_mpq->fpMpq,glb_mpq->offset_mpq+offset_body,SEEK_SET);
    fread(&coded_dword,sizeof(DWORD),1,glb_mpq->fpMpq);                     // read first coded dword from file

    if(flag&0x200 || flag&0x100) {                              // IF FILE PACKED:
        size_unpack=*(glb_mpq->block_table+entry*4+2);                      // . get size of unpacked file
        size_pack=*(glb_mpq->block_table+entry*4+1);                            // . get size of packed file
        divres=ldiv(size_unpack-1,0x1000);
        num_block=divres.quot+2;                                    // . calculate lenght of file header
        for(j=0;j<=0xff;j++) {                                      // . now we're gonna find crc_file of 0x100 possible variants
            crc_file=((num_block*4)^coded_dword)-0xeeeeeeee - *(glb_mpq->massive_base+0x400+j);// . calculate possible crc
            if((crc_file&0xffL) == j) {                             // . IF FIRST CHECK is succesfull - do second one
                fseek(glb_mpq->fpMpq,glb_mpq->offset_mpq+offset_body,SEEK_SET);
                fread(glb_mpq->file_header,sizeof(DWORD),num_block,glb_mpq->fpMpq); // . read file header 
                Decode(glb_mpq->file_header,glb_mpq->massive_base,crc_file,num_block);// . decode file header with possible crc
                tmp=num_block*4;                                    // . tmp = size header (bytes)
                if(tmp == *glb_mpq->file_header) {                          // . IF SECOND CHECK is succesfull - do third one
                    for(i=0;i<num_block-1;i++) {
                        tmp+=*(glb_mpq->file_header+i+1)-*(glb_mpq->file_header+i);
                        if(*(glb_mpq->file_header+i+1)-*(glb_mpq->file_header+i)>0x1000) {
                            tmp=0xffffffff;
                            break;
                        }
                    }
                    if(tmp!=0xffffffff) {                           // . IF THIRD CHECK is succesfull
                        crc_file++;                                 // . great! we got right crc_file
                        break;
                    }
                }
            }
            crc_file=0;                                             // . if its impossible to get right crc return 0
        }

    } else {                                                    // IF FILE IS NOT PACKED:
        for(j=0;j<=0xff;j++) {                                      // Calculate crc as if it was WAV FILE
            crc_file=(sign_riff1^coded_dword)-0xeeeeeeee - *(glb_mpq->massive_base+0x400+j);// . calculate possible crc
            if((crc_file&0xff)==j) {                                // . IF FIRST CHECK is succesfull - do second one
                fseek(glb_mpq->fpMpq,glb_mpq->offset_mpq+offset_body,SEEK_SET);
                fread(glb_mpq->file_header,sizeof(DWORD),3,glb_mpq->fpMpq);         // . read file file_header 
                Decode(glb_mpq->file_header,glb_mpq->massive_base,crc_file,3);      // . decode file file_header with possible crc
                if(sign_riff1==*glb_mpq->file_header) {
                    if(sign_riff3==*(glb_mpq->file_header+2))               // . IF SECOND CHECK is succesfull - we got right crc
                        break;
                }
            }
            crc_file=0;                                             // . if its impossible to get right crc return 0
        }
        if(!crc_file) {                                             // Calculate crc as if it was MPQ FILE
            for(j=0;j<=0xff;j++) {
                crc_file=(sign_mpq1^coded_dword)-0xeeeeeeee - *(glb_mpq->massive_base+0x400+j);
                if((crc_file&0xffL) == j) {
                    fseek(glb_mpq->fpMpq,glb_mpq->offset_mpq+offset_body,SEEK_SET);
                    fread(glb_mpq->file_header,sizeof(DWORD),2,glb_mpq->fpMpq);
                    Decode(glb_mpq->file_header,glb_mpq->massive_base,crc_file,2);
                    if(sign_mpq1 == *glb_mpq->file_header) {
                        if(sign_mpq2 == *(glb_mpq->file_header+1))
                            break;
                    }
                }
                crc_file=0;
            }
        }
    }
    return crc_file;
}

/******************************************************************************
 *
 *   FUNCTION:   ExtractTo(FILE,DWORD) - extract file from archive
 *
 ******************************************************************************/
int ExtractTo(FILE *fp_new,DWORD entry)
{
    DWORD   size_pack,size_unpack;
    UInt8   *read_buffer,*write_buffer;
    UInt32  i,j,offset_body,flag,crc_file=0;
    UInt32  num_block,lenght_read,iteration;
    UInt8   *szNameFile;
    UInt8   metod;
    ldiv_t  divres;
    params  param;

    offset_body=*(glb_mpq->block_table+entry*4);                            // get offset of file in mpq
    size_unpack=*(glb_mpq->block_table+entry*4+2);                      // get unpacked size of file
    flag=*(glb_mpq->block_table+entry*4+3);                             // get flags for file

    //
    //
    //
    if(flag&0x30000) {                                      // If file is coded, calculate its crc
        if(*(glb_mpq->identify_table+entry)&0x1) {                      // . Calculate crc_file for identified file:
            szNameFile=glb_mpq->filename_table+MPQTYPES_MAX_PATH*entry;         // . . get name of file
            if(strrchr(szNameFile,'\\'))
                szNameFile=strrchr(szNameFile,'\\')+1;
            crc_file=Crc(szNameFile,glb_mpq->massive_base,0x300);       // . . calculate crc_file (for Diablo I MPQs)
            if((flag&0x20200) == 0x20200)                                   // . . if flag indicates Starcraft MPQ
                crc_file=(crc_file+offset_body)^size_unpack;    // . . calculate crc_file (for Starcraft MPQs)
        }
        else
            crc_file=GetUnknowCrc(entry);                       // . calculate crc_file for not identified file:
    }

    if(flag&0x200 || flag&0x100) {                          // IF FILE IS PACKED:
        divres=ldiv(size_unpack-1,0x1000);
        num_block=divres.quot+2;                                // . calculate lenght of file header
        fseek(glb_mpq->fpMpq,glb_mpq->offset_mpq+offset_body,SEEK_SET);
        fread(glb_mpq->file_header,sizeof(DWORD),num_block,glb_mpq->fpMpq);     // . read file header 
        if(flag&0x30000)
            Decode(glb_mpq->file_header,glb_mpq->massive_base,(crc_file-1),num_block);// . decode file header (if file is coded)
        read_buffer=glb_mpq->read_buffer_start;
        for(j=0;j<(num_block-1);j++) {
            lenght_read=*(glb_mpq->file_header+j+1)-*(glb_mpq->file_header+j);  // . get lenght of block to read
            fread(read_buffer,sizeof(char),lenght_read,glb_mpq->fpMpq); // . read block
            if(flag&0x30000)
                Decode((DWORD *)read_buffer,glb_mpq->massive_base,crc_file,lenght_read/4);          // . decode block (if file is coded)
            if(lenght_read==0x1000 || (j==num_block-2 && lenght_read==(size_unpack&0xFFF))) // . if block is unpacked (its lenght=0x1000 or its last block and lenght=remainder)
                //
                fwrite(read_buffer,sizeof(char),lenght_read,fp_new);                    // . write block "as is"
            else {                                              // . block is packed
                if(flag&0x200) {                                // . If this file is from Starcraft MPQ (or Diablo 2), then
                    metod=*read_buffer;                         // . . first byte determinates metod of packing
                    iteration=0;
                    for(i=0;i<4;i++) {                          // . . calculate number of iterations
                        if(metod&glb_mpq->avail_metods[i])
                            iteration++;
                    }
                    read_buffer+=1;
                    lenght_read-=1;
                } else {                                        // . Else: file is from Diablo I MPQ, then
                    iteration=1;
                    metod=8;                                    // . .file is compressed with DCL
                }
                write_buffer=glb_mpq->write_buffer_start;
                if(metod&0x08) {
                    param.buf_in =read_buffer;
                    param.buf_out=write_buffer;
                    glb_mpq->lenght_write=0;
                    explode(&read_data,&write_data,&param);
                    lenght_read=glb_mpq->lenght_write;
                    iteration--;
                    if(iteration) {
                        read_buffer=write_buffer;
                        write_buffer=glb_mpq->read_buffer_start;
                    }
                }
                if(metod&0x01) {
                    lenght_read=ExtWavUnp1((UInt32)read_buffer,(UInt32)lenght_read,(UInt32)write_buffer,0x1000);
                    iteration--;
                    if(iteration) {
                        read_buffer=write_buffer;
                        write_buffer=glb_mpq->read_buffer_start;
                    }
                }
                if(metod&0x40)
                    lenght_read=ExtWavUnp2((UInt32)read_buffer,(UInt32)lenght_read,(UInt32)write_buffer,0x1000);
                if(metod&0x80)
                    lenght_read=ExtWavUnp3((UInt32)read_buffer,(UInt32)lenght_read,(UInt32)write_buffer,0x1000);
                //
                fwrite(write_buffer,1,lenght_read,fp_new);
                read_buffer=glb_mpq->read_buffer_start;
            }
            crc_file++;                                         // . calculate crc_file for next block
        }
    }

    else {                                                  // IF FILE IS NOT PACKED
        size_pack=*(glb_mpq->block_table+entry*4+1);                    // get size  of file
        if(flag&0x30000)
            lenght_read=0x1000;                             // if file is coded, lenght_read=0x1000 (4 KB)
        else
            lenght_read=0x60000;                            // if file is not coded, lenght_read=0x60000 (384KB)
        if(size_pack<lenght_read)
            lenght_read=size_pack;                          // if size of file < lenght_read, lenght read = size of file
        read_buffer=glb_mpq->read_buffer_start;
        if(lenght_read) {
            divres=ldiv(size_pack,lenght_read);                 // .
            num_block=divres.quot;                              // .
        } else {                                                // .
            num_block=0;                                        // .
            divres.rem=0;                                       // .
        }
        fseek(glb_mpq->fpMpq,glb_mpq->offset_mpq+offset_body,SEEK_SET);
        for (j=0;j<num_block;j++) {
            fread(read_buffer,1,lenght_read,glb_mpq->fpMpq);
            if(flag&0x30000) {
                Decode((DWORD *)read_buffer,glb_mpq->massive_base,crc_file,lenght_read/4);  // if file is coded, decode block
                crc_file++;                                     // and calculate crc_file for next block
            }
            //
            fwrite(read_buffer,1,lenght_read,fp_new);
        }
        if(divres.rem) {
            fread(read_buffer,1,divres.rem,glb_mpq->fpMpq);
            if(flag&0x30000)
                Decode((DWORD *)read_buffer,glb_mpq->massive_base,crc_file,divres.rem/4);
            //
            fwrite(read_buffer,1,divres.rem,fp_new);
        }
    }
    return 0;
}

/******************************************************************************
 *
 *   FUNCTION:   ExtractToMem(FILE,DWORD) - extract file from archive
 *
 *   ∞—entryø™ º¥¶µƒ ˝æ›Ω‚—πÀıµΩmp_new÷–, mp_newµƒ≥§∂» «∏√∂Œ ˝æ›…–Œ¥±ª—πÀı÷Æ«∞µƒ≥§∂»
 *   entry «—πÀı∫Û ˝æ›‘⁄mpqŒƒº˛÷–µƒ∆´“∆
 *
 *
 ******************************************************************************/
int ExtractToMem(void * mp_new, DWORD entry)
{
    //’‚∏ˆ∫Ø ˝’Êø÷≤¿...√ªø¥
    DWORD  size_pack,size_unpack;
    UInt8  * read_buffer,*write_buffer;
    UInt32 i,j,offset_body,flag,crc_file=0;
    UInt32 num_block,lenght_read,iteration;
    UInt8    * szNameFile;
    UInt8  metod;
    ldiv_t divres;
    params param;
    UBYTE  * buff_ptr = mp_new;

    offset_body=*(glb_mpq->block_table+entry*4);                        // get offset of file in mpq
    size_unpack=*(glb_mpq->block_table+entry*4+2);                      // get unpacked size of file
    flag=*(glb_mpq->block_table+entry*4+3);                             // get flags for file

    //size_pack=*(glb_mpq->block_table+entry*4+1);                  // get size  of file
    //’‚æ‰ª∞ «∫Û√Êµƒ, Àµ√˜¡À[0:offset][1:unpackedsize][2:packedsize][3:flag] ’‚4∏ˆ ˝æ›µƒ≈≈¡–∫Õƒ⁄»›

    if(flag&0x30000) {                                                  // If file is coded, calculate its crc
        if(*(glb_mpq->identify_table+entry)&0x1) {                      // . Calculate crc_file for identified file:
            szNameFile=glb_mpq->filename_table+MPQTYPES_MAX_PATH*entry;         // . . get name of file
            if(strrchr(szNameFile,'\\'))
                szNameFile=strrchr(szNameFile,'\\')+1;
            crc_file=Crc(szNameFile,glb_mpq->massive_base,0x300);       // . . calculate crc_file (for Diablo I MPQs)

            /* edit by Sloan Roy 17 Nov 2002 : must be
               if ((flag & 0x20200) == 0x20200)
               instead of
               if (flag & 0x20200) */

            if ((flag & 0x20200) == 0x20200)                                    // . . if flag indicates Starcraft MPQ

                crc_file=(crc_file+offset_body)^size_unpack;    // . . calculate crc_file (for Starcraft MPQs)
        }
        else
            crc_file=GetUnknowCrc(entry);                       // . calculate crc_file for not identified file:
    }

    if(flag&0x200 || flag&0x100) {                          // IF FILE IS PACKED:
        divres=ldiv(size_unpack-1,0x1000);
        num_block=divres.quot+2;                                // . calculate lenght of file header
        fseek(glb_mpq->fpMpq,glb_mpq->offset_mpq+offset_body,SEEK_SET);
        fread(glb_mpq->file_header,sizeof(DWORD),num_block,glb_mpq->fpMpq);     // . read file header 
        if(flag&0x30000){
            //Decode «∂®≥§º”√‹Ω‚√‹, À˘“‘ø…“‘÷±Ω”¥´»ÎΩ·ππÕ∑÷∏’Î
            Decode(glb_mpq->file_header,glb_mpq->massive_base,(crc_file-1),num_block);// . decode file header (if file is coded)
        }
        read_buffer=glb_mpq->read_buffer_start;
        for(j=0;j<(num_block-1);j++) {
            lenght_read=*(glb_mpq->file_header+j+1)-*(glb_mpq->file_header+j);  // . get lenght of block to read
            fread(read_buffer,sizeof(char),lenght_read,glb_mpq->fpMpq); // . read block
            if(flag&0x30000)
                Decode((DWORD *)read_buffer,glb_mpq->massive_base,crc_file,lenght_read/4);          // . decode block (if file is coded)
            if(lenght_read==0x1000 || (j==num_block-2 && lenght_read==(size_unpack&0xFFF))) // . if block is unpacked (its lenght=0x1000 or its last block and lenght=remainder)
            {
                //
                //                  fwrite(read_buffer,sizeof(char),lenght_read,fp_new);                    // . write block "as is"
                memcpy(buff_ptr, read_buffer, lenght_read);
                buff_ptr += lenght_read;
            }
            else {                                              // . block is packed
                if(flag&0x200) {                                // . If this file is from Starcraft MPQ (or Diablo 2), then
                    metod=*read_buffer;                         // . . first byte determinates metod of packing
                    iteration=0;
                    for(i=0;i<4;i++) {                          // . . calculate number of iterations
                        if(metod&glb_mpq->avail_metods[i])
                            iteration++;
                    }
                    read_buffer+=1;
                    lenght_read-=1;
                } else {                                        // . Else: file is from Diablo I MPQ, then
                    iteration=1;
                    metod=8;                                    // . .file is compressed with DCL
                }
                write_buffer=glb_mpq->write_buffer_start;
                if(metod&0x08) {
                    param.buf_in =read_buffer;
                    param.buf_out=write_buffer;
                    glb_mpq->lenght_write=0;
                    explode(&read_data,&write_data,&param);
                    lenght_read=glb_mpq->lenght_write;
                    iteration--;
                    if(iteration) {
                        read_buffer=write_buffer;
                        write_buffer=glb_mpq->read_buffer_start;
                    }
                }
                if(metod&0x01) {
                    lenght_read=ExtWavUnp1((UInt32)read_buffer,(UInt32)lenght_read,(UInt32)write_buffer,0x1000);
                    iteration--;
                    if(iteration) {
                        read_buffer=write_buffer;
                        write_buffer=glb_mpq->read_buffer_start;
                    }
                }
                if(metod&0x40)
                    lenght_read=ExtWavUnp2((UInt32)read_buffer,(UInt32)lenght_read,(UInt32)write_buffer,0x1000);
                if(metod&0x80)
                    lenght_read=ExtWavUnp3((UInt32)read_buffer,(UInt32)lenght_read,(UInt32)write_buffer,0x1000);
                //
                //              fwrite(write_buffer,1,lenght_read,fp_new);
                memcpy(buff_ptr, write_buffer, lenght_read);
                buff_ptr += lenght_read;

                read_buffer=glb_mpq->read_buffer_start;
            }
            crc_file++;                                         // . calculate crc_file for next block
        }
    }

    else {                                                  // IF FILE IS NOT PACKED
        size_pack=*(glb_mpq->block_table+entry*4+1);        // get size  of file
        if(flag&0x30000)
            lenght_read=0x1000;                             // if file is coded, lenght_read=0x1000 (4 KB)
        else
            lenght_read=0x60000;                            // if file is not coded, lenght_read=0x60000 (384KB)
        if(size_pack<lenght_read)
            lenght_read=size_pack;                          // if size of file < lenght_read, lenght read = size of file
        read_buffer=glb_mpq->read_buffer_start;
        if(lenght_read) {
            divres=ldiv(size_pack,lenght_read);                 // .
            num_block=divres.quot;                              // .
        } else {                                                // .
            num_block=0;                                        // .
            divres.rem=0;                                       // .
        }
        fseek(glb_mpq->fpMpq,glb_mpq->offset_mpq+offset_body,SEEK_SET);
        for (j=0;j<num_block;j++) {
            fread(read_buffer,1,lenght_read,glb_mpq->fpMpq);
            if(flag&0x30000) {
                Decode((DWORD *)read_buffer,glb_mpq->massive_base,crc_file,lenght_read/4);  // if file is coded, decode block
                crc_file++;                                     // and calculate crc_file for next block
            }
            //
            //          fwrite(read_buffer,1,lenght_read,fp_new);
            memcpy(buff_ptr, read_buffer, lenght_read);
            buff_ptr += lenght_read;
        }
        if(divres.rem) {
            fread(read_buffer,1,divres.rem,glb_mpq->fpMpq);
            if(flag&0x30000)
                Decode((DWORD *)read_buffer,glb_mpq->massive_base,crc_file,divres.rem/4);
            //
            //          fwrite(read_buffer,1,divres.rem,fp_new);
            memcpy(buff_ptr, read_buffer, divres.rem);
            buff_ptr += divres.rem;
        }
    }
    return 0;
}

#ifdef WIN32
#pragma warning (pop)
#endif
#ifdef WIN32
   #pragma warning (push)
   #pragma warning (disable  :  4100 4127 4311 4312 4127)
#endif

/* WAVE decompressor */

#include "mpqtypes.h"
#include "wav_unp.h"
#include <stdlib.h>

UInt32 ExtWavUnp1   (UInt32,UInt32,UInt32,UInt32);
UInt32 ExtWavUnp2   (UInt32,UInt32,UInt32,UInt32);
UInt32 ExtWavUnp3   (UInt32,UInt32,UInt32,UInt32);
void   Sub_WavUnp1  (UInt32,UInt32);
UInt32 Sub_WavUnp2  (UInt32,UInt32,UInt32);
void   Sub_WavUnp3  (UInt32);
void   Sub_WavUnp4  (UInt32,UInt32,UInt32,UInt32);
UInt32 Sub_WavUnp5  (UInt32);
void   Sub_WavUnp6  (UInt32);
UInt32 Sub_WavUnp7  (UInt32);
UInt32 Sub_WavUnp8  (UInt32);
void   Sub_WavUnp9  (UInt32,UInt32);
void   Sub_WavUnp10 (UInt32,UInt32);
UInt32 Sub_WavUnp11 (UInt32,UInt32,UInt32,UInt32);
void   Sub_WavUnp12 (UInt32);
UInt32 Sub_WavUnp13 (UInt32,UInt32,UInt32,UInt32,UInt32);


// ==========================================================================
UInt32 ExtWavUnp3(UInt32 buf_in,UInt32 size_in,UInt32 buf_out,UInt32 size_out)
{
	return Sub_WavUnp13(buf_in,size_in,2,buf_out,size_out);
}


// ==========================================================================
UInt32 ExtWavUnp2(UInt32 buf_in,UInt32 size_in,UInt32 buf_out,UInt32 size_out)
{
	return Sub_WavUnp13(buf_in,size_in,1,buf_out,size_out);
}


// ==========================================================================
UInt32 Sub_WavUnp13(UInt32 buf_in,UInt32 size_in,UInt32 flag,UInt32 buf_out,UInt32 size_out)
{
	UInt32	var14=0,var18=0,var1c=0;
	UInt32	tmp0=0,tmp1=0,tmp2=0,tmp3=0,tmp4=0;
   UInt32	var8[2]={0, 0};
	UInt32	var10[2]={0, 0};


	var14=buf_in;
	size_in+=buf_in;
	tmp0=var14+2;
	var1c=size_out;
	tmp3=buf_out;
	var18=buf_out;
	var10[0]=0x2C;
	var10[1]=0x2C;
	if((SInt32)flag>0) {
		for(tmp2=0;tmp2<flag;tmp2++) {
			var8[tmp2]=(SInt32)*((SInt16 *)tmp0);
			tmp0+=2;
			if(size_out<2)
				return tmp3-var18;
			*((UInt16 *)tmp3)=(UInt16) var8[tmp2];
			tmp3+=2;
			var1c-=2;
		}
	}
	tmp2=flag-1;
	while(tmp0<size_in) {	
		if(flag==2)	{
			if(tmp2==0)
				tmp2=1;
			else
				tmp2=0;
		}
		tmp1=(UInt32)*((UInt8 *)tmp0);
		tmp0++;
		buf_in=tmp0;
		if(tmp1&0x80) {
			tmp1&=0x7F;
			tmp4=1;
			if(tmp1==0)	{
				if(var10[tmp2])
					var10[tmp2]--;
				if(var1c<2)
					return tmp3-var18;
				*((UInt16 *)tmp3)=(UInt16)var8[tmp2];
				tmp3+=2;
				var1c-=2;
				if((tmp4==0)&&(flag==2)) {
					if(tmp2==0)
						tmp2=1;
					else
						tmp2=0;
				}
			} else {
				tmp1--;
				if(tmp1==0)	{
					var10[tmp2]+=8;
					tmp4=var10[tmp2];
					if(tmp4>0x58)
						var10[tmp2]=0x58;
					tmp4=0;
					if(tmp4==0 && flag==2) {
						if(tmp2==0)
							tmp2=1;
						else
							tmp2=0;
					}
				} else {
					tmp1--;
					if(tmp1==0)	{
						var10[tmp2]+=0xFFFFFFF8;
						if((SInt32)var10[tmp2]<0)
							var10[tmp2]=0;
						tmp4=0;
					}
					if((tmp4==0)&&(flag==2)) {
						if(tmp2==0)
							tmp2=1;
						else
							tmp2=0;
					}
				}
			}
		} else {
			tmp0=small_tbl1[var10[tmp2]];			
			tmp4=tmp0>>(*((UInt8 *)(var14+1)));
			if(tmp1&1)
				tmp4+=tmp0;
			if(tmp1&2)
				tmp4+=tmp0>>1;
			if(tmp1&4)
				tmp4+=tmp0>>2;
			if(tmp1&8)
				tmp4+=tmp0>>3;
			if(tmp1&0x10)
				tmp4+=tmp0>>4;
			if(tmp1&0x20)
				tmp4+=tmp0>>5;
			tmp0=var8[tmp2];
			if((tmp1&0xFF)&0x40) {
				tmp0-=tmp4;
				if((SInt32)tmp0<=(SInt32)0xFFFF8000)
					tmp0=0xFFFF8000;
			} else {
				tmp0+=tmp4;
				if((SInt32)tmp0>=0x7FFF)
					tmp0=0x7FFF;
			}
			var8[tmp2]=tmp0;
			tmp0=var1c;
			if(tmp0<2)
				return tmp3-var18;
			*((UInt16 *)tmp3)=(UInt16)var8[tmp2];
			tmp1&=0x1F;
			tmp3+=2;
			var1c-=2;
			tmp4=var10[tmp2]+small_tbl2[tmp1];
			var10[tmp2]=tmp4;
			if((SInt32)tmp4<0)
				var10[tmp2]=0;
			else {
				if(tmp4>0x58)
					var10[tmp2]=0x58;
			}
			tmp0=buf_in;
		}
	}
	return tmp3-var18;
}


// ==========================================================================
UInt32 ExtWavUnp1(UInt32 buf_in, UInt32 size_in, UInt32 buf_out, UInt32 size_out)
{
	UInt32	work_buff=0,base=0;
	UInt32	tmp1=0,tmp2=0,tmp3=0;
	SInt32	i=0;


	work_buff=(UInt32)(UInt8 *)malloc(0x3a80);
	*((UInt32 *)work_buff)=buf_in+4;
	*((UInt32 *)(work_buff+4))=*((UInt32 *)buf_in);
	*((UInt32 *)(work_buff+8))=0x20;
	base=work_buff+0xC;
	Sub_WavUnp12(base);
	size_out=Sub_WavUnp11(buf_out,size_out,work_buff,base);
	while(1) {
		tmp2=*((UInt32 *)(work_buff+0x3070));
		if((SInt32)tmp2<=0)
			break;
		tmp3=Sub_WavUnp5(tmp2);
		*((UInt32 *)tmp3)=*((UInt32 *)tmp2);
		tmp3=*((UInt32 *)tmp2);
		*((UInt32 *)(tmp3+4))=*((UInt32 *)(tmp2+4));
		*((UInt32 *)tmp2)=0;
		*((UInt32 *)(tmp2+4))=0;
	}
	if(*((UInt32 *)(work_buff+0x306C))) {
		tmp3=Sub_WavUnp5(*((UInt32 *)(work_buff+0x306C)));
		*((UInt32 *)tmp3)=*((UInt32 *)(work_buff+0x306C));
		tmp3=*((UInt32 *)(work_buff+0x306C));
		*((UInt32 *)(tmp3+4))=*((UInt32 *)(work_buff+0x3070));
		*((UInt32 *)(work_buff+0x306C))=0;
		*((UInt32 *)(work_buff+0x3070))=0;
	}
	while(1) {
		tmp2=*((UInt32 *)(work_buff+0x3064));
		if((SInt32)tmp2<=0)
			break;
		tmp3=Sub_WavUnp5(tmp2);
		*((UInt32 *)tmp3)=*((UInt32 *)tmp2);
		tmp3=*((UInt32 *)tmp2);
		*((UInt32 *)(tmp3+4))=*((UInt32 *)(tmp2+4));
		*((UInt32 *)tmp2)=0;
		*((UInt32 *)(tmp2+4))=0;
	}
	if(*((UInt32 *)(work_buff+0x3060))) {
		tmp3=Sub_WavUnp5(*((UInt32 *)(work_buff+0x3060)));
		*((UInt32 *)tmp3)=*((UInt32 *)(work_buff+0x3060));
		tmp3=*((UInt32 *)(work_buff+0x3060));
		*((UInt32 *)(tmp3+4))=*((UInt32 *)(work_buff+0x3064));
		*((UInt32 *)(work_buff+0x3060))=0;
		*((UInt32 *)(work_buff+0x3064))=0;
	}
	tmp2=work_buff+0x305C;
	for(i=0x203;i!=0;i--) {
		tmp3=*((UInt32 *)(tmp2-0x18));
		tmp2-=0x18;
		if(tmp3) {
			tmp3=Sub_WavUnp5(tmp2);
			*((UInt32 *)tmp3)=*((UInt32 *)tmp2);
			tmp3=*((UInt32 *)tmp2);
			*((UInt32 *)(tmp3+4))=*((UInt32 *)(tmp2+4));
			*((UInt32 *)tmp2)=0;
			*((UInt32 *)(tmp2+4))=0;
		}
		tmp1=*((UInt32 *)tmp2);
		if(tmp1) {
			tmp3=*((UInt32 *)(tmp2+4));
			if((SInt32)tmp3<0)
				tmp3=~tmp3;
			else
				tmp3=tmp2+tmp3-*((UInt32 *)(tmp1+4));
			*((UInt32 *)tmp3)=tmp1;
			tmp3=*((UInt32 *)tmp2);
			*((UInt32 *)(tmp3+4))=*((UInt32 *)(tmp2+4));
			*((UInt32 *)tmp2)=0;
			*((UInt32 *)(tmp2+4))=0;
		}
	}
	free((UInt8 *)work_buff);
	return size_out;
}


// ==========================================================================
void Sub_WavUnp12(UInt32 base)
{
	UInt32	tmp=0;
	SInt32	i=0;


	Sub_WavUnp6(base);
	tmp=base+0x3474;
	for(i=0x80;i!=0;i--) {
		*((UInt32 *) tmp)=0;
		tmp+=0xC;
	}
	return;
}


// ==========================================================================
UInt32 Sub_WavUnp11(UInt32 buf_out,UInt32 size_out,UInt32 work_buff,UInt32 base)
{
	UInt32	var4=0,var8=0,varc=0,var10=0,var14=0;
	UInt32	flag=0,tmp0=0,tmp1=0,tmp2=0,tmp3=0,tmp4=0,tmp5=0;


	if(size_out==0)
		return 0;
	tmp0=work_buff;
	if(*((UInt32 *)(tmp0+8))<=8) {
		tmp3=*((UInt32 *)tmp0);
		*((UInt32 *)(tmp0+4))|=((UInt32)*((UInt16 *)tmp3)&0xFFFF)<<(*((UInt32 *)(tmp0+8))&0xFF);		
		*((UInt32 *)(tmp0+8))+=0x10;
		*((UInt32 *)tmp0)+=2;				                    
	}
	*((UInt32 *)(tmp0+8))+=0xFFFFFFF8;
	varc=*((UInt32 *)(tmp0+4))&0xFF;
	*((UInt32 *)(tmp0+4))=*((UInt32 *)(tmp0+4))>>8;
	Sub_WavUnp1(varc,base);
	if((varc&0xFF)==0)
		*((UInt32 *)base)=1;
	else
		*((UInt32 *)base)=0;
	varc=buf_out;

	while(1) {
		if(*((UInt32 *)(tmp0+8))<=7) {
			tmp3=*((UInt32 *)tmp0);
			*((UInt32 *)(tmp0+4))|=((UInt32)*((UInt16 *)tmp3)&0xFFFF)<<(*((UInt32 *)(tmp0+8))&0xFF);		
			*((UInt32 *)(tmp0+8))+=0x10;
			*((UInt32 *)tmp0)+=2;
		}
		tmp3=*((UInt32 *)(tmp0+4));
		tmp4=tmp3&0x7F;					
		tmp2=base+(tmp4+0x45F)*12;
		tmp1=*((UInt32 *)tmp2);
		var8=0;
		flag=1;
		if(tmp1==*((UInt32 *)(base+4))) {
			var8=1;
			tmp5=*((UInt32 *)(tmp2+4));
			if(tmp5>7) {
				*((UInt32 *)(tmp0+4))=*((UInt32 *)(tmp0+4))>>7;
				*((UInt32 *)(tmp0+8))+=0xFFFFFFF9;
				var14=*((UInt32 *)(tmp2+8));
			} else {
				*((UInt32 *)(tmp0+4))=*((UInt32 *)(tmp0+4))>>(*((UInt32 *)(tmp2+4))&0xFF);
				*((UInt32 *)(tmp0+8))-=*((UInt32 *)(tmp2+4));
				tmp5=*((UInt32 *)(tmp2+8));
				flag=0;
			}
		} else {
			tmp5=*((UInt32 *)(base+0x3060));
			tmp3=*((UInt32 *)tmp5);
			var14=*((UInt32 *)(tmp3+4));
			tmp3=var14;
			if((SInt32)var14<=0)
				var14=0;
		}
		if(flag) {
			var10=0;
			do {
				var14=*((UInt32 *)(var14+0x14));
				if(Sub_WavUnp8(tmp0)) {
					tmp3=*((UInt32 *)(var14+4));
					var14=tmp3;
				} else
					tmp3=var14;
				var10++;
				if(var10==7)
					var4=tmp3;
			} while(*((UInt32 *)(tmp3+0x14)));
			if(var8==0) {
				if(var10>7)	{
					*((UInt32 *)tmp2)=*((UInt32 *)(base+4));
					*((UInt32 *)(tmp2+4))=var10;
					*((UInt32 *)(tmp2+8))=var4;
				} else {
					tmp3=(((var10|0xFFFFFFFF)>>((0x20-var10)&0xFF)))&tmp4;
					tmp1=1<<(var10&0xFF);
					tmp5=base+0x347C+tmp3*12;
					tmp2=(tmp1*3)<<2;
					do {
						tmp3+=tmp1;
						*((UInt32 *)(tmp5-8))=*((UInt32 *)(base+4));
						*((UInt32 *)(tmp5-4))=var10;
						*((UInt32 *)tmp5)=*((UInt32 *)(var14+8));
						tmp5+=tmp2;
					} while(tmp3<=0x7F);
				}
			}
			var10=*((UInt32 *)(var14+8));	
			tmp5=var10;
		}
		if(tmp5==0x101) {
			tmp5=*((UInt32 *)(tmp0+8));
			if(tmp5<=8)	{
				tmp3=*((UInt32 *)tmp0);
				*((UInt32 *)(tmp0+4))|=((UInt32)*((UInt16 *)tmp3)&0xFFFF)<<(*((UInt32 *)(tmp0+8))&0xFF);
				*((UInt32 *)(tmp0+8))+=0x10;
				*((UInt32 *)tmp0)+=2;
			}
			tmp2=*((UInt32 *)(tmp0+4))&0xFF;
			*((UInt32 *)(tmp0+4))=*((UInt32 *)(tmp0+4))>>8;
			*((UInt32 *)(tmp0+8))+=0xFFFFFFF8;			
			var10=tmp2;
			Sub_WavUnp9(tmp2,base);
			if(*((UInt32 *)base)==0) {
				tmp2=*((UInt32 *)(base+tmp2*4+0x306C));
				if(tmp2) {									
					while(tmp2) {
						tmp3=*((UInt32 *)(tmp2+0xC));
						tmp3++;
						*((UInt32 *)(tmp2+0xC))=tmp3;	
						tmp0=tmp2;
						tmp5=tmp3;
						while(1) {
							tmp4=*((UInt32 *)(tmp0+4));
							if((SInt32)tmp4<0)
								tmp4=0;
							if(tmp4) {
								if(*((UInt32 *)(tmp4+0xC))<tmp5)
									tmp0=tmp4;
								else
									break;
							} else
								break;
						}								
						if(tmp0!=tmp2) {
							Sub_WavUnp4(tmp0,2,tmp2,base+0x305C);
							Sub_WavUnp4(tmp2,2,tmp4,base+0x305C);
							tmp3=*((UInt32 *)(tmp0+0x10));
							tmp5=*((UInt32 *)(tmp3+0x14));
							tmp3=*((UInt32 *)(tmp2+0x10));
							if(*((UInt32 *)(tmp3+0x14))==tmp2)
								*((UInt32 *)(tmp3+0x14))=tmp0;
							if(tmp5==tmp0) {
								tmp5=*((UInt32 *)(tmp0+0x10));
								*((UInt32 *)(tmp5+0x14))=tmp2;
							}
							tmp3=*((UInt32 *)(tmp2+0x10));
							*((UInt32 *)(tmp2+0x10))=*((UInt32 *)(tmp0+0x10));
							*((UInt32 *)(tmp0+0x10))=tmp3;
							*((UInt32 *)(base+4))+=1;
						}
						tmp2=*((UInt32 *)(tmp2+0x10));
					}
					tmp5=var10;
					tmp0=work_buff;
				}
				else
					tmp5=var10;
			}
			else
				tmp5=var10;
		}
		tmp3=varc;
		if(tmp5!=0x100)						
		{
			size_out--;
			*((UInt8 *)varc)=(UInt8)tmp5&0xFF;
			tmp3++;
			varc=tmp3;
			if(size_out) {
				if(*((UInt32 *)base)) {
					tmp3=*((UInt32 *)(base+tmp5*4+0x306C));
					Sub_WavUnp10(tmp3,base);
				}
			} else
				return tmp3-buf_out;
		}
		else
			return tmp3-buf_out;
	}
}
	

// ==========================================================================
void Sub_WavUnp1(UInt32 arg1,UInt32 base)
{
	UInt32	var_4=0,var_8=0,var_c=0;
	UInt32	tmp0=0,tmp1=0,tmp2=0,tmp3=0,tmp4=0;
	SInt32	i=0;


	while((SInt32)*((UInt32 *)(base+0x3064))>0) {       
		tmp0=Sub_WavUnp2(0,*((UInt32 *)(base+0x3050)),*((UInt32 *)(base+0x3064)));
		if(*((UInt32 *) tmp0))
			Sub_WavUnp3(tmp0);
		tmp2=base+0x3054;
		*((UInt32 *)(tmp0))=tmp2;
		*((UInt32 *)(tmp0+4))=*((UInt32 *)(tmp2+4));
		tmp3=*((UInt32 *)(tmp2+4));
		if((SInt32)tmp3<=0)
			tmp3=~tmp3;
		tmp3=Sub_WavUnp2(0,*((UInt32 *)(base+0x3050)),tmp3);
		*((UInt32 *)tmp3)=(UInt32)tmp0;
		*((UInt32 *)(tmp2+4))=base;
	}
	tmp0=base+0x306c;
	for(i=0x102;i!=0;i--) {
		*((UInt32 *)tmp0)=0;
		tmp0+=4;
	}
	var_c=0;
	var_8=base+0x306C;
	tmp1=(UInt32)wav_table+(((arg1&0xff)<<7)+(arg1&0xff))*2;
	var_4=tmp1;
	tmp0=0;
	while(tmp0<0x100) {
		if(*((UInt8 *)(tmp0+tmp1))) {	
			tmp2=*((UInt32 *)(base+0x3058));
			if((SInt32)tmp2<=0) {
				tmp2=*((UInt32 *)(base+0x3068))*24+base+8;
				*((UInt32 *)(base+0x3068))=*((UInt32 *)(base+0x3068))+1;
			}
			Sub_WavUnp4(tmp2,2,0,base+0x305C);
			*((UInt32 *)(tmp2+0x10))=0;
			*((UInt32 *)(tmp2+0x14))=0;
			*((UInt32 *)var_8)=tmp2;
			*((UInt32 *)(tmp2+8))=tmp0;
			tmp3=*((UInt32 *)(tmp0+tmp1))&0xFF;
			*((UInt32 *)(tmp2+0xC))=tmp3;
			if(tmp3>=var_c)
				var_c=tmp3;
			else {
				tmp1=*((UInt32 *)(base+0x3064));
				if((SInt32)tmp1>0) {
					while(tmp1)	{
						if(*((UInt32 *)(tmp1+0xC))<tmp3)
							tmp1=*((UInt32 *)(tmp1+4));
						else
							break;
					}
				} else
					tmp1=0;
				arg1=Sub_WavUnp2(0,*((UInt32 *)(base+0x305C)),tmp2);
				if(*((UInt32 *)arg1))
					Sub_WavUnp3(arg1);
				if(tmp1)
					tmp3=Sub_WavUnp2(0,*((UInt32 *)(base+0x305C)),tmp1);
				else
					tmp3=base+0x3060;
				tmp4=*((UInt32 *)tmp3);
				*((UInt32 *)arg1)=tmp4;
				*((UInt32 *)(arg1+4))=*((UInt32 *)(tmp4+4));
				tmp1=var_4;
				*((UInt32 *)(tmp4+4))=tmp2;
				*((UInt32 *)tmp3)=arg1;
			}
		}
		var_8+=4;
		tmp0++;
	}
	if(tmp0<0x102) {
		tmp1=base+tmp0*4+0x306C;
		while(tmp0<0x102) {
			tmp2=*((UInt32 *)(base+0x3058));
			if((SInt32)tmp2<=0)	{
				tmp2=base+*((UInt32 *)(base+0x3068))*24+8;
				*((UInt32 *)(base+0x3068))=*((UInt32 *)(base+0x3068))+1;
				
			}
			Sub_WavUnp4(tmp2,1,0,base+0x305C);
			tmp1+=4;
			*((UInt32 *)(tmp2+0x10))=0;
			*((UInt32 *)(tmp2+0x14))=0;
			*((UInt32 *)(tmp1-4))=tmp2;
			*((UInt32 *)(tmp2+8))=tmp0;
			tmp0++;
			*((UInt32 *)(tmp2+0xC))=1;
		}
	}
	tmp0=*((UInt32 *)(base+0x3064));
	if((SInt32)tmp0<=0)
		tmp0=0;
	while(tmp0) {
		tmp1=*((UInt32 *)(tmp0+4));
		if((SInt32)tmp1<=0)
			tmp1=0;
		arg1=tmp1;
		if(tmp1) {
			tmp2=*((UInt32 *)(base+0x3058));
			if((SInt32)tmp2<=0)	{
				tmp2=base+*((UInt32 *)(base+0x3068))*24+8;
				*((UInt32 *)(base+0x3068))=*((UInt32 *)(base+0x3068))+1;
			}
			Sub_WavUnp4(tmp2,2,0,base+0x305C);
			*((UInt32 *)(tmp2+0x10))=0;
			*((UInt32 *)(tmp2+0x14))=0;
			*((UInt32 *)(tmp2+0x14))=tmp0;
			*((UInt32 *)(tmp2+0xC))=*((UInt32 *)(tmp1+0xC))+*((UInt32 *)(tmp0+0xC));
			*((UInt32 *)(tmp0+0x10))=tmp2;
			*((UInt32 *)(tmp1+0x10))=tmp2;
			tmp3=*((UInt32 *)(tmp2+0xC));
			if(tmp3>=var_c)
				var_c=tmp3;
			else {
				tmp1=*((UInt32 *)(tmp1+4));
				tmp0=tmp1;
				if((SInt32)tmp0<=0)
					tmp0=0;
				while(tmp0)	{
					if(*((UInt32 *)(tmp0+0xC))<tmp3) {
						tmp0=*((UInt32 *)(tmp0+4));
						if((SInt32)tmp0<=0)
							tmp0=0;
					}
					else
						break;
				}
				tmp1=Sub_WavUnp2(0,*((UInt32 *)(base+0x305C)),tmp2);
				if(*((UInt32 *)(tmp1))) {
					tmp3=Sub_WavUnp5(tmp1);
					*((UInt32 *)(tmp3))=*((UInt32 *)(tmp1));
					tmp4=*((UInt32 *)tmp1);
					*((UInt32 *)(tmp4+4))=*((UInt32 *)(tmp1+4));
					*((UInt32 *)tmp1)=0;
					*((UInt32 *)(tmp1+4))=0;
				}
				if(tmp0)
					tmp3=Sub_WavUnp2(0,*((UInt32 *)(base+0x305C)),tmp0);
				else
					tmp3=base+0x3060;
				tmp4=*((UInt32 *)(tmp3));
				*((UInt32 *)(tmp1))=tmp4;
				*((UInt32 *)(tmp1+4))=*((UInt32 *)(tmp4+4));
				*((UInt32 *)(tmp4+4))=tmp2;
				*((UInt32 *)(tmp3))=tmp1;
				tmp1=arg1;
			}
			tmp0=*((UInt32 *)(tmp1+4));
			if((SInt32)tmp0<=0)
				tmp0=0;
		} else
			break;
	}
	*((UInt32 *)(base+4))=1;
	return;		
}


// ==========================================================================
void Sub_WavUnp9(UInt32 arg1,UInt32 arg2)
{
	UInt32	var4=0,var8=0,tmp0=0,tmp1=0,tmp2=0,tmp3=0,tmp4=0;


	tmp0=*((UInt32 *)(arg2+0x3064));
	if((SInt32)tmp0<0)
		tmp0=0;
	tmp2=*((UInt32 *)(arg2+0x3058));
	if((SInt32)tmp2<0)
		tmp2=0;
	var4=arg2;
	if(tmp2==0) {
		tmp2=var4+*((UInt32 *)(var4+0x3068))*24+8;
		*((UInt32 *)(var4+0x3068))+=1;
	}
	var8=arg2+0x305C;
	tmp1=Sub_WavUnp2(0,*((UInt32 *)var8),tmp2);
	if(*((UInt32 *)tmp1)) {
		tmp3=Sub_WavUnp5(tmp1);
		*((UInt32 *)tmp3)=*((UInt32 *)tmp1);
		tmp3=*((UInt32 *)tmp1);
		*((UInt32 *)(tmp3+4))=*((UInt32 *)(tmp1+4));
		*((UInt32 *)tmp1)=0;
		*((UInt32 *)(tmp1+4))=0;
	}
	*((UInt32 *)tmp1)=var8+4;
	*((UInt32 *)(tmp1+4))=*((UInt32 *)(var8+8));
	tmp3=Sub_WavUnp2(0,*((UInt32 *)var8),Sub_WavUnp7(var8+4));
	*((UInt32 *)tmp3)=tmp1;
	*((UInt32 *)(var8+8))=tmp2;
	*((UInt32 *)(tmp2+0x10))=0;
	*((UInt32 *)(tmp2+0x14))=0;
	*((UInt32 *)(tmp2+8))=*((UInt32 *)(tmp0+8));
	*((UInt32 *)(tmp2+0xC))=*((UInt32 *)(tmp0+0xC));
	*((UInt32 *)(tmp2+0x10))=tmp0;
	*((UInt32 *)(var4+*((UInt32 *)(tmp0+8))*4+0x306C))=tmp2;
	tmp2=*((UInt32 *)(var4+0x3058));
	if((SInt32)tmp2<0)
		tmp2=0;
	if(tmp2==0)	{
		tmp2=var4+*((UInt32 *)(var4+0x3068))*24+8;
		*((UInt32 *)(var4+0x3068))+=1;
	}
	tmp1=Sub_WavUnp2(0,*((UInt32 *)var8),tmp2);
	if(*((UInt32 *)tmp1)) {
		tmp3=Sub_WavUnp5(tmp1);
		*((UInt32 *)tmp3)=*((UInt32 *)tmp1);
		tmp3=*((UInt32 *)tmp1);
		*((UInt32 *)(tmp3+4))=*((UInt32 *)(tmp1+4));
		*((UInt32 *)tmp1)=0;
		*((UInt32 *)(tmp1+4))=0;
	}
	*((UInt32 *)tmp1)=var8+4;
	*((UInt32 *)(tmp1+4))=*((UInt32 *)(var8+8));
	tmp3=Sub_WavUnp2(0,*((UInt32 *)var8),Sub_WavUnp7(var8+4));
	*((UInt32 *)tmp3)=tmp1;
	tmp3=arg1;
	*((UInt32 *)(var8+8))=tmp2;
	*((UInt32 *)(tmp2+0x14))=0;
	*((UInt32 *)(tmp2+8))=tmp3;
	*((UInt32 *)(tmp2+0xC))=0;
	*((UInt32 *)(tmp2+0x10))=tmp0;
	*((UInt32 *)(var4+tmp3*4+0x306C))=tmp2;
	*((UInt32 *)(tmp0+0x14))=tmp2;
	while(tmp2) {
		tmp4=tmp2;
		*((UInt32 *)(tmp2+0xC))+=1;
		tmp3=*((UInt32 *)(tmp2+0xC));
		while(1) {
			tmp1=*((UInt32 *)(tmp4+4));
			if((SInt32)tmp1<=0)	{
				tmp1=0;
				break;
			}
			if(*((UInt32 *)(tmp1+0xC))>=tmp3)
				break;
			tmp4=tmp1;
		}
		if(tmp4!=tmp2) {
			Sub_WavUnp4(tmp4,2,tmp2,var8);
			Sub_WavUnp4(tmp2,2,tmp1,var8);
			tmp3=*((UInt32 *)(tmp4+0x10));
			tmp1=*((UInt32 *)(tmp2+0x10));
			tmp0=*((UInt32 *)(tmp3+0x14));
			tmp3=*((UInt32 *)(tmp1+0x14));
			if(tmp3==tmp2)
				*((UInt32 *)(tmp1+0x14))=tmp4;
			if(tmp0==tmp4) {
				tmp1=*((UInt32 *)(tmp4+0x10));
				*((UInt32 *)(tmp1+0x14))=tmp2;
			}
			tmp3=*((UInt32 *)(tmp2+0x10));
			*((UInt32 *)(tmp2+0x10))=*((UInt32 *)(tmp4+0x10));
			*((UInt32 *)(tmp4+0x10))=tmp3;
			*((UInt32 *)(var4+4))+=1;
		}
		tmp2=*((UInt32 *)(tmp2+0x10));
	}
	return;
}


// ==========================================================================
void Sub_WavUnp6(UInt32 ptr_base)
{
	UInt32	ptr1=0;
	SInt32	i=0;


	ptr1=ptr_base+8;				
	for(i=0x203;i!=0;i--) {		
		*((UInt32 *)ptr1)=0;
		*((UInt32 *)(ptr1+4))=0;
		ptr1+=0x18;				
	}
	ptr1=ptr_base+0x3054;
	*((UInt32 *)ptr1)=0;
	*((UInt32 *)(ptr1+4))=0;
	*((UInt32 *)ptr1)=ptr1;
	*((UInt32 *)(ptr_base+0x3050))=0;
	*((UInt32 *)(ptr_base+0x3058))=~ptr1;
	ptr1=ptr_base+0x3060;
	*((UInt32 *)ptr1)=0;
	*((UInt32 *)(ptr1+4))=0;
	*((UInt32 *)ptr1)=(UInt32) ptr1;
	*((UInt32 *)(ptr_base+0x305C))=0;
	*((UInt32 *)(ptr_base+0x3064))=~ptr1;
	*((UInt32 *)(ptr_base+0x3068))=0;
	*((UInt32 *)(ptr_base+4))=1;
	return;
}


// ==========================================================================
UInt32 Sub_WavUnp2(UInt32 arg1,UInt32 arg2,UInt32 arg3)
{
	if(arg1)
		return arg3+arg2;
	return arg3;
}
	   

// ==========================================================================
void Sub_WavUnp3(UInt32 ptr)  
{
	UInt32 ptr0=0,ptr1=0;


	ptr0=*((UInt32 *)ptr);
	if(ptr0) {
		ptr1=*((UInt32 *)(ptr+4));
		if((SInt32)ptr1<0)
		 	ptr1=~ptr1;
		else
			ptr1=ptr1+ptr-*((UInt32 *)(ptr0+4));
		*((UInt32 *)ptr1)=ptr0;
		*((UInt32 *)(ptr0+4))=*((UInt32 *)(ptr+4));
		*((UInt32 *)ptr)=0;
		*((UInt32 *)(ptr+4))=0;
	}
	return;
}
		

// ==========================================================================
void Sub_WavUnp4(UInt32 arg1,UInt32 arg2,UInt32 arg3,UInt32 arg4)
{
	UInt32	tmp0=0,tmp1=0;


	tmp0=*((UInt32 *)arg1);
	if(tmp0) {
		tmp1=*((UInt32 *)(arg1+4));
		if((SInt32)tmp1<0)
			tmp1=~tmp1;
		else
			tmp1+=arg1-*((UInt32 *)(tmp0+4));
		*((UInt32 *)tmp1)=(UInt32)tmp0;
		*((UInt32 *)(tmp0+4))=*((UInt32 *)(arg1+4));
		*((UInt32 *)arg1)=0;
		*((UInt32 *)(arg1+4))=0;
	}
	if(arg3==0)
		arg3=arg4+4;
	if(arg2-1) {
		if((arg2-2)==0)	{
			tmp1=*((UInt32 *)arg3);
			*((UInt32 *)arg1)=tmp1;
			*((UInt32 *)(arg1+4))=*((UInt32 *)(tmp1+4));
			*((UInt32 *)(tmp1+4))=arg1;
			*((UInt32 *)arg3)=arg1;
		}
		return;
	}
	*((UInt32 *)arg1)=arg3;
	*((UInt32 *)(arg1+4))=*((UInt32 *)(arg3+4));
	tmp1=*((UInt32 *)(arg3+4));
	if((SInt32)tmp1<=0)
		tmp1=~tmp1;
	*((UInt32 *)tmp1)=arg1;
	*((UInt32 *)(arg3+4))=arg1;
	return;
}


// ==========================================================================
UInt32 Sub_WavUnp5(UInt32 arg1)
{
	UInt32 tmp0=0,tmp1=0;


	tmp0=*((UInt32 *)(arg1+4));
	if((SInt32)tmp0<0)
		return ~tmp0;
	tmp1=*((UInt32 *)arg1);
	tmp0+=arg1-*((UInt32 *)(tmp1+4));
	return tmp0;
}


// ==========================================================================
UInt32 Sub_WavUnp7(UInt32 arg1)
{
	UInt32 tmp=0;


	tmp=*((UInt32 *)(arg1+4));
	if((SInt32)tmp<=0)
		return ~tmp;
	return tmp;
}


// ==========================================================================
UInt32 Sub_WavUnp8(UInt32 arg1)
{
	UInt32	tmp0=0,tmp1=0;


	tmp0=*((UInt32 *)(arg1+4));
	*((UInt32 *)(arg1+4))=tmp0>>1;
	tmp0&=1;
	*((UInt32 *)(arg1+8))-=1;
	if(*((UInt32 *)(arg1+8))==0) {
		tmp1=*((UInt32 *)arg1);
		*((UInt32 *)arg1)+=4;
		*((UInt32 *)(arg1+4))=*((UInt32 *)tmp1);
		*((UInt32 *)(arg1+8))=0x20;
	}
	return tmp0;
}


// ==========================================================================
void Sub_WavUnp10(UInt32 arg1,UInt32 arg2)
{
	UInt32	tmp0=0,tmp1=0,tmp2=0,tmp3=0,arg2_old=0;


	arg2_old=arg2;
	while(arg1) {
		tmp2=arg1;
		*((UInt32 *)(arg1+0xC))+=1;
		tmp3=*((UInt32 *)(arg1+0xC));
		while(1) {
			tmp0=*((UInt32 *)(tmp2+4));
			if((SInt32)tmp0<=0) {
				tmp0=0;
				break;
			}
			if(*((UInt32 *)(tmp0+0xC))>=tmp3)
				break;
			tmp2=tmp0;
		}
		if(tmp2!=arg1) {
			if(*((UInt32 *)tmp2)) {
				tmp3=Sub_WavUnp5(tmp2);
				*((UInt32 *)tmp3)=*((UInt32 *)tmp2);
				tmp1=*((UInt32 *)tmp2);
				*((UInt32 *)(tmp1+4))=*((UInt32 *)(tmp2+4));
				*((UInt32 *)tmp2)=0;
				*((UInt32 *)(tmp2+4))=0;
			}
			tmp1=arg1;
			if(tmp1==0)
				tmp1=arg2+0x3060;
			tmp3=*((UInt32 *)tmp1);
			*((UInt32 *)tmp2)=tmp3;
			*((UInt32 *)(tmp2+4))=*((UInt32 *)(tmp3+4));
			*((UInt32 *)tmp1)=tmp2;
			arg2=Sub_WavUnp2(0,*((UInt32 *)(arg2+0x205C)),arg1);
			if(*((UInt32 *)arg2)) {
				tmp3=Sub_WavUnp5(arg2);
				*((UInt32 *)tmp3)=*((UInt32 *)arg2);
				tmp1=*((UInt32 *)arg2);
				*((UInt32 *)(tmp1+4))=*((UInt32 *)(arg2+4));
				*((UInt32 *)arg2)=0;
				*((UInt32 *)(arg2+4))=0;
			}
			if(tmp0)
				tmp3=Sub_WavUnp2(0,*((UInt32 *)(arg2_old+0x305C)),tmp0);
			else
				tmp3=arg2_old+0x3060;
			tmp1=*((UInt32 *)tmp3);
			*((UInt32 *)arg2)=tmp1;
			tmp0=*((UInt32 *)(tmp1+4));
			*((UInt32 *)(arg2+4))=tmp0;
			*((UInt32 *)(tmp1+4))=arg1;
			*((UInt32 *)tmp3)=arg2;
			tmp3=*((UInt32 *)(tmp2+0x10));
			tmp1=*((UInt32 *)(tmp3+0x14));
			tmp3=*((UInt32 *)(arg1+0x10));
			if(*((UInt32 *)(tmp3+0x14))==arg1)
				*((UInt32 *)(tmp3+0x14))=tmp2;
			if(tmp1==tmp2) {
				tmp1=*((UInt32 *)(tmp2+0x10));
				*((UInt32 *)(tmp1+0x14))=arg1;
			}
			tmp3=*((UInt32 *)(arg1+0x10));
			*((UInt32 *)(arg1+0x10))=*((UInt32 *)(tmp2+0x10));
			*((UInt32 *)(tmp2+0x10))=tmp3;
			arg2=arg2_old;
			*((UInt32 *)(arg2_old+4))+=1;
		}
		arg1=*((UInt32 *)(arg1+0x10));
	}
	return;
}

#ifdef WIN32
   #pragma warning (pop)
#endif
/* Header for Data Compression Library */

#include "mpqtypes.h"

#define CMP_BUFFER_SIZE 36312L	/* Work buffer size for imploding */
#define EXP_BUFFER_SIZE 12596L	/* Work buffer size for exploding */
#define CMP_BINARY          0
#define CMP_ASCII           1
#define DICT_SIZE_1      1024
#define DICT_SIZE_2      2048
#define DICT_SIZE_4      4096

#define DCL_NO_ERROR 0L
#define DCL_ERROR_1  1L
#define DCL_ERROR_2  2L
#define DCL_ERROR_3  3L
#define DCL_ERROR_4  4L

typedef UInt16 read_data_proc  (UInt8 * buffer, UInt16 size, void * param);
typedef void   write_data_proc (UInt8 * buffer, UInt16 size, void * param);

extern const UInt8 dcl_table[];

extern UInt32 implode (read_data_proc  read_data,
                       write_data_proc write_data,
                       UInt8           * work_buff,
                       void            * param,
                       UInt16          type,
                       UInt16          size);
                       
extern  UInt32 explode (read_data_proc  read_data,
                        write_data_proc write_data,
                        void            * param);
                        
extern  UInt32 crc32   (UInt8  * buffer,
                        UInt32 size,
                        UInt32 old_crc);

#ifndef _MPQTYPES_H_

#define _MPQTYPES_H_

#include <stdio.h>

#define UInt8	unsigned char
#define UInt16	unsigned short int
#define SInt16	short int
#define UInt32	unsigned long
#define SInt32	long

#define DWORD unsigned long

#define MPQTYPES_MAX_PATH   256


// global datas for reading mpq
typedef struct GLB_MPQ_S
{
   int   is_open;          // FALSE / TRUE

   DWORD	offset_mpq;			// Offset to MPQ file data
   DWORD	offset_htbl;		// Offset to hash_table of MPQ
   DWORD	offset_btbl;		// Offset to block_table of MPQ
   DWORD	lenght_mpq_part;	// Lenght of MPQ file data
   DWORD	lenght_htbl;		// Lenght of hash table
   DWORD	lenght_btbl;		// Lenght of block table
   DWORD	*hash_table;		// Hash table
   DWORD	*block_table;		// Block table
   DWORD	count_files;		// Number of files in MPQ (calculated from size of block_table)
   DWORD	massive_base[0x500];// This massive is used to calculate crc and decode files, 
                                // ËøôÂÆûÈôÖ‰∏äÂ∞±ÊòØ‰∏™Êü•ÊâæË°®ËÄåÂ∑≤

   char	*filename_table;	// Array of MPQ filenames
   char	*identify_table;	// Bitmap table of MPQ filenames 1 - if file name for this entry is known, 0 - if is not

   char	file_name[257];		// Name of archive
   char	work_dir[MPQTYPES_MAX_PATH];	// Work directory
   char	prnbuf[MPQTYPES_MAX_PATH+100];	// Buffer
   char	default_list[MPQTYPES_MAX_PATH];// Path to list file
   FILE	*fpMpq;

   // This is used to decompress DCL-compressed and WAVE files
   DWORD	 avail_metods[4];//={0x08,0x01,0x40,0x80};
   DWORD	 lenght_write;
   UInt8  * global_buffer, * read_buffer_start, * write_buffer_start, * explode_buffer;
   UInt32 * file_header;
} GLB_MPQ_S;

extern GLB_MPQ_S * glb_mpq;

#endif

#ifndef _MPQVIEW_H_

#define  _MPQVIEW_H_

int  mod_load_in_mem       (char * moddir, char * filename, void ** buffer, long * buf_len);
int  mpq_load_in_mem       (char * mpqname, char * filename, void ** buffer, long * buf_len, int output);
void mpq_batch_open        (char * mpqname);
int  mpq_batch_load_in_mem (char * filename, void ** buffer, long * buf_len, int output);
void mpq_batch_close       (void);

#endif
/* WAVE decompression table */

#include "mpqtypes.h"

UInt8 wav_table[2512] =
{	0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
	0x00, 0x00, 0x54, 0x16, 0x16, 0x0D, 0x0C, 0x08,
	0x06, 0x05, 0x06, 0x05, 0x06, 0x03, 0x04, 0x04,
	0x03, 0x05, 0x0E, 0x0B, 0x14, 0x13, 0x13, 0x09,
	0x0B, 0x06, 0x05, 0x04, 0x03, 0x02, 0x03, 0x02,
	0x02, 0x02, 0x0D, 0x07, 0x09, 0x06, 0x06, 0x04,
	0x03, 0x02, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03,
	0x02, 0x02, 0x09, 0x06, 0x04, 0x04, 0x04, 0x04,
	0x03, 0x02, 0x03, 0x02, 0x02, 0x02, 0x02, 0x03,
	0x02, 0x04, 0x08, 0x03, 0x04, 0x07, 0x09, 0x05,
	0x03, 0x03, 0x03, 0x03, 0x02, 0x02, 0x02, 0x03,
	0x02, 0x02, 0x03, 0x02, 0x02, 0x02, 0x02, 0x02,
	0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x02, 0x01,
	0x02, 0x02, 0x06, 0x0A, 0x08, 0x08, 0x06, 0x07,
	0x04, 0x03, 0x04, 0x04, 0x02, 0x02, 0x04, 0x02,
	0x03, 0x03, 0x04, 0x03, 0x07, 0x07, 0x09, 0x06,
	0x04, 0x03, 0x03, 0x02, 0x01, 0x02, 0x02, 0x02,
	0x02, 0x02, 0x0A, 0x02, 0x02, 0x03, 0x02, 0x02,
	0x01, 0x01, 0x02, 0x02, 0x02, 0x06, 0x03, 0x05,
	0x02, 0x03, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01,
	0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x02, 0x04, 0x04, 0x04, 0x07, 0x09, 0x08,
	0x0C, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01,
	0x01, 0x03, 0x04, 0x01, 0x02, 0x04, 0x05, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01,
	0x01, 0x01, 0x04, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x02, 0x02, 0x01, 0x01, 0x02, 0x02, 0x02,
	0x06, 0x4B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x27, 0x00,
	0x00, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xFF, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x01, 0x01,
	0x06, 0x0E, 0x10, 0x04, 0x06, 0x08, 0x05, 0x04,
	0x04, 0x03, 0x03, 0x02, 0x02, 0x03, 0x03, 0x01,
	0x01, 0x02, 0x01, 0x01, 0x01, 0x04, 0x02, 0x04,
	0x02, 0x02, 0x02, 0x01, 0x01, 0x04, 0x01, 0x01,
	0x02, 0x03, 0x03, 0x02, 0x03, 0x01, 0x03, 0x06,
	0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02,
	0x01, 0x02, 0x01, 0x01, 0x01, 0x29, 0x07, 0x16,
	0x12, 0x40, 0x0A, 0x0A, 0x11, 0x25, 0x01, 0x03,
	0x17, 0x10, 0x26, 0x2A, 0x10, 0x01, 0x23, 0x23,
	0x2F, 0x10, 0x06, 0x07, 0x02, 0x09, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x0B,
	0x07, 0x05, 0x0B, 0x02, 0x02, 0x02, 0x06, 0x02,
	0x02, 0x01, 0x04, 0x02, 0x01, 0x03, 0x09, 0x01,
	0x01, 0x01, 0x03, 0x04, 0x01, 0x01, 0x02, 0x01,
	0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x05, 0x01,
	0x01, 0x01, 0x0D, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01,
	0x01, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x0A, 0x04,
	0x02, 0x01, 0x06, 0x03, 0x02, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x03, 0x01, 0x01, 0x01, 0x05, 0x02,
	0x03, 0x04, 0x03, 0x03, 0x03, 0x02, 0x01, 0x01,
	0x01, 0x02, 0x01, 0x02, 0x03, 0x03, 0x01, 0x03,
	0x01, 0x01, 0x02, 0x05, 0x01, 0x01, 0x04, 0x03,
	0x05, 0x01, 0x03, 0x01, 0x03, 0x03, 0x02, 0x01,
	0x04, 0x03, 0x0A, 0x06, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02,
	0x01, 0x0A, 0x02, 0x05, 0x01, 0x01, 0x02, 0x07,
	0x02, 0x17, 0x01, 0x05, 0x01, 0x01, 0x0E, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x06, 0x02,
	0x01, 0x04, 0x05, 0x01, 0x01, 0x02, 0x01, 0x01,
	0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01,
	0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x11, 0x00, 0x00,
	0xFF, 0xFB, 0x98, 0x9A, 0x84, 0x85, 0x63, 0x64,
	0x3E, 0x3E, 0x22, 0x22, 0x13, 0x13, 0x18, 0x17,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xFF, 0xF1, 0x9D, 0x9E, 0x9A, 0x9B,
	0x9A, 0x97, 0x93, 0x93, 0x8C, 0x8E, 0x86, 0x88,
	0x80, 0x82, 0x7C, 0x7C, 0x72, 0x73, 0x69, 0x6B,
	0x5F, 0x60, 0x55, 0x56, 0x4A, 0x4B, 0x40, 0x41,
	0x37, 0x37, 0x2F, 0x2F, 0x27, 0x27, 0x21, 0x21,
	0x1B, 0x1C, 0x17, 0x17, 0x13, 0x13, 0x10, 0x10,
	0x0D, 0x0D, 0x0B, 0x0B, 0x09, 0x09, 0x08, 0x08,
	0x07, 0x07, 0x06, 0x05, 0x05, 0x04, 0x04, 0x04,
	0x19, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xC3, 0xCB, 0xF5, 0x41,
	0xFF, 0x7B, 0xF7, 0x21, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xBF, 0xCC, 0xF2, 0x40,
	0xFD, 0x7C, 0xF7, 0x22, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x7A, 0x46, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC3, 0xD9,
	0xEF, 0x3D, 0xF9, 0x7C, 0xE9, 0x1E, 0xFD, 0xAB,
	0xF1, 0x2C, 0xFC, 0x5B, 0xFE, 0x17, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBD, 0xD9,
	0xEC, 0x3D, 0xF5, 0x7D, 0xE8, 0x1D, 0xFB, 0xAE,
	0xF0, 0x2C, 0xFB, 0x5C, 0xFF, 0x18, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x6C,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBA, 0xC5, 0xDA, 0x33, 0xE3, 0x6D, 0xD8, 0x18,
	0xE5, 0x94, 0xDA, 0x23, 0xDF, 0x4A, 0xD1, 0x10,
	0xEE, 0xAF, 0xE4, 0x2C, 0xEA, 0x5A, 0xDE, 0x15,
	0xF4, 0x87, 0xE9, 0x21, 0xF6, 0x43, 0xFC, 0x12,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xB0, 0xC7, 0xD8, 0x33, 0xE3, 0x6B, 0xD6, 0x18,
	0xE7, 0x95, 0xD8, 0x23, 0xDB, 0x49, 0xD0, 0x11,
	0xE9, 0xB2, 0xE2, 0x2B, 0xE8, 0x5C, 0xDD, 0x15,
	0xF1, 0x87, 0xE7, 0x20, 0xF7, 0x44, 0xFF, 0x13,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5F, 0x9E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x33, 0x00, 0x00, 0x00, 0x66, 0x00, 0x00, 0x00,
	0x3A, 0x00, 0x00, 0x00, 0x3A, 0x00, 0x00, 0x00,
	0x50, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00,
	0x3A, 0x00, 0x00, 0x00, 0x3A, 0x00, 0x00, 0x00,
	0x3A, 0x00, 0x00, 0x00, 0x3A, 0x00, 0x00, 0x00,
	0x4D, 0x00, 0x00, 0x00, 0x66, 0x00, 0x00, 0x00,
	0x80, 0x00, 0x00, 0x00, 0x9A, 0x00, 0x00, 0x00,
	0x3A, 0x00, 0x00, 0x00, 0x3A, 0x00, 0x00, 0x00,
	0x3A, 0x00, 0x00, 0x00, 0x3A, 0x00, 0x00, 0x00,
	0x3A, 0x00, 0x00, 0x00, 0x3A, 0x00, 0x00, 0x00,
	0x3A, 0x00, 0x00, 0x00, 0x3A, 0x00, 0x00, 0x00,
	0x3A, 0x00, 0x00, 0x00, 0x3A, 0x00, 0x00, 0x00,
	0x3A, 0x00, 0x00, 0x00, 0x3A, 0x00, 0x00, 0x00,
	0x3A, 0x00, 0x00, 0x00, 0x3A, 0x00, 0x00, 0x00,
	0x3A, 0x00, 0x00, 0x00, 0x3A, 0x00, 0x00, 0x00,
	0x46, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00,
	0x60, 0x00, 0x00, 0x00, 0x6D, 0x00, 0x00, 0x00,
	0x7A, 0x00, 0x00, 0x00, 0x86, 0x00, 0x00, 0x00,
	0x93, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00,
	0xAD, 0x00, 0x00, 0x00, 0xBA, 0x00, 0x00, 0x00,
	0xC6, 0x00, 0x00, 0x00, 0xD3, 0x00, 0x00, 0x00,
	0xE0, 0x00, 0x00, 0x00, 0xED, 0x00, 0x00, 0x00,
	0xFA, 0x00, 0x00, 0x00, 0x06, 0x01, 0x00, 0x00
};

UInt32 small_tbl1[90] =
{
	0x7,    0x8,    0x9,    0xA,    0xB,    0xC,    0xD,    0xE,    0x10,   0x11,
	0x13,   0x15,   0x17,   0x19,   0x1C,   0x1F,   0x22,   0x25,   0x29,   0x2D,
	0x32,   0x37,   0x3C,   0x42,   0x49,   0x50,   0x58,   0x61,   0x6B,   0x76,
	0x82,   0x8F,   0x9D,   0xAD,   0xBE,   0xD1,   0xE6,   0xFD,   0x117,  0x133,
	0x151,  0x173,  0x198,  0x1C1,  0x1EE,  0x220,  0x256,  0x292,  0x2D4,  0x31C,
	0x36C,  0x3C3,  0x424,  0x48E,  0x502,  0x583,  0x610,  0x6AB,  0x756,  0x812,
	0x8E0,  0x9C3,  0xABD,  0xBD0,  0xCFF,  0xE4C,  0xFBA,  0x114C, 0x1307, 0x14EE,
	0x1706, 0x1954, 0x1BDC, 0x1EA5, 0x21B6, 0x2515, 0x28CA, 0x2CDF, 0x315B, 0x364B,
	0x3BB9, 0x41B2, 0x4844, 0x4F7E, 0x5771, 0x602F, 0x69CE, 0x7462, 0x7FFF, 0x0
};

UInt32 small_tbl2[32] =
{
	0xFFFFFFFF, 0x0, 0xFFFFFFFF, 0x4, 0xFFFFFFFF, 0x2, 0xFFFFFFFF, 0x6,
	0xFFFFFFFF, 0x1, 0xFFFFFFFF, 0x5, 0xFFFFFFFF, 0x3, 0xFFFFFFFF, 0x7,
	0xFFFFFFFF, 0x1, 0xFFFFFFFF, 0x5, 0xFFFFFFFF, 0x3, 0xFFFFFFFF, 0x7,
	0xFFFFFFFF, 0x2, 0xFFFFFFFF, 0x4, 0xFFFFFFFF, 0x6, 0xFFFFFFFF, 0x8
};

